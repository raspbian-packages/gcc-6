# DP: updates from the 6 branch upto 20170920 (r253004).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Wed Sep 20 11:26:17 CEST 2017
Wed Sep 20 09:26:17 UTC 2017 (revision 253004)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_6_4_0_release svn://gcc.gnu.org/svn/gcc/branches/gcc-6-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,23 @@
+2017-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2017-09-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/81314
+	* testsuite/libgomp.c++/pr81314.C: New test.
+
+	2017-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/81687
+	* testsuite/libgomp.c/pr81687-1.c: New test.
+	* testsuite/libgomp.c/pr81687-2.c: New test.
+
+	2017-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/45784
+	* testsuite/libgomp.c/pr45784.c: New test.
+	* testsuite/libgomp.c++/pr45784.C: New test.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: libgomp/testsuite/libgomp.c++/pr81314.C
===================================================================
--- a/src/libgomp/testsuite/libgomp.c++/pr81314.C	(.../tags/gcc_6_4_0_release)
+++ b/src/libgomp/testsuite/libgomp.c++/pr81314.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,38 @@
+// PR c++/81314
+// { dg-do link }
+
+template <int N>
+struct S {
+  S () { s = 0; }
+  S (const S &x) { s = x.s; }
+  ~S () {}
+  int s;
+};
+
+void
+foo (S<2> &x)
+{
+  #pragma omp taskloop
+  for (int i = 0; i < 100; ++i)
+    x.s++;
+}
+
+void
+bar (S<3> &x)
+{
+  #pragma omp task
+  x.s++;
+}
+
+int
+main ()
+{
+  S<2> s;
+  S<3> t;
+  #pragma omp parallel
+  #pragma omp master
+  {
+    foo (s);
+    bar (t);
+  }
+}
Index: libgomp/testsuite/libgomp.c++/pr45784.C
===================================================================
--- a/src/libgomp/testsuite/libgomp.c++/pr45784.C	(.../tags/gcc_6_4_0_release)
+++ b/src/libgomp/testsuite/libgomp.c++/pr45784.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,5 @@
+// PR c/45784
+// { dg-do run }
+
+#include "../libgomp.c/pr45784.c"
+
Index: libgomp/testsuite/libgomp.c/pr81687-2.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr81687-2.c	(.../tags/gcc_6_4_0_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr81687-2.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,27 @@
+/* PR c/81687 */
+/* { dg-do link } */
+/* { dg-additional-options "-O2" } */
+
+int
+main ()
+{
+  __label__ lab4, lab5, lab6;
+  volatile int l = 0;
+  int m = l;
+  void foo (int x) { if (x == 1) goto lab4; }
+  void bar (int x) { if (x == 2) goto lab5; }
+  void baz (int x) { if (x == 3) goto lab6; }
+  #pragma omp parallel
+  {
+    foo (m + 1);
+   lab4:;
+  }
+  #pragma omp task
+  {
+    bar (m + 2);
+   lab5:;
+  }
+  baz (m + 3);
+ lab6:;
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/pr45784.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr45784.c	(.../tags/gcc_6_4_0_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr45784.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,41 @@
+/* PR c/45784 */
+/* { dg-do run } */
+
+void
+foo (int n)
+{
+  char *p, vla[2 * n];
+  int i;
+  #pragma omp parallel for
+  for (p = vla; p < vla + (sizeof (vla) / sizeof (vla[0])); p++)
+    *p = ' ';
+  #pragma omp parallel for
+  for (i = 0; i < 2 * n; i++)
+    if (vla[i] != ' ')
+      __builtin_abort ();
+}
+
+void
+bar (int n)
+{
+  char *p, vla1[n], vla2[n * 2], vla3[n * 3], vla4[n * 4];
+  int i;
+  __builtin_memset (vla4, ' ', n * 4);
+  #pragma omp parallel for
+  for (p = vla4 + sizeof (vla1); p < vla4 + sizeof (vla3) - sizeof (vla2) + sizeof (vla1); p += sizeof (vla4) / sizeof (vla4))
+    p[0] = '!';
+  #pragma omp parallel for
+  for (i = 0; i < n * 4; i++)
+    if (vla4[i] != ((i >= n && i < 2 * n) ? '!' : ' '))
+      __builtin_abort ();
+}
+
+int
+main ()
+{
+  volatile int n;
+  n = 128;
+  foo (n);
+  bar (n);
+  return 0;
+}
Index: libgomp/testsuite/libgomp.c/pr81687-1.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr81687-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr81687-1.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,23 @@
+/* PR c/81687 */
+/* { dg-do link } */
+/* { dg-additional-options "-O2" } */
+
+extern int printf (const char *, ...);
+
+int
+main ()
+{
+  #pragma omp parallel
+  {
+   lab1:
+    printf ("lab1=%p\n", (void *)(&&lab1));
+  }
+ lab2:
+  #pragma omp parallel
+  {
+   lab3:
+    printf ("lab2=%p\n", (void *)(&&lab2));
+  }
+  printf ("lab3=%p\n", (void *)(&&lab3));
+  return 0;
+}
Index: libquadmath/ChangeLog
===================================================================
--- a/src/libquadmath/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/libquadmath/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,8 @@
+2017-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libquadmath/65757
+	* math/roundq.c: Cherry-pick upstream glibc 2015-04-28 change.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: libquadmath/math/roundq.c
===================================================================
--- a/src/libquadmath/math/roundq.c	(.../tags/gcc_6_4_0_release)
+++ b/src/libquadmath/math/roundq.c	(.../branches/gcc-6-branch)
@@ -1,5 +1,5 @@
 /* Round __float128 to integer away from zero.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
+   Copyright (C) 1997-2017 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997 and
 		  Jakub Jelinek <jj@ultra.linux.cz>, 1999.
@@ -32,7 +32,7 @@
 
   GET_FLT128_WORDS64 (i0, i1, x);
   j0 = ((i0 >> 48) & 0x7fff) - 0x3fff;
-  if (j0 < 31)
+  if (j0 < 48)
     {
       if (j0 < 0)
 	{
Index: libsanitizer/sanitizer_common/sanitizer_linux.cc
===================================================================
--- a/src/libsanitizer/sanitizer_common/sanitizer_linux.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libsanitizer/sanitizer_common/sanitizer_linux.cc	(.../branches/gcc-6-branch)
@@ -546,8 +546,7 @@
 }
 #endif
 
-uptr internal_sigaltstack(const struct sigaltstack *ss,
-                         struct sigaltstack *oss) {
+uptr internal_sigaltstack(const void *ss, void *oss) {
   return internal_syscall(SYSCALL(sigaltstack), (uptr)ss, (uptr)oss);
 }
 
Index: libsanitizer/sanitizer_common/sanitizer_linux.h
===================================================================
--- a/src/libsanitizer/sanitizer_common/sanitizer_linux.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libsanitizer/sanitizer_common/sanitizer_linux.h	(.../branches/gcc-6-branch)
@@ -19,7 +19,6 @@
 #include "sanitizer_platform_limits_posix.h"
 
 struct link_map;  // Opaque type returned by dlopen().
-struct sigaltstack;
 
 namespace __sanitizer {
 // Dirent structure for getdents(). Note that this structure is different from
@@ -28,8 +27,7 @@
 
 // Syscall wrappers.
 uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);
-uptr internal_sigaltstack(const struct sigaltstack* ss,
-                          struct sigaltstack* oss);
+uptr internal_sigaltstack(const void* ss, void* oss);
 uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,
     __sanitizer_sigset_t *oldset);
 void internal_sigfillset(__sanitizer_sigset_t *set);
Index: libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc
===================================================================
--- a/src/libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc	(.../branches/gcc-6-branch)
@@ -267,7 +267,7 @@
 
   // Alternate stack for signal handling.
   InternalScopedBuffer<char> handler_stack_memory(kHandlerStackSize);
-  struct sigaltstack handler_stack;
+  stack_t handler_stack;
   internal_memset(&handler_stack, 0, sizeof(handler_stack));
   handler_stack.ss_sp = handler_stack_memory.data();
   handler_stack.ss_size = kHandlerStackSize;
Index: libsanitizer/ChangeLog
===================================================================
--- a/src/libsanitizer/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/libsanitizer/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,14 @@
+2017-09-07  Matthias Klose  <doko@ubuntu.com>
+
+	Backported from mainline
+	2017-07-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/81066
+	* sanitizer_common/sanitizer_linux.h: Cherry-pick upstream r307969.
+	* sanitizer_common/sanitizer_linux.cc: Likewise.
+	* sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc: Likewise.
+	* tsan/tsan_platform_linux.cc: Likewise.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: libsanitizer/tsan/tsan_platform_linux.cc
===================================================================
--- a/src/libsanitizer/tsan/tsan_platform_linux.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libsanitizer/tsan/tsan_platform_linux.cc	(.../branches/gcc-6-branch)
@@ -291,7 +291,7 @@
 int ExtractResolvFDs(void *state, int *fds, int nfd) {
 #if SANITIZER_LINUX
   int cnt = 0;
-  __res_state *statp = (__res_state*)state;
+  struct __res_state *statp = (struct __res_state*)state;
   for (int i = 0; i < MAXNS && cnt < nfd; i++) {
     if (statp->_u._ext.nsaddrs[i] && statp->_u._ext.nssocks[i] != -1)
       fds[cnt++] = statp->_u._ext.nssocks[i];
Index: libstdc++-v3/src/c++98/misc-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++98/misc-inst.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++98/misc-inst.cc	(.../branches/gcc-6-branch)
@@ -36,34 +36,6 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  // string related to iostreams
-  template 
-    basic_istream<char>& 
-    operator>>(basic_istream<char>&, string&);
-  template 
-    basic_ostream<char>& 
-    operator<<(basic_ostream<char>&, const string&);
-  template 
-    basic_istream<char>& 
-    getline(basic_istream<char>&, string&, char);
-  template 
-    basic_istream<char>& 
-    getline(basic_istream<char>&, string&);
-#ifdef _GLIBCXX_USE_WCHAR_T
-  template 
-    basic_istream<wchar_t>& 
-    operator>>(basic_istream<wchar_t>&, wstring&);
-  template 
-    basic_ostream<wchar_t>& 
-    operator<<(basic_ostream<wchar_t>&, const wstring&);
-  template 
-    basic_istream<wchar_t>& 
-    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
-  template 
-    basic_istream<wchar_t>& 
-    getline(basic_istream<wchar_t>&, wstring&);
-#endif
-
 #if _GLIBCXX_USE_CXX11_ABI
   // C++98 members that are not instantiated by src/c++11/string-inst.cc
   // because they changed in C++11 to take const_iterator parameters.
Index: libstdc++-v3/src/c++11/cow-wstring-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/cow-wstring-inst.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/cow-wstring-inst.cc	(.../branches/gcc-6-branch)
@@ -33,32 +33,8 @@
 #define C wchar_t
 #include "string-inst.cc"
 
-#include <ostream>
-#include <istream>
-
 #if ! _GLIBCXX_USE_DUAL_ABI
 # error This file should not be compiled for this configuration.
 #endif
 
-namespace std _GLIBCXX_VISIBILITY(default)
-{
-_GLIBCXX_BEGIN_NAMESPACE_VERSION
-
-  // XXX these came from c++98/misc-inst.cc, repeat them for COW string
-  // string related to iostreams
-  template 
-    basic_istream<wchar_t>& 
-    operator>>(basic_istream<wchar_t>&, wstring&);
-  template 
-    basic_ostream<wchar_t>& 
-    operator<<(basic_ostream<wchar_t>&, const wstring&);
-  template 
-    basic_istream<wchar_t>& 
-    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
-  template 
-    basic_istream<wchar_t>& 
-    getline(basic_istream<wchar_t>&, wstring&);
-
-_GLIBCXX_END_NAMESPACE_VERSION
-} // namespace
 #endif
Index: libstdc++-v3/src/c++11/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++11/Makefile.in	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/Makefile.in	(.../branches/gcc-6-branch)
@@ -97,8 +97,11 @@
 	system_error.lo thread.lo $(am__objects_1) $(am__objects_2)
 @ENABLE_DUAL_ABI_TRUE@am__objects_4 = cow-fstream-inst.lo \
 @ENABLE_DUAL_ABI_TRUE@	cow-sstream-inst.lo cow-string-inst.lo \
-@ENABLE_DUAL_ABI_TRUE@	cow-wstring-inst.lo cxx11-locale-inst.lo \
-@ENABLE_DUAL_ABI_TRUE@	cxx11-wlocale-inst.lo
+@ENABLE_DUAL_ABI_TRUE@	cow-string-io-inst.lo \
+@ENABLE_DUAL_ABI_TRUE@	cow-wstring-inst.lo \
+@ENABLE_DUAL_ABI_TRUE@	cow-wstring-io-inst.lo \
+@ENABLE_DUAL_ABI_TRUE@	cxx11-locale-inst.lo \
+@ENABLE_DUAL_ABI_TRUE@	cxx11-wlocale-inst.lo sso_string.lo
 @ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_5 = $(am__objects_4) \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	ext11-inst.lo fstream-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	ios-inst.lo iostream-inst.lo \
@@ -105,7 +108,9 @@
 @ENABLE_EXTERN_TEMPLATE_TRUE@	istream-inst.lo locale-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	ostream-inst.lo sstream-inst.lo \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	streambuf-inst.lo string-inst.lo \
-@ENABLE_EXTERN_TEMPLATE_TRUE@	wlocale-inst.lo wstring-inst.lo
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-io-inst.lo wlocale-inst.lo \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	wstring-inst.lo \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	wstring-io-inst.lo
 am_libc__11convenience_la_OBJECTS = $(am__objects_3) $(am__objects_5)
 libc__11convenience_la_OBJECTS = $(am_libc__11convenience_la_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
@@ -395,9 +400,12 @@
 @ENABLE_DUAL_ABI_TRUE@	cow-fstream-inst.cc \
 @ENABLE_DUAL_ABI_TRUE@	cow-sstream-inst.cc \
 @ENABLE_DUAL_ABI_TRUE@	cow-string-inst.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-string-io-inst.cc \
 @ENABLE_DUAL_ABI_TRUE@	cow-wstring-inst.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-wstring-io-inst.cc \
 @ENABLE_DUAL_ABI_TRUE@	cxx11-locale-inst.cc \
-@ENABLE_DUAL_ABI_TRUE@	cxx11-wlocale-inst.cc
+@ENABLE_DUAL_ABI_TRUE@	cxx11-wlocale-inst.cc \
+@ENABLE_DUAL_ABI_TRUE@	sso_string.cc
 
 # XTEMPLATE_FLAGS =
 @ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = 
@@ -415,8 +423,10 @@
 @ENABLE_EXTERN_TEMPLATE_TRUE@	sstream-inst.cc \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	streambuf-inst.cc \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-io-inst.cc \
 @ENABLE_EXTERN_TEMPLATE_TRUE@	wlocale-inst.cc \
-@ENABLE_EXTERN_TEMPLATE_TRUE@	wstring-inst.cc
+@ENABLE_EXTERN_TEMPLATE_TRUE@	wstring-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	wstring-io-inst.cc
 
 libc__11convenience_la_SOURCES = $(sources)  $(inst_sources)
 
Index: libstdc++-v3/src/c++11/cow-string-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/cow-string-inst.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/cow-string-inst.cc	(.../branches/gcc-6-branch)
@@ -29,35 +29,10 @@
 #define _GLIBCXX_USE_CXX11_ABI 0
 #include "string-inst.cc"
 
-#include <istream>
-#include <ostream>
-
 #if ! _GLIBCXX_USE_DUAL_ABI
 # error This file should not be compiled for this configuration.
 #endif
 
-namespace std _GLIBCXX_VISIBILITY(default)
-{
-_GLIBCXX_BEGIN_NAMESPACE_VERSION
-
-  // These came from c++98/misc-inst.cc, repeat them for COW string
-  // string related to iostreams.
-  template 
-    basic_istream<char>& 
-    operator>>(basic_istream<char>&, string&);
-  template 
-    basic_ostream<char>& 
-    operator<<(basic_ostream<char>&, const string&);
-  template 
-    basic_istream<char>& 
-    getline(basic_istream<char>&, string&, char);
-  template 
-    basic_istream<char>& 
-    getline(basic_istream<char>&, string&);
-
-_GLIBCXX_END_NAMESPACE_VERSION
-} // namespace
-
 #ifdef  _GLIBCXX_USE_C99_STDINT_TR1
 #include <random>
 #if defined __i386__ || defined __x86_64__
Index: libstdc++-v3/src/c++11/regex.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/regex.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/regex.cc	(.../branches/gcc-6-branch)
@@ -24,11 +24,17 @@
 
 #include <stdexcept>
 #include <bits/regex_error.h>
+#include <bits/functexcept.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  void
+  __throw_regex_error(regex_constants::error_type __ecode
+		      __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(regex_error(__ecode)); }
+
   regex_error::regex_error(regex_constants::error_type __ecode)
   : std::runtime_error("regex_error"), _M_code(__ecode)
   { }
Index: libstdc++-v3/src/c++11/future.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/future.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/future.cc	(.../branches/gcc-6-branch)
@@ -23,6 +23,7 @@
 // <http://www.gnu.org/licenses/>.
 
 #include <future>
+#include <bits/functexcept.h>
 
 namespace
 {
@@ -70,6 +71,10 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  void
+  __throw_future_error(int __i __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(future_error(make_error_code(future_errc(__i)))); }
+
   const error_category& future_category() noexcept
   { return __future_category_instance(); }
 
Index: libstdc++-v3/src/c++11/cow-string-io-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/cow-string-io-inst.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/cow-string-io-inst.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,59 @@
+// Reference-counted COW string instantiations for I/O -*- C++ -*-
+
+// Copyright (C) 2014-2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882: 21  Strings library
+//
+
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include <istream>
+#include <ostream>
+
+#if ! _GLIBCXX_USE_DUAL_ABI
+# error This file should not be compiled for this configuration.
+#endif
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // The equivalent SSO string instantiations are in c++98/misc-inst.cc,
+  // repeat them for COW string
+
+  // string related to iostreams.
+  template
+    basic_istream<char>&
+    operator>>(basic_istream<char>&, string&);
+  template
+    basic_ostream<char>&
+    operator<<(basic_ostream<char>&, const string&);
+  template
+    basic_istream<char>&
+    getline(basic_istream<char>&, string&, char);
+  template
+    basic_istream<char>&
+    getline(basic_istream<char>&, string&);
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/src/c++11/string-io-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/string-io-inst.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/string-io-inst.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,53 @@
+// SSO string instantiations for I/O -*- C++ -*-
+
+// Copyright (C) 1997-2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882:
+//
+
+#define _GLIBCXX_USE_CXX11_ABI 1
+#include <string>
+#include <istream>
+#include <ostream>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // string related to iostreams
+  template
+    basic_istream<char>&
+    operator>>(basic_istream<char>&, string&);
+  template
+    basic_ostream<char>&
+    operator<<(basic_ostream<char>&, const string&);
+  template
+    basic_istream<char>&
+    getline(basic_istream<char>&, string&, char);
+  template
+    basic_istream<char>&
+    getline(basic_istream<char>&, string&);
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/src/c++11/functexcept.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/functexcept.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/functexcept.cc	(.../branches/gcc-6-branch)
@@ -20,9 +20,6 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
-// We don't want to change the type thrown by __throw_ios_failure (yet?)
-#define _GLIBCXX_USE_CXX11_ABI 0
-
 #include <bits/functexcept.h>
 #include <cstdlib>
 #include <exception>
@@ -29,11 +26,6 @@
 #include <stdexcept>
 #include <new>
 #include <typeinfo>
-#include <ios>
-#include <system_error>
-#include <future>
-#include <functional>
-#include <bits/regex_error.h>
 #include <stdarg.h>
 
 #ifdef _GLIBCXX_USE_NLS
@@ -121,27 +113,5 @@
   __throw_underflow_error(const char* __s __attribute__((unused)))
   { _GLIBCXX_THROW_OR_ABORT(underflow_error(_(__s))); }
 
-  void
-  __throw_ios_failure(const char* __s __attribute__((unused)))
-  { _GLIBCXX_THROW_OR_ABORT(ios_base::failure(_(__s))); }
-
-  void
-  __throw_system_error(int __i __attribute__((unused)))
-  { _GLIBCXX_THROW_OR_ABORT(system_error(error_code(__i,
-						    generic_category()))); }
-
-  void
-  __throw_future_error(int __i __attribute__((unused)))
-  { _GLIBCXX_THROW_OR_ABORT(future_error(make_error_code(future_errc(__i)))); }
-
-  void
-  __throw_bad_function_call()
-  { _GLIBCXX_THROW_OR_ABORT(bad_function_call()); }
-
-  void
-  __throw_regex_error(regex_constants::error_type __ecode
-		      __attribute__((unused)))
-  { _GLIBCXX_THROW_OR_ABORT(regex_error(__ecode)); }
-
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/src/c++11/ios.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/ios.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/ios.cc	(.../branches/gcc-6-branch)
@@ -26,13 +26,29 @@
 // ISO C++ 14882: 27.4  Iostreams base classes
 //
 
+// Determines the version of ios_base::failure thrown by __throw_ios_failure.
+// If !_GLIBCXX_USE_DUAL_ABI this will get undefined automatically.
+#define _GLIBCXX_USE_CXX11_ABI 0
+
 #include <ios>
 #include <limits>
+#include <bits/functexcept.h>
 
+#ifdef _GLIBCXX_USE_NLS
+# include <libintl.h>
+# define _(msgid)   gettext (msgid)
+#else
+# define _(msgid)   (msgid)
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  void
+  __throw_ios_failure(const char* __s __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(ios_base::failure(_(__s))); }
+
   // Definitions for static const members of ios_base.
   const ios_base::fmtflags ios_base::boolalpha;
   const ios_base::fmtflags ios_base::dec;
Index: libstdc++-v3/src/c++11/sso_string.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/sso_string.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/sso_string.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,107 @@
+// Helper for accessing __cxx11::string from the ABI -*- C++ -*-
+
+// Copyright (C) 2014-2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+
+#define _GLIBCXX_USE_CXX11_ABI 1
+#define __sso_string __sso_stringxxx
+#include <string>
+#include <stdexcept>
+#undef __sso_string
+
+#if ! _GLIBCXX_USE_DUAL_ABI
+# error This file should not be compiled for this configuration.
+#endif
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wabi-tag"
+  // Redefine __sso_string so that we can define and export its members
+  // in terms of the SSO std::string.
+  struct __sso_string
+  {
+    struct __str
+    {
+      const char* _M_p;
+      size_t _M_string_length;
+      char _M_local_buf[16];
+    };
+
+    union {
+      __str _M_s;
+      char _M_bytes[sizeof(_M_s)];
+      std::string _M_str;
+    };
+
+    __sso_string();
+    __sso_string(const std::string& s);
+    __sso_string(const char*, size_t n);
+    __sso_string(const __sso_string&) noexcept;
+    __sso_string& operator=(const __sso_string&) noexcept;
+    ~__sso_string();
+    __sso_string(__sso_string&&) noexcept;
+    __sso_string& operator=(__sso_string&&) noexcept;
+  };
+#pragma GCC diagnostic pop
+
+  __sso_string::__sso_string() : _M_str() { }
+
+#if _GLIBCXX_USE_CXX11_ABI
+  static_assert(sizeof(__sso_string) == sizeof(std::string),
+                "sizeof(std::string) has changed");
+  static_assert(alignof(__sso_string) == alignof(std::string),
+                "alignof(std::string) has changed");
+
+  // This constructor is defined in src/c++11/cow-stdexcept.cc for COW strings
+  __sso_string::__sso_string(const std::string& s) : _M_str(s) { }
+#endif
+
+  __sso_string::__sso_string(const char* s, size_t n) : _M_str(s, n) { }
+
+  __sso_string::__sso_string(const __sso_string& s) noexcept
+  : _M_str(s._M_str) { }
+
+  __sso_string&
+  __sso_string::operator=(const __sso_string& s) noexcept
+  {
+    _M_str = s._M_str;
+    return *this;
+  }
+
+  __sso_string::~__sso_string() { _M_str.~basic_string(); }
+
+  __sso_string::__sso_string(__sso_string&& s) noexcept
+  : _M_str(std::move(s._M_str)) { }
+
+  __sso_string&
+  __sso_string::operator=(__sso_string&& s) noexcept
+  {
+    _M_str = std::move(s._M_str);
+    return *this;
+  }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/src/c++11/system_error.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/system_error.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/system_error.cc	(.../branches/gcc-6-branch)
@@ -75,6 +75,12 @@
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  void
+  __throw_system_error(int __i __attribute__((unused)))
+  {
+    _GLIBCXX_THROW_OR_ABORT(system_error(error_code(__i, generic_category())));
+  }
+
   error_category::~error_category() noexcept = default;
 
   const error_category& 
@@ -112,73 +118,5 @@
   }
 #endif
 
-#if _GLIBCXX_USE_DUAL_ABI
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wabi-tag"
-  // Redefine __sso_string so that we can define and export its members
-  // in terms of the SSO std::string.
-  struct __sso_string
-  {
-    struct __str
-    {
-      const char* _M_p;
-      size_t _M_string_length;
-      char _M_local_buf[16];
-    };
-
-    union {
-      __str _M_s;
-      char _M_bytes[sizeof(_M_s)];
-      std::string _M_str;
-    };
-
-    __sso_string();
-    __sso_string(const std::string& s);
-    __sso_string(const char*, size_t n);
-    __sso_string(const __sso_string&) noexcept;
-    __sso_string& operator=(const __sso_string&) noexcept;
-    ~__sso_string();
-    __sso_string(__sso_string&&) noexcept;
-    __sso_string& operator=(__sso_string&&) noexcept;
-  };
-#pragma GCC diagnostic pop
-
-  __sso_string::__sso_string() : _M_str() { }
-
-#if _GLIBCXX_USE_CXX11_ABI
-  static_assert(sizeof(__sso_string) == sizeof(std::string),
-                "sizeof(std::string) has changed");
-  static_assert(alignof(__sso_string) == alignof(std::string),
-                "alignof(std::string) has changed");
-
-  // This constructor is defined in src/c++11/cow-stdexcept.cc for COW strings
-  __sso_string::__sso_string(const std::string& s) : _M_str(s) { }
-#endif
-
-  __sso_string::__sso_string(const char* s, size_t n) : _M_str(s, n) { }
-
-  __sso_string::__sso_string(const __sso_string& s) noexcept
-  : _M_str(s._M_str) { }
-
-  __sso_string&
-  __sso_string::operator=(const __sso_string& s) noexcept
-  {
-    _M_str = s._M_str;
-    return *this;
-  }
-
-  __sso_string::~__sso_string() { _M_str.~basic_string(); }
-
-  __sso_string::__sso_string(__sso_string&& s) noexcept
-  : _M_str(std::move(s._M_str)) { }
-
-  __sso_string&
-  __sso_string::operator=(__sso_string&& s) noexcept
-  {
-    _M_str = std::move(s._M_str);
-    return *this;
-  }
-#endif // _GLIBCXX_USE_DUAL_ABI
-
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/src/c++11/functional.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/functional.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/functional.cc	(.../branches/gcc-6-branch)
@@ -23,11 +23,16 @@
 // <http://www.gnu.org/licenses/>.
 
 #include <functional>
+#include <bits/functexcept.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
+  void
+  __throw_bad_function_call()
+  { _GLIBCXX_THROW_OR_ABORT(bad_function_call()); }
+
   bad_function_call::~bad_function_call() noexcept = default;
 
   const char*
Index: libstdc++-v3/src/c++11/cow-wstring-io-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/cow-wstring-io-inst.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/cow-wstring-io-inst.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,63 @@
+// Reference-counted COW wide string instantiations for I/O -*- C++ -*-
+
+// Copyright (C) 2014-2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882: 21  Strings library
+//
+
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include <bits/c++config.h>
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+#include <ostream>
+#include <istream>
+
+#if ! _GLIBCXX_USE_DUAL_ABI
+# error This file should not be compiled for this configuration.
+#endif
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // The equivalent SSO wstring instantiations are in c++98/misc-inst.cc,
+  // repeat them for COW wstring
+
+  // string related to iostreams
+  template
+    basic_istream<wchar_t>&
+    operator>>(basic_istream<wchar_t>&, wstring&);
+  template
+    basic_ostream<wchar_t>&
+    operator<<(basic_ostream<wchar_t>&, const wstring&);
+  template
+    basic_istream<wchar_t>&
+    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
+  template
+    basic_istream<wchar_t>&
+    getline(basic_istream<wchar_t>&, wstring&);
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
+#endif
Index: libstdc++-v3/src/c++11/wstring-io-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/wstring-io-inst.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/wstring-io-inst.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,55 @@
+// SSO string instantiations for I/O -*- C++ -*-
+
+// Copyright (C) 1997-2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+//
+// ISO C++ 14882:
+//
+
+#define _GLIBCXX_USE_CXX11_ABI 1
+#include <string>
+#include <istream>
+#include <ostream>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // string related to iostreams
+#ifdef _GLIBCXX_USE_WCHAR_T
+  template
+    basic_istream<wchar_t>&
+    operator>>(basic_istream<wchar_t>&, wstring&);
+  template
+    basic_ostream<wchar_t>&
+    operator<<(basic_ostream<wchar_t>&, const wstring&);
+  template
+    basic_istream<wchar_t>&
+    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
+  template
+    basic_istream<wchar_t>&
+    getline(basic_istream<wchar_t>&, wstring&);
+#endif
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
Index: libstdc++-v3/src/c++11/snprintf_lite.cc
===================================================================
--- a/src/libstdc++-v3/src/c++11/snprintf_lite.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/snprintf_lite.cc	(.../branches/gcc-6-branch)
@@ -71,19 +71,17 @@
   // Returns number of characters appended, or -1 if BUFSIZE is too small.
   int __concat_size_t(char *__buf, size_t __bufsize, size_t __val)
   {
-    // __int_to_char is explicitly instantiated and available only for
-    // some, but not all, types. See locale-inst.cc.
-#ifdef _GLIBCXX_USE_LONG_LONG
-    unsigned long long __val2 = __val;
-#else
-    unsigned long __val2 = __val;
-#endif
     // Long enough for decimal representation.
-    int __ilen = 3 * sizeof(__val2);
+    int __ilen = 3 * sizeof(__val);
     char *__cs = static_cast<char*>(__builtin_alloca(__ilen));
-    size_t __len = std::__int_to_char(__cs + __ilen, __val2,
-				      std::__num_base::_S_atoms_out,
-				      std::ios_base::dec, true);
+    char* __out = __cs + __ilen;
+    do
+      {
+	*--__out = "0123456789"[__val % 10];
+	__val /= 10;
+      }
+    while (__val != 0);
+    size_t __len = __out - __cs;
     if (__bufsize < __len)
       return -1;
 
Index: libstdc++-v3/src/c++11/Makefile.am
===================================================================
--- a/src/libstdc++-v3/src/c++11/Makefile.am	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/src/c++11/Makefile.am	(.../branches/gcc-6-branch)
@@ -82,9 +82,12 @@
 	cow-fstream-inst.cc \
 	cow-sstream-inst.cc \
 	cow-string-inst.cc \
+	cow-string-io-inst.cc \
 	cow-wstring-inst.cc \
+	cow-wstring-io-inst.cc \
 	cxx11-locale-inst.cc \
-	cxx11-wlocale-inst.cc
+	cxx11-wlocale-inst.cc \
+	sso_string.cc
 else
 extra_string_inst_sources =
 endif
@@ -103,8 +106,10 @@
 	sstream-inst.cc \
 	streambuf-inst.cc \
 	string-inst.cc \
+	string-io-inst.cc \
 	wlocale-inst.cc \
-	wstring-inst.cc
+	wstring-inst.cc \
+	wstring-io-inst.cc
 else
 # XTEMPLATE_FLAGS =
 inst_sources =
Index: libstdc++-v3/doc/xml/manual/extensions.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/extensions.xml	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/extensions.xml	(.../branches/gcc-6-branch)
@@ -502,7 +502,7 @@
     <quote>demangling.</quote>
   </para>
   <para>
-    If you have read the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01115.html">source
+    If you have read the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespaces.html">source
     documentation for <code>namespace abi</code></link> then you are
     aware of the cross-vendor C++ ABI in use by GCC.  One of the
     exposed functions is used for demangling,
Index: libstdc++-v3/doc/html/manual/ext_demangling.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/ext_demangling.html	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/ext_demangling.html	(.../branches/gcc-6-branch)
@@ -7,7 +7,7 @@
     original C++ source identifiers is called
     <span class="quote">“<span class="quote">demangling.</span>”</span>
   </p><p>
-    If you have read the <a class="link" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01115.html" target="_top">source
+    If you have read the <a class="link" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespaces.html" target="_top">source
     documentation for <code class="code">namespace abi</code></a> then you are
     aware of the cross-vendor C++ ABI in use by GCC.  One of the
     exposed functions is used for demangling,
Index: libstdc++-v3/doc/doxygen/mainpage.html
===================================================================
--- a/src/libstdc++-v3/doc/doxygen/mainpage.html	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/doc/doxygen/mainpage.html	(.../branches/gcc-6-branch)
@@ -28,7 +28,7 @@
 
 <p>There are two types of documentation for libstdc++.  One is the
    distribution documentation, which can be read online
-   <a href="http://gcc.gnu.org/onlinedocs/libstdc++/index.html">here</a>
+   <a href="https://gcc.gnu.org/onlinedocs/libstdc++/index.html">here</a>
    or offline from the file doc/html/index.html in the library source
    directory.
 </p>
@@ -78,11 +78,11 @@
    pages.  See the section "Documentation Style"
    in <code>doc/xml/manual/appendix_contributing.xml</code> in the
    source tree for how to create (and write) the doxygen markup.
-  This style guide can also be viewed on the <a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01apas04.html">web</a>.
+  This style guide can also be viewed on the <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_hacking.html">web</a>.
 
 <h2>License, Copyright, and Other Lawyerly Verbosity</h2>
 <p>The libstdc++ documentation is released under
-   <a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01s02.html">
+   <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/appendix_gpl.html">
    these terms</a>.
 </p>
 <p>Part of the generated documentation involved comments and notes from
Index: libstdc++-v3/include/std/future
===================================================================
--- a/src/libstdc++-v3/include/std/future	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/std/future	(.../branches/gcc-6-branch)
@@ -462,7 +462,6 @@
 	  // Used by std::promise to copy construct the result.
           typename promise<_Res>::_Ptr_type operator()() const
           {
-            _State_baseV2::_S_check(_M_promise->_M_future);
             _M_promise->_M_storage->_M_set(*_M_arg);
             return std::move(_M_promise->_M_storage);
           }
@@ -477,7 +476,6 @@
 	  // Used by std::promise to move construct the result.
           typename promise<_Res>::_Ptr_type operator()() const
           {
-            _State_baseV2::_S_check(_M_promise->_M_future);
             _M_promise->_M_storage->_M_set(std::move(*_M_arg));
             return std::move(_M_promise->_M_storage);
           }
@@ -485,6 +483,18 @@
           _Res*             _M_arg;
         };
 
+      // set void
+      template<typename _Res>
+	struct _Setter<_Res, void>
+	{
+	  static_assert(is_void<_Res>::value, "Only used for promise<void>");
+
+	  typename promise<_Res>::_Ptr_type operator()() const
+	  { return std::move(_M_promise->_M_storage); }
+
+	  promise<_Res>*    _M_promise;
+	};
+
       struct __exception_ptr_tag { };
 
       // set exceptions
@@ -494,7 +504,6 @@
 	  // Used by std::promise to store an exception as the result.
           typename promise<_Res>::_Ptr_type operator()() const
           {
-            _State_baseV2::_S_check(_M_promise->_M_future);
             _M_promise->_M_storage->_M_error = *_M_ex;
             return std::move(_M_promise->_M_storage);
           }
@@ -507,6 +516,7 @@
         static _Setter<_Res, _Arg&&>
         __setter(promise<_Res>* __prom, _Arg&& __arg)
         {
+	  _S_check(__prom->_M_future);
           return _Setter<_Res, _Arg&&>{ __prom, std::__addressof(__arg) };
         }
 
@@ -514,9 +524,18 @@
         static _Setter<_Res, __exception_ptr_tag>
         __setter(exception_ptr& __ex, promise<_Res>* __prom)
         {
+	  _S_check(__prom->_M_future);
           return _Setter<_Res, __exception_ptr_tag>{ __prom, &__ex };
         }
 
+      template<typename _Res>
+	static _Setter<_Res, void>
+	__setter(promise<_Res>* __prom)
+	{
+	  _S_check(__prom->_M_future);
+	  return _Setter<_Res, void>{ __prom };
+	}
+
       template<typename _Tp>
         static void
         _S_check(const shared_ptr<_Tp>& __p)
@@ -1014,6 +1033,7 @@
       typedef __future_base::_Result<_Res>	_Res_type;
       typedef __future_base::_Ptr<_Res_type>	_Ptr_type;
       template<typename, typename> friend class _State::_Setter;
+      friend _State;
 
       shared_ptr<_State>                        _M_future;
       _Ptr_type                                 _M_storage;
@@ -1124,6 +1144,7 @@
       typedef __future_base::_Result<_Res&>	_Res_type;
       typedef __future_base::_Ptr<_Res_type> 	_Ptr_type;
       template<typename, typename> friend class _State::_Setter;
+      friend _State;
 
       shared_ptr<_State>                        _M_future;
       _Ptr_type                                 _M_storage;
@@ -1213,6 +1234,7 @@
       typedef __future_base::_Result<void>	_Res_type;
       typedef __future_base::_Ptr<_Res_type> 	_Ptr_type;
       template<typename, typename> friend class _State::_Setter;
+      friend _State;
 
       shared_ptr<_State>                        _M_future;
       _Ptr_type                                 _M_storage;
@@ -1273,7 +1295,9 @@
       { return future<void>(_M_future); }
 
       // Setting the result
-      void set_value();
+      void
+      set_value()
+      { _M_future->_M_set_result(_State::__setter(this)); }
 
       void
       set_exception(exception_ptr __p)
@@ -1280,7 +1304,8 @@
       { _M_future->_M_set_result(_State::__setter(__p, this)); }
 
       void
-      set_value_at_thread_exit();
+      set_value_at_thread_exit()
+      { _M_future->_M_set_delayed_result(_State::__setter(this), _M_future); }
 
       void
       set_exception_at_thread_exit(exception_ptr __p)
@@ -1290,30 +1315,6 @@
       }
     };
 
-  // set void
-  template<>
-    struct __future_base::_State_base::_Setter<void, void>
-    {
-      promise<void>::_Ptr_type operator()() const
-      {
-        _State_base::_S_check(_M_promise->_M_future);
-        return std::move(_M_promise->_M_storage);
-      }
-
-      promise<void>*    _M_promise;
-    };
-
-  inline void
-  promise<void>::set_value()
-  { _M_future->_M_set_result(_State::_Setter<void, void>{ this }); }
-
-  inline void
-  promise<void>::set_value_at_thread_exit()
-  {
-    _M_future->_M_set_delayed_result(_State::_Setter<void, void>{this},
-				     _M_future);
-  }
-
   template<typename _Ptr_type, typename _Fn, typename _Res>
     struct __future_base::_Task_setter
     {
Index: libstdc++-v3/include/std/chrono
===================================================================
--- a/src/libstdc++-v3/include/std/chrono	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/std/chrono	(.../branches/gcc-6-branch)
@@ -558,7 +558,8 @@
 	{ }
 
 	// conversions
-	template<typename _Dur2>
+	template<typename _Dur2,
+		 typename = _Require<is_convertible<_Dur2, _Dur>>>
 	  constexpr time_point(const time_point<clock, _Dur2>& __t)
 	  : __d(__t.time_since_epoch())
 	  { }
Index: libstdc++-v3/include/std/functional
===================================================================
--- a/src/libstdc++-v3/include/std/functional	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/std/functional	(.../branches/gcc-6-branch)
@@ -1885,7 +1885,7 @@
        *  The newly-created %function contains the target of @a __x
        *  (if it has one).
        */
-      function(function&& __x) : _Function_base()
+      function(function&& __x) noexcept : _Function_base()
       {
 	__x.swap(*this);
       }
@@ -1944,7 +1944,7 @@
        *  object, then this operation will not throw an %exception.
        */
       function&
-      operator=(function&& __x)
+      operator=(function&& __x) noexcept
       {
 	function(std::move(__x)).swap(*this);
 	return *this;
Index: libstdc++-v3/include/std/istream
===================================================================
--- a/src/libstdc++-v3/include/std/istream	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/std/istream	(.../branches/gcc-6-branch)
@@ -150,9 +150,9 @@
        *  whatever data is appropriate for the type of the argument.
        *
        *  If an exception is thrown during extraction, ios_base::badbit
-       *  will be turned on in the stream's error state without causing an
-       *  ios_base::failure to be thrown.  The original exception will then
-       *  be rethrown.
+       *  will be turned on in the stream's error state (without causing an
+       *  ios_base::failure to be thrown) and the original exception will
+       *  be rethrown if badbit is set in the exceptions mask.
       */
 
       //@{
@@ -286,9 +286,9 @@
        *  by gcount().
        *
        *  If an exception is thrown during extraction, ios_base::badbit
-       *  will be turned on in the stream's error state without causing an
-       *  ios_base::failure to be thrown.  The original exception will then
-       *  be rethrown.
+       *  will be turned on in the stream's error state (without causing an
+       *  ios_base::failure to be thrown) and the original exception will
+       *  be rethrown if badbit is set in the exceptions mask.
       */
 
       /**
Index: libstdc++-v3/include/std/sstream
===================================================================
--- a/src/libstdc++-v3/include/std/sstream	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/std/sstream	(.../branches/gcc-6-branch)
@@ -302,12 +302,14 @@
 	__xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 	: _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 	{
-	  const _CharT* __str = __from._M_string.data();
+	  const _CharT* const __str = __from._M_string.data();
+	  const _CharT* __end = nullptr;
 	  if (__from.eback())
 	    {
-	    _M_goff[0] = __from.eback() - __str;
-	    _M_goff[1] = __from.gptr() - __str;
-	    _M_goff[2] = __from.egptr() - __str;
+	      _M_goff[0] = __from.eback() - __str;
+	      _M_goff[1] = __from.gptr() - __str;
+	      _M_goff[2] = __from.egptr() - __str;
+	      __end = __from.egptr();
 	    }
 	  if (__from.pbase())
 	    {
@@ -314,7 +316,18 @@
 	      _M_poff[0] = __from.pbase() - __str;
 	      _M_poff[1] = __from.pptr() - __from.pbase();
 	      _M_poff[2] = __from.epptr() - __str;
+	      if (__from.pptr() > __end)
+		__end = __from.pptr();
 	    }
+
+	  // Set _M_string length to the greater of the get and put areas.
+	  if (__end)
+	    {
+	      // The const_cast avoids changing this constructor's signature,
+	      // because it is exported from the dynamic library.
+	      auto& __mut_from = const_cast<basic_stringbuf&>(__from);
+	      __mut_from._M_string._M_length(__end - __str);
+	    }
 	}
 
 	~__xfer_bufptrs()
Index: libstdc++-v3/include/ext/new_allocator.h
===================================================================
--- a/src/libstdc++-v3/include/ext/new_allocator.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/ext/new_allocator.h	(.../branches/gcc-6-branch)
@@ -96,8 +96,8 @@
       // NB: __n is permitted to be 0.  The C++ standard says nothing
       // about what the return value is when __n == 0.
       pointer
-      allocate(size_type __n, const void* = 0)
-      { 
+      allocate(size_type __n, const void* = static_cast<const void*>(0))
+      {
 	if (__n > this->max_size())
 	  std::__throw_bad_alloc();
 
Index: libstdc++-v3/include/bits/hashtable.h
===================================================================
--- a/src/libstdc++-v3/include/bits/hashtable.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/bits/hashtable.h	(.../branches/gcc-6-branch)
@@ -836,17 +836,8 @@
 	    _M_bucket_count = __bkt_count;
 	  }
 
-	__try
-	  {
-	    for (; __f != __l; ++__f)
-	      this->insert(*__f);
-	  }
-	__catch(...)
-	  {
-	    clear();
-	    _M_deallocate_buckets();
-	    __throw_exception_again;
-	  }
+	for (; __f != __l; ++__f)
+	  this->insert(*__f);
       }
 
   template<typename _Key, typename _Value,
Index: libstdc++-v3/include/bits/basic_ios.h
===================================================================
--- a/src/libstdc++-v3/include/bits/basic_ios.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/bits/basic_ios.h	(.../branches/gcc-6-branch)
@@ -157,8 +157,8 @@
       setstate(iostate __state)
       { this->clear(this->rdstate() | __state); }
 
-      // Flip the internal state on for the proper state bits, then re
-      // throws the propagated exception if bit also set in
+      // Flip the internal state on for the proper state bits, then
+      // rethrows the propagated exception if bit also set in
       // exceptions().
       void
       _M_setstate(iostate __state)
Index: libstdc++-v3/include/bits/stl_stack.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_stack.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/bits/stl_stack.h	(.../branches/gcc-6-branch)
@@ -86,7 +86,7 @@
    *
    *  The second template parameter defines the type of the underlying
    *  sequence/container.  It defaults to std::deque, but it can be
-   *  any type that supports @c back, @c push_back, and @c pop_front,
+   *  any type that supports @c back, @c push_back, and @c pop_back,
    *  such as std::list, std::vector, or an appropriate user-defined
    *  type.
    *
Index: libstdc++-v3/include/bits/basic_string.h
===================================================================
--- a/src/libstdc++-v3/include/bits/basic_string.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/bits/basic_string.h	(.../branches/gcc-6-branch)
@@ -2543,7 +2543,10 @@
       int
       compare(size_type __pos, size_type __n1, const _CharT* __s,
 	      size_type __n2) const;
-  };
+
+      // Allow basic_stringbuf::__xfer_bufptrs to call _M_length:
+      template<typename, typename, typename> friend class basic_stringbuf;
+    };
 _GLIBCXX_END_NAMESPACE_CXX11
 #else  // !_GLIBCXX_USE_CXX11_ABI
   // Reference-counted COW string implentation
Index: libstdc++-v3/include/bits/istream.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/istream.tcc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/bits/istream.tcc	(.../branches/gcc-6-branch)
@@ -48,28 +48,36 @@
     {
       ios_base::iostate __err = ios_base::goodbit;
       if (__in.good())
-	{
-	  if (__in.tie())
-	    __in.tie()->flush();
-	  if (!__noskip && bool(__in.flags() & ios_base::skipws))
-	    {
-	      const __int_type __eof = traits_type::eof();
-	      __streambuf_type* __sb = __in.rdbuf();
-	      __int_type __c = __sb->sgetc();
+	__try
+	  {
+	    if (__in.tie())
+	      __in.tie()->flush();
+	    if (!__noskip && bool(__in.flags() & ios_base::skipws))
+	      {
+		const __int_type __eof = traits_type::eof();
+		__streambuf_type* __sb = __in.rdbuf();
+		__int_type __c = __sb->sgetc();
 
-	      const __ctype_type& __ct = __check_facet(__in._M_ctype);
-	      while (!traits_type::eq_int_type(__c, __eof)
-		     && __ct.is(ctype_base::space, 
-				traits_type::to_char_type(__c)))
-		__c = __sb->snextc();
+		const __ctype_type& __ct = __check_facet(__in._M_ctype);
+		while (!traits_type::eq_int_type(__c, __eof)
+		       && __ct.is(ctype_base::space,
+				  traits_type::to_char_type(__c)))
+		  __c = __sb->snextc();
 
-	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-	      // 195. Should basic_istream::sentry's constructor ever
-	      // set eofbit?
-	      if (traits_type::eq_int_type(__c, __eof))
-		__err |= ios_base::eofbit;
-	    }
-	}
+		// _GLIBCXX_RESOLVE_LIB_DEFECTS
+		// 195. Should basic_istream::sentry's constructor ever
+		// set eofbit?
+		if (traits_type::eq_int_type(__c, __eof))
+		  __err |= ios_base::eofbit;
+	      }
+	  }
+	__catch(__cxxabiv1::__forced_unwind&)
+	  {
+	    __in._M_setstate(ios_base::badbit);
+	    __throw_exception_again;
+	  }
+	__catch(...)
+	  { __in._M_setstate(ios_base::badbit); }
 
       if (__in.good() && __err == ios_base::goodbit)
 	_M_ok = true;
Index: libstdc++-v3/include/bits/sstream.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/sstream.tcc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/bits/sstream.tcc	(.../branches/gcc-6-branch)
@@ -88,6 +88,25 @@
 	return traits_type::not_eof(__c);
 
       const __size_type __capacity = _M_string.capacity();
+
+#if _GLIBCXX_USE_CXX11_ABI
+      if ((this->epptr() - this->pbase()) < __capacity)
+	{
+	  // There is additional capacity in _M_string that can be used.
+	  char_type* __base = const_cast<char_type*>(_M_string.data());
+	  _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
+	  if (_M_mode & ios_base::in)
+	    {
+	      const __size_type __nget = this->gptr() - this->eback();
+	      const __size_type __eget = this->egptr() - this->eback();
+	      this->setg(__base, __base + __nget, __base + __eget + 1);
+	    }
+	  *this->pptr() = traits_type::to_char_type(__c);
+	  this->pbump(1);
+	  return __c;
+	}
+#endif
+
       const __size_type __max_size = _M_string.max_size();
       const bool __testput = this->pptr() < this->epptr();
       if (__builtin_expect(!__testput && __capacity == __max_size, false))
Index: libstdc++-v3/include/bits/shared_ptr_base.h
===================================================================
--- a/src/libstdc++-v3/include/bits/shared_ptr_base.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/include/bits/shared_ptr_base.h	(.../branches/gcc-6-branch)
@@ -1082,12 +1082,12 @@
 
       template<typename _Tp1>
 	bool
-	owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const
+	owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 	{ return _M_refcount._M_less(__rhs._M_refcount); }
 
       template<typename _Tp1>
 	bool
-	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const
+	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 	{ return _M_refcount._M_less(__rhs._M_refcount); }
 
 #if __cpp_rtti
@@ -1444,12 +1444,12 @@
 
       template<typename _Tp1>
 	bool
-	owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const
+	owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
 	{ return _M_refcount._M_less(__rhs._M_refcount); }
 
       template<typename _Tp1>
 	bool
-	owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const
+	owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept
 	{ return _M_refcount._M_less(__rhs._M_refcount); }
 
       void
@@ -1494,15 +1494,15 @@
     struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
     {
       bool
-      operator()(const _Tp& __lhs, const _Tp& __rhs) const
+      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept
       { return __lhs.owner_before(__rhs); }
 
       bool
-      operator()(const _Tp& __lhs, const _Tp1& __rhs) const
+      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept
       { return __lhs.owner_before(__rhs); }
 
       bool
-      operator()(const _Tp1& __lhs, const _Tp& __rhs) const
+      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept
       { return __lhs.owner_before(__rhs); }
     };
 
Index: libstdc++-v3/libsupc++/cxxabi.h
===================================================================
--- a/src/libstdc++-v3/libsupc++/cxxabi.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/libsupc++/cxxabi.h	(.../branches/gcc-6-branch)
@@ -185,7 +185,7 @@
    *  with GNU extensions. For example, this function is used in
    *  __gnu_cxx::__verbose_terminate_handler.
    *
-   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt12ch39.html
+   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_demangling.html
    *  for other examples of use.
    *
    *  @note The same demangling functionality is available via
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,170 @@
+2017-09-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2017-02-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60936
+	* src/c++11/Makefile.am: Add new files.
+	* src/c++11/Makefile.in: Regenerate.
+	* src/c++11/cow-string-inst.cc [!_GLIBCXX_USE_CXX11_ABI]
+	(operator<<, operator>>, getline): Move explicit instantiations to ...
+	* src/c++11/cow-string-io-inst.cc: ... new file.
+	* src/c++11/cow-wstring-inst.cc [!_GLIBCXX_USE_CXX11_ABI]
+	(operator<<, operator>>, getline): Move explicit instantiations to ...
+	* src/c++11/cow-wstring-io-inst.cc: ... new file.
+	* src/c++11/functexcept.cc (__throw_ios_failure, __throw_system_error)
+	(__throw_future_error, __throw_bad_function_call):
+	(__throw_regex_error): Move functions for C++11 exceptions to the
+	files that define the exception types.
+	* src/c++11/functional.cc (__throw_bad_function_call): Move here.
+	* src/c++11/future.cc (__throw_future_error): Likewise.
+	* src/c++11/ios.cc (__throw_ios_failure): Likewise.
+	* src/c++11/regex.cc (__throw_regex_error): Likewise.
+	* src/c++11/snprintf_lite.cc (__concat_size_t): Print decimal
+	representation directly instead of calling __int_to_char.
+	* src/c++11/sso_string.cc (__sso_string): New file for definition
+	of __sso_string type.
+	* src/c++11/string-io-inst.cc [_GLIBCXX_USE_CXX11_ABI]: New file for
+	explicit instantiations of narrow string I/O functions.
+	* src/c++11/system_error.cc (__throw_system_error): Move here.
+	(__sso_string): Move to new file.
+	* src/c++11/wstring-io-inst.cc [_GLIBCXX_USE_CXX11_ABI]: New file for
+	explicit instantiations of wide string I/O functions.
+	* src/c++98/misc-inst.cc [_GLIBCXX_USE_CXX11_ABI] (operator<<)
+	(operator>>, getline): Remove explicit instantiations from here.
+
+2017-09-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81468
+	* include/std/chrono (time_point(const time_point<_Dur2>&)): Add
+	missing constraint from LWG DR 1177.
+	* testsuite/20_util/duration/cons/dr1177.cc: New.
+	* testsuite/20_util/time_point/cons/81468.cc: New.
+	* testsuite/20_util/duration/literals/range.cc: Update dg-error line.
+
+	* doc/doxygen/mainpage.html: Fix broken URLs.
+
+	PR libstdc++/81835
+	* doc/xml/manual/extensions.xml: Replace unstable URL.
+	* doc/html/manual/ext_demangling.html: Regenerate.
+	* libsupc++/cxxabi.h (__cxa_demangle): Fix broken URL.
+
+2017-09-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/owner_less/noexcept.cc: Remove owner_less<void>
+	tests.
+
+2017-09-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2017-08-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/79820
+	PR libstdc++/81751
+	* config/io/basic_file_stdio.cc (sys_open(FILE*, ios_base::openmode)):
+	Call fflush on the stream instead of calling sync() while _M_cfile is
+	null. Restore original value of errno.
+	* testsuite/ext/stdio_filebuf/char/79820.cc: New.
+	* testsuite/ext/stdio_filebuf/char/81751.cc: New.
+
+	Backport from mainline
+	2017-07-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/53984
+	* include/bits/basic_ios.h (basic_ios::_M_setstate): Adjust comment.
+	* include/bits/istream.tcc (basic_istream::sentry): Handle exceptions
+	during construction.
+	* include/std/istream: Adjust comments for formatted input functions
+	and unformatted input functions.
+	* testsuite/27_io/basic_fstream/53984.cc: New.
+	* testsuite/27_io/basic_istream/sentry/char/53984.cc: New.
+
+	Backport from mainline
+	2017-06-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81017
+	* include/std/functional (function::function(function&&))
+	(function::operator=(function&&)): Add noexcept.
+	* testsuite/20_util/function/assign/move.cc: Check for noexcept.
+	* testsuite/20_util/function/cons/move.cc: Likewise.
+
+	Backport from mainline
+	2017-06-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/shared_ptr_base.h (__shared_ptr::owner_before)
+	(__weak_ptr::owner_before, _Sp_owner_less::operator()): Add noexcept
+	specifiers as per LWG 2873 and LWG 2942.
+	* testsuite/20_util/owner_less/noexcept.cc: New.
+	* testsuite/20_util/shared_ptr/observers/owner_before.cc: Test
+	noexcept guarantees.
+	* testsuite/20_util/weak_ptr/observers/owner_before.cc: Likewise.
+
+	Backport from mainline
+	2017-08-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/82039
+	* include/ext/new_allocator.h (__gnu_cxx::new_allocator::allocate):
+	Adjust null pointer constant to avoid warning.
+
+	Backport from mainline
+	2017-08-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81891
+	* include/bits/hashtable.h (_Hashtable(_InputIterator, _InputIterator,
+	size_type, const _H1&, const _H2&, const _Hash&, const _Equal&,
+	const _ExtractKey&, const allocator_type&)): Let destructor do clean
+	up if an exception is thrown.
+	* testsuite/23_containers/unordered_map/cons/81891.cc: New.
+
+	Backport from mainline
+	2017-07-31  Marek Polacek  <polacek@redhat.com>
+
+	PR libstdc++/81599
+	* include/bits/stl_stack.h: Fix typo.
+
+	Backport from mainline
+	2017-07-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81338
+	* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI] (basic_string):
+	Declare basic_stringbuf to be a friend.
+	* include/bits/sstream.tcc (basic_stringbuf::overflow)
+	[_GLIBCXX_USE_CXX11_ABI]: Use unused capacity before reallocating.
+	* include/std/sstream (basic_stringbuf::__xfer_bufptrs): Update string
+	length to buffer length.
+	* testsuite/27_io/basic_stringstream/assign/81338.cc: New.
+
+2017-07-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/30_threads/promise/members/at_thread_exit2.cc: Require
+	atomic builtins.
+
+2017-07-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2017-04-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/80316
+	* include/std/future (_State_baseV2::_Setter::operator()): Remove
+	_S_check calls that are done after the pointer to the shared state is
+	already dereferenced.
+	(_State_baseV2::_Setter<_Res, void>): Define specialization for void
+	as partial specialization so it can be defined within the definition
+	of _State_baseV2.
+	(_State_baseV2::__setter): Call _S_check.
+	(_State_baseV2::__setter(promise<void>*)): Add overload for use by
+	promise<void>::set_value and promise<void>::set_value_at_thread_exit.
+	(promise<T>, promise<T&>, promise<void>): Make _State a friend.
+	(_State_baseV2::_Setter<void, void>): Remove explicit specialization.
+	(promise<void>::set_value, promise<void>::set_value_at_thread_exit):
+	Use new __setter overload.
+	* testsuite/30_threads/promise/members/at_thread_exit2.cc: New test.
+	* testsuite/30_threads/promise/members/set_exception.cc: Test
+	promise<T&> and promise<void> specializations.
+	* testsuite/30_threads/promise/members/set_exception2.cc: Likewise.
+	Test for no_state error condition.
+	* testsuite/30_threads/promise/members/set_value2.cc: Likewise.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: libstdc++-v3/testsuite/30_threads/promise/members/set_exception2.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/promise/members/set_exception2.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/promise/members/set_exception2.cc	(.../branches/gcc-6-branch)
@@ -23,10 +23,13 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+// Test that promise::set_exception throws when required.
 
 #include <future>
 #include <testsuite_hooks.h>
 
+// Check for promise_already_satisfied error conditions.
+
 void test01()
 {
   bool test = false;
@@ -85,9 +88,187 @@
   VERIFY( test );
 }
 
+void test03()
+{
+  bool test = false;
+
+  std::promise<int&> p1;
+  std::future<int&> f1 = p1.get_future();
+
+  p1.set_exception(std::make_exception_ptr(0));
+
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(1));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  try
+  {
+    f1.get();
+    test = false;
+  }
+  catch(int i)
+  {
+    VERIFY( i == 0 );
+  }
+
+  VERIFY( test );
+}
+
+void test04()
+{
+  bool test = false;
+
+  std::promise<int&> p1;
+  std::future<int&> f1 = p1.get_future();
+
+  int i = 2;
+  p1.set_value(i);
+
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(0));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  VERIFY( test );
+}
+
+void test05()
+{
+  bool test = false;
+
+  std::promise<void> p1;
+  std::future<void> f1 = p1.get_future();
+
+  p1.set_exception(std::make_exception_ptr(0));
+
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(1));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  try
+  {
+    f1.get();
+    test = false;
+  }
+  catch(int i)
+  {
+    VERIFY( i == 0 );
+  }
+
+  VERIFY( test );
+}
+
+void test06()
+{
+  bool test = false;
+
+  std::promise<void> p1;
+  std::future<void> f1 = p1.get_future();
+
+  p1.set_value();
+
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(0));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  VERIFY( test );
+}
+
+// Check for no_state error condition (PR libstdc++/80316)
+
+void test07()
+{
+  using namespace std;
+
+  promise<int> p1;
+  promise<int> p2(std::move(p1));
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(1));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() == make_error_code(future_errc::no_state));
+  }
+}
+
+void test08()
+{
+  using namespace std;
+
+  promise<int&> p1;
+  promise<int&> p2(std::move(p1));
+  try
+  {
+    int i = 0;
+    p1.set_exception(std::make_exception_ptr(1));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() == make_error_code(future_errc::no_state));
+  }
+}
+
+void test09()
+{
+  using namespace std;
+
+  promise<void> p1;
+  promise<void> p2(std::move(p1));
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(1));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() == make_error_code(future_errc::no_state));
+  }
+}
+
 int main()
 {
   test01();
   test02();
+  test03();
+  test04();
+  test05();
+  test06();
+  test07();
+  test08();
+  test09();
   return 0;
 }
Index: libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit2.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,168 @@
+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-rtems* *-*-darwin* powerpc-ibm-aix* } }
+// { dg-options "-pthread" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* powerpc-ibm-aix* } }
+// { dg-require-effective-target c++11 }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2014-2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// Test set_value_at_thread_exit error conditions
+
+#include <future>
+#include <testsuite_hooks.h>
+
+void test01()
+{
+  std::promise<int> p1;
+  p1.set_value(1);
+  try
+  {
+    p1.set_value_at_thread_exit(2);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );
+  }
+  try
+  {
+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );
+  }
+
+  std::promise<int> p2(std::move(p1));
+  try
+  {
+    p1.set_value_at_thread_exit(2);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::no_state );
+  }
+  try
+  {
+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::no_state );
+  }
+}
+
+void test02()
+{
+  std::promise<int&> p1;
+  int i = 1;
+  p1.set_value(i);
+  try
+  {
+    p1.set_value_at_thread_exit(i);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );
+  }
+  try
+  {
+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );
+  }
+
+  std::promise<int&> p2(std::move(p1));
+  try
+  {
+    int i = 0;
+    p1.set_value_at_thread_exit(i);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::no_state );
+  }
+  try
+  {
+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::no_state );
+  }
+}
+
+void test03()
+{
+  std::promise<void> p1;
+  int i = 0;
+  p1.set_value();
+  try {
+    p1.set_value_at_thread_exit();
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );
+  }
+  try
+  {
+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );
+  }
+
+  std::promise<void> p2(std::move(p1));
+  try {
+    p1.set_value_at_thread_exit();
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::no_state );
+  }
+  try
+  {
+    p1.set_exception_at_thread_exit(std::make_exception_ptr(3));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY( e.code() == std::future_errc::no_state );
+  }
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+}
Index: libstdc++-v3/testsuite/30_threads/promise/members/set_exception.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/promise/members/set_exception.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/promise/members/set_exception.cc	(.../branches/gcc-6-branch)
@@ -23,6 +23,7 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+// Test that promise::set_exception stores an exception.
 
 #include <future>
 #include <testsuite_hooks.h>
@@ -50,8 +51,56 @@
   VERIFY( !f1.valid() );
 }
 
+void test02()
+{
+  bool test = false;
+
+  std::promise<int&> p1;
+  std::future<int&> f1 = p1.get_future();
+
+  VERIFY( f1.valid() );
+
+  p1.set_exception(std::make_exception_ptr(0));
+
+  try
+  {
+    f1.get();
+  }
+  catch (int)
+  {
+    test = true;
+  }
+  VERIFY( test );
+  VERIFY( !f1.valid() );
+}
+
+void test03()
+{
+  bool test = false;
+
+  std::promise<void> p1;
+  std::future<void> f1 = p1.get_future();
+
+  VERIFY( f1.valid() );
+
+  p1.set_exception(std::make_exception_ptr(0));
+
+  try
+  {
+    f1.get();
+  }
+  catch (int)
+  {
+    test = true;
+  }
+  VERIFY( test );
+  VERIFY( !f1.valid() );
+}
+
 int main()
 {
   test01();
+  test02();
+  test03();
   return 0;
 }
Index: libstdc++-v3/testsuite/30_threads/promise/members/set_value2.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/30_threads/promise/members/set_value2.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/30_threads/promise/members/set_value2.cc	(.../branches/gcc-6-branch)
@@ -23,10 +23,13 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
+// Test that promise::set_value throws when required.
 
 #include <future>
 #include <testsuite_hooks.h>
 
+// Check for promise_already_satisfied error conditions.
+
 void test01()
 {
   bool test = false;
@@ -81,9 +84,298 @@
   VERIFY( test );
 }
 
+void test03()
+{
+  bool test = false;
+
+  std::promise<int> p1;
+  std::future<int> f1 = p1.get_future();
+
+  p1.set_exception(std::make_exception_ptr(4));
+
+  try
+  {
+    p1.set_value(3);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  std::chrono::milliseconds delay(1);
+  VERIFY( f1.wait_for(delay) == std::future_status::ready );
+  test = false;
+  try
+  {
+    f1.get();
+    VERIFY( false );
+  }
+  catch (int e)
+  {
+    VERIFY(e == 4 );
+    test = true;
+  }
+
+  VERIFY( test );
+}
+
+void test04()
+{
+  bool test = false;
+
+  std::promise<int&> p1;
+  std::future<int&> f1 = p1.get_future();
+
+  int i = 1;
+  p1.set_value(i);
+
+  try
+  {
+    p1.set_value(i);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  std::chrono::milliseconds delay(1);
+  VERIFY( f1.wait_for(delay) == std::future_status::ready );
+  VERIFY( f1.get() == 1 );
+  VERIFY( test );
+}
+
+void test05()
+{
+  bool test = false;
+
+  std::promise<int&> p1;
+  std::future<int&> f1 = p1.get_future();
+
+  int i = 3;
+  p1.set_value(i);
+
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(4));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  std::chrono::milliseconds delay(1);
+  VERIFY( f1.wait_for(delay) == std::future_status::ready );
+  VERIFY( f1.get() == 3 );
+  VERIFY( test );
+}
+
+void test06()
+{
+  bool test = false;
+
+  std::promise<int&> p1;
+  std::future<int&> f1 = p1.get_future();
+
+  p1.set_exception(std::make_exception_ptr(4));
+
+  try
+  {
+    int i = 3;
+    p1.set_value(i);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  std::chrono::milliseconds delay(1);
+  VERIFY( f1.wait_for(delay) == std::future_status::ready );
+  test = false;
+  try
+  {
+    f1.get();
+    VERIFY( false );
+  }
+  catch (int e)
+  {
+    VERIFY(e == 4 );
+    test = true;
+  }
+
+  VERIFY( test );
+}
+
+void test07()
+{
+  bool test = false;
+
+  std::promise<void> p1;
+  std::future<void> f1 = p1.get_future();
+
+  p1.set_value();
+
+  try
+  {
+    p1.set_value();
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  std::chrono::milliseconds delay(1);
+  VERIFY( f1.wait_for(delay) == std::future_status::ready );
+  f1.get();
+  VERIFY( test );
+}
+
+void test08()
+{
+  bool test = false;
+
+  std::promise<void> p1;
+  std::future<void> f1 = p1.get_future();
+
+  p1.set_value();
+
+  try
+  {
+    p1.set_exception(std::make_exception_ptr(4));
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  std::chrono::milliseconds delay(1);
+  VERIFY( f1.wait_for(delay) == std::future_status::ready );
+  f1.get();
+  VERIFY( test );
+}
+
+void test09()
+{
+  bool test = false;
+
+  std::promise<void> p1;
+  std::future<void> f1 = p1.get_future();
+
+  p1.set_exception(std::make_exception_ptr(4));
+
+  try
+  {
+    p1.set_value();
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() ==
+        std::make_error_code(std::future_errc::promise_already_satisfied));
+    test = true;
+  }
+
+  std::chrono::milliseconds delay(1);
+  VERIFY( f1.wait_for(delay) == std::future_status::ready );
+  test = false;
+  try
+  {
+    f1.get();
+    VERIFY( false );
+  }
+  catch (int e)
+  {
+    VERIFY(e == 4 );
+    test = true;
+  }
+
+  VERIFY( test );
+}
+
+// Check for no_state error condition (PR libstdc++/80316)
+
+void test10()
+{
+  using namespace std;
+
+  promise<int> p1;
+  promise<int> p2(std::move(p1));
+  try
+  {
+    p1.set_value(1);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() == make_error_code(future_errc::no_state));
+  }
+}
+
+void test11()
+{
+  using namespace std;
+
+  promise<int&> p1;
+  promise<int&> p2(std::move(p1));
+  try
+  {
+    int i = 0;
+    p1.set_value(i);
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() == make_error_code(future_errc::no_state));
+  }
+}
+
+void test12()
+{
+  using namespace std;
+
+  promise<void> p1;
+  promise<void> p2(std::move(p1));
+  try
+  {
+    p1.set_value();
+    VERIFY( false );
+  }
+  catch (std::future_error& e)
+  {
+    VERIFY(e.code() == make_error_code(future_errc::no_state));
+  }
+}
+
 int main()
 {
   test01();
   test02();
+  test03();
+  test04();
+  test05();
+  test06();
+  test07();
+  test08();
+  test09();
+  test10();
+  test11();
+  test12();
   return 0;
 }
Index: libstdc++-v3/testsuite/ext/stdio_filebuf/char/81751.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/ext/stdio_filebuf/char/81751.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/ext/stdio_filebuf/char/81751.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,53 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-require-fileio "" }
+
+#include <ext/stdio_filebuf.h>
+#include <cstdio>
+#include <cerrno>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  FILE* out = std::fopen("81751.txt", "w");
+  std::fwrite("Some words.", 1, 10, out);
+
+  FILE* in1 = std::fopen("81751.txt", "r");
+  __gnu_cxx::stdio_filebuf<char> buf1(in1, std::ios::in, BUFSIZ);
+  int c = buf1.sgetc();
+  VERIFY( c == std::char_traits<char>::eof() ); // PR libstdc++/81751
+
+  std::fflush(out);
+  FILE* in2 = std::fopen("81751.txt", "r");
+  __gnu_cxx::stdio_filebuf<char> buf2(in2, std::ios::in, BUFSIZ);
+  c = buf2.sgetc();
+  VERIFY( c == 'S' );
+
+  buf1.close();
+  buf2.close();
+  std::fclose(in1);
+  std::fclose(in2);
+  std::fclose(out);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/ext/stdio_filebuf/char/79820.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/ext/stdio_filebuf/char/79820.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/ext/stdio_filebuf/char/79820.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,39 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-require-fileio "" }
+
+#include <ext/stdio_filebuf.h>
+#include <cstdio>
+#include <cerrno>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  FILE* f = std::fopen("79820.txt", "w");
+  std::fclose(f);
+  errno = 127;
+  __gnu_cxx::stdio_filebuf<char> b(f, std::ios::out, BUFSIZ);
+  VERIFY(errno == 127); // PR libstdc++/79820
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_map/cons/81891.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_map/cons/81891.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_map/cons/81891.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,68 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <unordered_map>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+struct fails_on_copy {
+  fails_on_copy() = default;
+  fails_on_copy(const fails_on_copy&) { throw 0; };
+};
+
+using value_type = std::pair<int, fails_on_copy>;
+
+void
+test01()
+{
+  value_type p;
+  try
+  {
+    std::unordered_map<int, fails_on_copy> umap(&p, &p + 1);
+  }
+  catch(...)
+  { }
+}
+
+void
+test02()
+{
+  using Alloc = __gnu_test::tracker_allocator<value_type>;
+  using std::hash;
+  using std::equal_to;
+
+  value_type p;
+  try
+  {
+    std::unordered_map<int, fails_on_copy, hash<int>, equal_to<int>, Alloc>
+	umap(&p, &p + 1);
+  }
+  catch(...)
+  { }
+
+  using counter = __gnu_test::tracker_allocator_counter;
+  VERIFY(counter::get_allocation_count() == counter::get_deallocation_count());
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/27_io/basic_stringstream/assign/81338.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/basic_stringstream/assign/81338.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/basic_stringstream/assign/81338.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,40 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <sstream>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::stringstream ss;
+  for (int i = 0; i < 100; ++i)
+  {
+    ss << 'a';
+    VERIFY( static_cast<bool>(ss) );
+    VERIFY( ss.str() == "a" );
+    ss = std::stringstream();
+  }
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/27_io/basic_fstream/53984.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/basic_fstream/53984.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/basic_fstream/53984.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,64 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-require-fileio "" }
+
+// PR libstdc++/53984
+
+#include <fstream>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::ifstream in(".");
+  if (in)
+  {
+    char c;
+    if (in.get(c))
+    {
+      // Reading a directory doesn't produce an error on this target
+      // so the formatted input functions below wouldn't fail anyway
+      // (see PR libstdc++/81808).
+      return;
+    }
+    int x;
+    in.clear();
+    // Formatted input function should set badbit, but not throw:
+    in >> x;
+    VERIFY( in.bad() );
+
+    in.clear();
+    in.exceptions(std::ios::badbit);
+    try
+    {
+      // Formatted input function should set badbit, and throw:
+      in >> x;
+      VERIFY( false );
+    }
+    catch (const std::exception&)
+    {
+      VERIFY( in.bad() );
+    }
+  }
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/53984.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/53984.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/53984.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,41 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <streambuf>
+#include <istream>
+#include <testsuite_hooks.h>
+
+struct SB : std::streambuf
+{
+  virtual int_type underflow() { throw 1; }
+};
+
+void
+test01()
+{
+  SB sb;
+  std::istream is(&sb);
+  int i;
+  is >> i;
+  VERIFY( is.bad() );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/owner_less/noexcept.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/owner_less/noexcept.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/owner_less/noexcept.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,31 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+
+const std::shared_ptr<int> si;
+const std::weak_ptr<int> wi;
+const std::owner_less<std::shared_ptr<int>> osi;
+static_assert( noexcept(osi(si, si)), "" );
+static_assert( noexcept(osi(si, wi)), "" );
+static_assert( noexcept(osi(wi, si)), "" );
+const std::owner_less<std::weak_ptr<int>> owi;
+static_assert( noexcept(owi(wi, wi)), "" );
+static_assert( noexcept(owi(si, wi)), "" );
+static_assert( noexcept(owi(wi, si)), "" );
Index: libstdc++-v3/testsuite/20_util/duration/literals/range.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/duration/literals/range.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/duration/literals/range.cc	(.../branches/gcc-6-branch)
@@ -27,5 +27,5 @@
 
   // std::numeric_limits<int64_t>::max() == 9223372036854775807;
   auto h = 9223372036854775808h;
-  // { dg-error "cannot be represented" "" { target *-*-* } 797 }
+  // { dg-error "cannot be represented" "" { target *-*-* } 798 }
 }
Index: libstdc++-v3/testsuite/20_util/duration/cons/dr1177.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/duration/cons/dr1177.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/duration/cons/dr1177.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,41 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <chrono>
+#include <type_traits>
+
+using namespace std;
+using namespace std::chrono;
+
+// DR 1177
+static_assert(is_constructible<duration<float>, duration<double>>{},
+    "can convert duration with one floating point rep to another");
+static_assert(is_constructible<duration<float>, duration<int>>{},
+    "can convert duration with integral rep to one with floating point rep");
+static_assert(!is_constructible<duration<int>, duration<float>>{},
+    "cannot convert duration with floating point rep to one with integral rep");
+static_assert(is_constructible<duration<int>, duration<long>>{},
+    "can convert duration with one integral rep to another");
+
+static_assert(!is_constructible<duration<int>, duration<int, ratio<2,3>>>{},
+    "cannot convert duration to one with different period");
+static_assert(is_constructible<duration<float>, duration<int, ratio<2,3>>>{},
+    "unless it has a floating-point representation");
+static_assert(is_constructible<duration<float>, duration<int, ratio<1,3>>>{},
+    "or a period that is an integral multiple of the original");
Index: libstdc++-v3/testsuite/20_util/shared_ptr/observers/owner_before.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/shared_ptr/observers/owner_before.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/shared_ptr/observers/owner_before.cc	(.../branches/gcc-6-branch)
@@ -71,6 +71,12 @@
   VERIFY( !a1.owner_before(w1) && !w1.owner_before(a1) );
   std::weak_ptr<A> w2(a2);
   VERIFY( !b1.owner_before(w2) && !w2.owner_before(b1) );
+
+  static_assert( noexcept(a1.owner_before(a0)), "" );
+  static_assert( noexcept(a1.owner_before(b1)), "" );
+  static_assert( noexcept(b1.owner_before(a1)), "" );
+  static_assert( noexcept(a1.owner_before(w1)), "" );
+  static_assert( noexcept(b1.owner_before(w1)), "" );
 }
 
 // Aliasing
Index: libstdc++-v3/testsuite/20_util/function/assign/move.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/function/assign/move.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/function/assign/move.cc	(.../branches/gcc-6-branch)
@@ -40,11 +40,12 @@
   fo2 = (std::move(fo));
   VERIFY( static_cast<bool>(fo2) );
   VERIFY( fo2() == 2 );
+
+  static_assert(std::is_nothrow_move_assignable<function>::value,
+		"PR libstdc++/81017");
 }
 
 int main()
 {
   test01();
-
-  return 0;
 }
Index: libstdc++-v3/testsuite/20_util/function/cons/move.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/function/cons/move.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/function/cons/move.cc	(.../branches/gcc-6-branch)
@@ -38,11 +38,12 @@
   function fo2(std::move(fo));
   VERIFY( static_cast<bool>(fo2) );
   VERIFY( fo2() == 2 );
+
+  static_assert(std::is_nothrow_move_constructible<function>::value,
+		"PR libstdc++/81017");
 }
 
 int main()
 {
   test01();
-
-  return 0;
 }
Index: libstdc++-v3/testsuite/20_util/weak_ptr/observers/owner_before.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/weak_ptr/observers/owner_before.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/weak_ptr/observers/owner_before.cc	(.../branches/gcc-6-branch)
@@ -27,7 +27,7 @@
 
 // 20.6.6.3.5 weak_ptr observers [util.smartptr.weak.obs]
 
-int
+void
 test01()
 {
   bool test __attribute__((unused)) = true;
@@ -40,11 +40,14 @@
   std::shared_ptr<B> p3;
   VERIFY( !p1.owner_before(p3) && !p3.owner_before(p1) );
 
-  return 0;
+  static_assert( noexcept(p1.owner_before(p1)), "" );
+  static_assert( noexcept(p1.owner_before(p2)), "" );
+  static_assert( noexcept(p1.owner_before(p3)), "" );
+  static_assert( noexcept(p2.owner_before(p1)), "" );
 }
 
 
-int
+void
 test02()
 {
   bool test __attribute__((unused)) = true;
@@ -64,8 +67,6 @@
 
   std::shared_ptr<B> b1(new B);
   VERIFY( w1.owner_before(b1) || b1.owner_before(w1) );
-
-  return 0;
 }
 
 int 
Index: libstdc++-v3/testsuite/20_util/time_point/cons/81468.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/time_point/cons/81468.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/time_point/cons/81468.cc	(.../branches/gcc-6-branch)
@@ -0,0 +1,34 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <chrono>
+#include <type_traits>
+
+using namespace std;
+using namespace std::chrono;
+
+template <class Duration>
+    using sys_time = time_point<system_clock, Duration>;
+
+static_assert(is_constructible<sys_time<milliseconds>, sys_time<seconds>>{},
+    "Can construct time_point from one with lower precision duration");
+
+// PR libstdc++/81468 - DR 1177
+static_assert(!is_constructible<sys_time<seconds>, sys_time<milliseconds>>{},
+    "Cannot construct time_point from one with higher precision duration");
Index: libstdc++-v3/config/io/basic_file_stdio.cc
===================================================================
--- a/src/libstdc++-v3/config/io/basic_file_stdio.cc	(.../tags/gcc_6_4_0_release)
+++ b/src/libstdc++-v3/config/io/basic_file_stdio.cc	(.../branches/gcc-6-branch)
@@ -195,11 +195,13 @@
     __basic_file* __ret = NULL;
     if (!this->is_open() && __file)
       {
-	int __err;
-	errno = 0;	
+	int __err, __save_errno = errno;
+	// POSIX guarantees that fflush sets errno on error, but C doesn't.
+	errno = 0;
 	do
-	  __err = this->sync();
+	  __err = fflush(__file);
 	while (__err && errno == EINTR);
+	errno = __save_errno;
 	if (!__err)
 	  {
 	    _M_cfile = __file;
Index: lto-plugin/ChangeLog
===================================================================
--- a/src/lto-plugin/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/lto-plugin/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,12 @@
+2017-07-26  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2017-07-26 gcc-7-branch r250562.
+
+	PR lto/81487
+	* lto-plugin.c (claim_file_handler): Use xasprintf instead of
+	asprintf.
+	[hi!=0]: Swap hi and lo arguments supplied to xasprintf.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: lto-plugin/lto-plugin.c
===================================================================
--- a/src/lto-plugin/lto-plugin.c	(.../tags/gcc_6_4_0_release)
+++ b/src/lto-plugin/lto-plugin.c	(.../branches/gcc-6-branch)
@@ -975,17 +975,16 @@
 
   if (file->offset != 0)
     {
-      char *objname;
       /* We pass the offset of the actual file, not the archive header.
          Can't use PRIx64, because that's C99, so we have to print the
-	 64-bit hex int as two 32-bit ones. */
-      int lo, hi, t;
+	 64-bit hex int as two 32-bit ones.  Use xasprintf instead of
+	 asprintf because asprintf doesn't work as expected on some older
+	 mingw32 hosts.  */
+      int lo, hi;
       lo = file->offset & 0xffffffff;
       hi = ((int64_t)file->offset >> 32) & 0xffffffff;
-      t = hi ? asprintf (&objname, "%s@0x%x%08x", file->name, lo, hi)
-	     : asprintf (&objname, "%s@0x%x", file->name, lo);
-      check (t >= 0, LDPL_FATAL, "asprintf failed");
-      lto_file.name = objname;
+      lto_file.name = hi ? xasprintf ("%s@0x%x%08x", file->name, hi, lo)
+      			 : xasprintf ("%s@0x%x", file->name, lo);
     }
   else
     {
Index: libjava/include/i386-signal.h
===================================================================
--- a/src/libjava/include/i386-signal.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libjava/include/i386-signal.h	(.../branches/gcc-6-branch)
@@ -29,7 +29,7 @@
 #define HANDLE_DIVIDE_OVERFLOW						\
 do									\
 {									\
-  struct ucontext *_uc = (struct ucontext *)_p;				\
+  ucontext_t *_uc = (ucontext_t *)_p;					\
   gregset_t &_gregs = _uc->uc_mcontext.gregs;				\
   unsigned char *_eip = (unsigned char *)_gregs[REG_EIP];		\
 									\
Index: libjava/include/s390-signal.h
===================================================================
--- a/src/libjava/include/s390-signal.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libjava/include/s390-signal.h	(.../branches/gcc-6-branch)
@@ -51,7 +51,7 @@
   struct                                                                \
   {                                                                     \
     unsigned long int uc_flags;                                         \
-    struct ucontext *uc_link;                                           \
+    ucontext_t *uc_link;                                                \
     stack_t uc_stack;                                                   \
     mcontext_t uc_mcontext;                                             \
     unsigned long sigmask[2];                                           \
Index: libjava/include/x86_64-signal.h
===================================================================
--- a/src/libjava/include/x86_64-signal.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libjava/include/x86_64-signal.h	(.../branches/gcc-6-branch)
@@ -28,7 +28,7 @@
 #define HANDLE_DIVIDE_OVERFLOW						\
 do									\
 {									\
-  struct ucontext *_uc = (struct ucontext *)_p;				\
+  ucontext_t *_uc = (ucontext_t *)_p;					\
   gregset_t &_gregs = _uc->uc_mcontext.gregs;				\
   unsigned char *_rip = (unsigned char *)_gregs[REG_RIP];		\
 									\
Index: libjava/ChangeLog
===================================================================
--- a/src/libjava/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/libjava/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,10 @@
+2017-09-07  Matthias Klose  <doko@ubuntu.com>
+
+	* include/x86_64-signal.h (HANDLE_DIVIDE_OVERFLOW): Replace
+	'struct ucontext' with ucontext_t.
+	* include/i386-signal.h (HANDLE_DIVIDE_OVERFLOW): Likewise.
+	* include/s390-signal.h (HANDLE_DIVIDE_OVERFLOW): Likewise.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,26 @@
+2017-07-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2017-07-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* config/rs6000/float128-ifunc.c: Don't include auxv.h.
+	(have_ieee_hw_p): Delete function.
+	(SW_OR_HW) Use __builtin_cpu_supports().
+
+2017-07-04  Joseph Myers  <joseph@codesourcery.com>
+
+	* config/aarch64/linux-unwind.h (aarch64_fallback_frame_state),
+	config/alpha/linux-unwind.h (alpha_fallback_frame_state),
+	config/bfin/linux-unwind.h (bfin_fallback_frame_state),
+	config/i386/linux-unwind.h (x86_64_fallback_frame_state,
+	x86_fallback_frame_state), config/m68k/linux-unwind.h (struct
+	uw_ucontext), config/nios2/linux-unwind.h (struct nios2_ucontext),
+	config/pa/linux-unwind.h (pa32_fallback_frame_state),
+	config/sh/linux-unwind.h (sh_fallback_frame_state),
+	config/tilepro/linux-unwind.h (tile_fallback_frame_state),
+	config/xtensa/linux-unwind.h (xtensa_fallback_frame_state): Use
+	ucontext_t instead of struct ucontext.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: libgcc/config/alpha/linux-unwind.h
===================================================================
--- a/src/libgcc/config/alpha/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/alpha/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -51,7 +51,7 @@
     {
       struct rt_sigframe {
 	siginfo_t info;
-	struct ucontext uc;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       sc = &rt_->uc.uc_mcontext;
     }
Index: libgcc/config/m68k/linux-unwind.h
===================================================================
--- a/src/libgcc/config/m68k/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/m68k/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -33,7 +33,7 @@
 /* <sys/ucontext.h> is unfortunately broken right now.  */
 struct uw_ucontext {
 	unsigned long	  uc_flags;
-	struct ucontext  *uc_link;
+	ucontext_t	 *uc_link;
 	stack_t		  uc_stack;
 	mcontext_t	  uc_mcontext;
 	unsigned long	  uc_filler[80];
Index: libgcc/config/aarch64/linux-unwind.h
===================================================================
--- a/src/libgcc/config/aarch64/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/aarch64/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -52,7 +52,7 @@
   struct rt_sigframe
   {
     siginfo_t info;
-    struct ucontext uc;
+    ucontext_t uc;
   };
 
   struct rt_sigframe *rt_;
Index: libgcc/config/i386/linux-unwind.h
===================================================================
--- a/src/libgcc/config/i386/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/i386/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -58,7 +58,7 @@
   if (*(unsigned char *)(pc+0) == 0x48
       && *(unsigned long long *)(pc+1) == RT_SIGRETURN_SYSCALL)
     {
-      struct ucontext *uc_ = context->cfa;
+      ucontext_t *uc_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
          because it does not alias anything.  */
@@ -138,7 +138,7 @@
 	siginfo_t *pinfo;
 	void *puc;
 	siginfo_t info;
-	struct ucontext uc;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
Index: libgcc/config/rs6000/float128-ifunc.c
===================================================================
--- a/src/libgcc/config/rs6000/float128-ifunc.c	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/rs6000/float128-ifunc.c	(.../branches/gcc-6-branch)
@@ -45,48 +45,8 @@
 #error "This module must not be compiled with IEEE 128-bit hardware support"
 #endif
 
-#include <sys/auxv.h>
+#define SW_OR_HW(SW, HW) (__builtin_cpu_supports ("ieee128") ? HW : SW)
 
-/* Use the namespace clean version of getauxval.  However, not all versions of
-   sys/auxv.h declare it, so declare it here.  This code is intended to be
-   temporary until a suitable version of __builtin_cpu_supports is added that
-   allows us to tell quickly if the machine supports IEEE 128-bit hardware.  */
-extern unsigned long __getauxval (unsigned long);
-
-static int
-have_ieee_hw_p (void)
-{
-  static int ieee_hw_p = -1;
-
-  if (ieee_hw_p < 0)
-    {
-      char *p = (char *) __getauxval (AT_PLATFORM);
-
-      ieee_hw_p = 0;
-
-      /* Don't use atoi/strtol/strncmp/etc.  These may require the normal
-	 environment to be setup to set errno to 0, and the ifunc resolvers run
-	 before the whole glibc environment is initialized.  */
-      if (p && p[0] == 'p' && p[1] == 'o' && p[2] == 'w' && p[3] == 'e'
-	  && p[4] == 'r')
-	{
-	  long n = 0;
-	  char ch;
-
-	  p += 5;
-	  while ((ch = *p++) >= '0' && (ch <= '9'))
-	    n = (n * 10) + (ch - '0');
-
-	  if (n >= 9)
-	    ieee_hw_p = 1;
-	}
-    }
-
-  return ieee_hw_p;
-}
-
-#define SW_OR_HW(SW, HW) (have_ieee_hw_p () ? HW : SW)
-
 /* Resolvers.  */
 
 /* We do not provide ifunc resolvers for __fixkfti, __fixunskfti, __floattikf,
Index: libgcc/config/sh/linux-unwind.h
===================================================================
--- a/src/libgcc/config/sh/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/sh/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -180,7 +180,7 @@
     {
       struct rt_sigframe {
 	siginfo_t info;
-	struct ucontext uc;
+	ucontext_t uc;
       } *rt_ = context->cfa;
       /* The void * cast is necessary to avoid an aliasing warning.
          The aliasing warning is correct, but should not be a problem
Index: libgcc/config/tilepro/linux-unwind.h
===================================================================
--- a/src/libgcc/config/tilepro/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/tilepro/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -61,7 +61,7 @@
   struct rt_sigframe {
     unsigned char save_area[C_ABI_SAVE_AREA_SIZE];
     siginfo_t info;
-    struct ucontext uc;
+    ucontext_t uc;
   } *rt_;
 
   /* Return if this is not a signal handler.  */
Index: libgcc/config/pa/linux-unwind.h
===================================================================
--- a/src/libgcc/config/pa/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/pa/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -80,7 +80,7 @@
   struct sigcontext *sc;
   struct rt_sigframe {
     siginfo_t info;
-    struct ucontext uc;
+    ucontext_t uc;
   } *frame;
 
   /* rt_sigreturn trampoline:
Index: libgcc/config/xtensa/linux-unwind.h
===================================================================
--- a/src/libgcc/config/xtensa/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/xtensa/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -67,7 +67,7 @@
 
   struct rt_sigframe {
     siginfo_t info;
-    struct ucontext uc;
+    ucontext_t uc;
   } *rt_;
 
   /* movi a2, __NR_rt_sigreturn; syscall */
Index: libgcc/config/nios2/linux-unwind.h
===================================================================
--- a/src/libgcc/config/nios2/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/nios2/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -38,7 +38,7 @@
 
 struct nios2_ucontext {
   unsigned long uc_flags;
-  struct ucontext *uc_link;
+  ucontext_t *uc_link;
   stack_t uc_stack;
   struct nios2_mcontext uc_mcontext;
   sigset_t uc_sigmask;	/* mask last for extensibility */
Index: libgcc/config/bfin/linux-unwind.h
===================================================================
--- a/src/libgcc/config/bfin/linux-unwind.h	(.../tags/gcc_6_4_0_release)
+++ b/src/libgcc/config/bfin/linux-unwind.h	(.../branches/gcc-6-branch)
@@ -52,7 +52,7 @@
 	void *puc;
 	char retcode[8];
 	siginfo_t info;
-	struct ucontext uc;
+	ucontext_t uc;
       } *rt_ = context->cfa;
 
       /* The void * cast is necessary to avoid an aliasing warning.
Index: gcc/ipa-visibility.c
===================================================================
--- a/src/gcc/ipa-visibility.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ipa-visibility.c	(.../branches/gcc-6-branch)
@@ -97,7 +97,8 @@
 	   && !DECL_EXTERNAL (node->decl)
 	   && !node->externally_visible
 	   && !node->used_from_other_partition
-	   && !node->in_other_partition);
+	   && !node->in_other_partition
+	   && node->get_availability () >= AVAIL_AVAILABLE);
 }
 
 /* Return true when function can be marked local.  */
Index: gcc/tree-ssa-tail-merge.c
===================================================================
--- a/src/gcc/tree-ssa-tail-merge.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/tree-ssa-tail-merge.c	(.../branches/gcc-6-branch)
@@ -808,6 +808,9 @@
 same_succ_flush_bb (basic_block bb)
 {
   same_succ *same = BB_SAME_SUCC (bb);
+  if (! same)
+    return;
+
   BB_SAME_SUCC (bb) = NULL;
   if (bitmap_single_bit_set_p (same->bbs))
     same_succ_htab->remove_elt_with_hash (same, same->hashval);
Index: gcc/tree-chkp.c
===================================================================
--- a/src/gcc/tree-chkp.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/tree-chkp.c	(.../branches/gcc-6-branch)
@@ -3144,6 +3144,9 @@
       && !flag_chkp_incomplete_type)
       return chkp_get_zero_bounds ();
 
+  if (VOID_TYPE_P (TREE_TYPE (decl)))
+    return chkp_get_zero_bounds ();
+
   if (flag_chkp_use_static_bounds
       && TREE_CODE (decl) == VAR_DECL
       && (TREE_STATIC (decl)
Index: gcc/ipa-icf-gimple.c
===================================================================
--- a/src/gcc/ipa-icf-gimple.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ipa-icf-gimple.c	(.../branches/gcc-6-branch)
@@ -361,10 +361,14 @@
       }
     case LABEL_DECL:
       {
+	if (t1 == t2)
+	  return true;
+
 	int *bb1 = m_label_bb_map.get (t1);
 	int *bb2 = m_label_bb_map.get (t2);
 
-	return return_with_debug (*bb1 == *bb2);
+	/* Labels can point to another function (non-local GOTOs).  */
+	return return_with_debug (bb1 != NULL && bb2 != NULL && *bb1 == *bb2);
       }
     case PARM_DECL:
     case RESULT_DECL:
@@ -539,11 +543,8 @@
     }
 }
 
-/* Compares two tree list operands T1 and T2 and returns true if these
-   two trees are semantically equivalent.  */
-
 bool
-func_checker::compare_tree_list_operand (tree t1, tree t2)
+func_checker::compare_asm_inputs_outputs (tree t1, tree t2)
 {
   gcc_assert (TREE_CODE (t1) == TREE_LIST);
   gcc_assert (TREE_CODE (t2) == TREE_LIST);
@@ -556,6 +557,16 @@
       if (!compare_operand (TREE_VALUE (t1), TREE_VALUE (t2)))
 	return return_false ();
 
+      tree p1 = TREE_PURPOSE (t1);
+      tree p2 = TREE_PURPOSE (t2);
+
+      gcc_assert (TREE_CODE (p1) == TREE_LIST);
+      gcc_assert (TREE_CODE (p2) == TREE_LIST);
+
+      if (strcmp (TREE_STRING_POINTER (TREE_VALUE (p1)),
+		  TREE_STRING_POINTER (TREE_VALUE (p2))) != 0)
+	return return_false ();
+
       t2 = TREE_CHAIN (t2);
     }
 
@@ -1004,7 +1015,7 @@
       tree input1 = gimple_asm_input_op (g1, i);
       tree input2 = gimple_asm_input_op (g2, i);
 
-      if (!compare_tree_list_operand (input1, input2))
+      if (!compare_asm_inputs_outputs (input1, input2))
 	return return_false_with_msg ("ASM input is different");
     }
 
@@ -1013,7 +1024,7 @@
       tree output1 = gimple_asm_output_op (g1, i);
       tree output2 = gimple_asm_output_op (g2, i);
 
-      if (!compare_tree_list_operand (output1, output2))
+      if (!compare_asm_inputs_outputs (output1, output2))
 	return return_false_with_msg ("ASM output is different");
     }
 
Index: gcc/ipa-icf-gimple.h
===================================================================
--- a/src/gcc/ipa-icf-gimple.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ipa-icf-gimple.h	(.../branches/gcc-6-branch)
@@ -215,9 +215,9 @@
      is returned.  */
   bool compare_operand (tree t1, tree t2);
 
-  /* Compares two tree list operands T1 and T2 and returns true if these
-     two trees are semantically equivalent.  */
-  bool compare_tree_list_operand (tree t1, tree t2);
+  /* Compares GIMPLE ASM inputs (or outputs) where we iterate tree chain
+     and compare both TREE_PURPOSEs and TREE_VALUEs.  */
+  bool compare_asm_inputs_outputs (tree t1, tree t2);
 
   /* Verifies that trees T1 and T2, representing function declarations
      are equivalent from perspective of ICF.  */
Index: gcc/opts-common.c
===================================================================
--- a/src/gcc/opts-common.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/opts-common.c	(.../branches/gcc-6-branch)
@@ -986,7 +986,8 @@
       {
 	if (!handlers->handlers[i].handler (opts, opts_set, decoded,
 					    lang_mask, kind, loc,
-					    handlers, dc))
+					    handlers, dc,
+					    handlers->target_option_override_hook))
 	  return false;
       }
   
Index: gcc/c-family/c-cppbuiltin.c
===================================================================
--- a/src/gcc/c-family/c-cppbuiltin.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/c-family/c-cppbuiltin.c	(.../branches/gcc-6-branch)
@@ -891,6 +891,8 @@
 	cpp_define (pfile, "__cpp_transactional_memory=210500");
       if (flag_sized_deallocation)
 	cpp_define (pfile, "__cpp_sized_deallocation=201309");
+      if (flag_threadsafe_statics)
+	cpp_define (pfile, "__cpp_threadsafe_static_init=200806");
     }
   /* Note that we define this for C as well, so that we know if
      __attribute__((cleanup)) will interface with EH.  */
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,46 @@
+2017-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2017-09-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/82112
+	* c-common.c (sync_resolve_size): Instead of c_dialect_cxx ()
+	assertion check that in the condition.
+	(get_atomic_generic_size): Likewise.  Before testing if parameter
+	has pointer type, if it has array type, call for C++
+	default_conversion to perform array-to-pointer conversion.
+
+	2017-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/45784
+	* c-omp.c (c_finish_omp_for): If the condition is wrapped in
+	rhs of COMPOUND_EXPR(s), skip them and readd their lhs into
+	new COMPOUND_EXPRs around the rhs of the comparison.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-29  Martin Liska  <mliska@suse.cz>
+
+	PR other/39851
+	* c-common.c (parse_optimize_options): Add argument to function
+	call.
+	* c-pragma.c (handle_pragma_diagnostic): Likewise.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-06-28  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/81128
+	* c-attribs.c (handle_alias_ifunc_attribute): Append ifunc alias
+	to a function declaration.
+
+2017-09-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/81852
+	* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_threadsafe_static_init.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: gcc/c-family/c-common.c
===================================================================
--- a/src/gcc/c-family/c-common.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/c-family/c-common.c	(.../branches/gcc-6-branch)
@@ -7989,9 +7989,14 @@
 	TREE_STATIC (decl) = 1;
 
       if (!is_alias)
-	/* ifuncs are also aliases, so set that attribute too. */
-	DECL_ATTRIBUTES (decl)
-	  = tree_cons (get_identifier ("alias"), args, DECL_ATTRIBUTES (decl));
+	{
+	  /* ifuncs are also aliases, so set that attribute too.  */
+	  DECL_ATTRIBUTES (decl)
+	    = tree_cons (get_identifier ("alias"), args,
+			 DECL_ATTRIBUTES (decl));
+	  DECL_ATTRIBUTES (decl) = tree_cons (get_identifier ("ifunc"),
+					      NULL, DECL_ATTRIBUTES (decl));
+	}
     }
   else
     {
@@ -9583,7 +9588,7 @@
 						&decoded_options_count);
   decode_options (&global_options, &global_options_set,
 		  decoded_options, decoded_options_count,
-		  input_location, global_dc);
+		  input_location, global_dc, NULL);
 
   targetm.override_options_after_change();
 
@@ -10725,10 +10730,9 @@
     }
 
   argtype = type = TREE_TYPE ((*params)[0]);
-  if (TREE_CODE (type) == ARRAY_TYPE)
+  if (TREE_CODE (type) == ARRAY_TYPE && c_dialect_cxx ())
     {
       /* Force array-to-pointer decay for C++.  */
-      gcc_assert (c_dialect_cxx());
       (*params)[0] = default_conversion ((*params)[0]);
       type = TREE_TYPE ((*params)[0]);
     }
@@ -10890,10 +10894,9 @@
 
   /* Get type of first parameter, and determine its size.  */
   type_0 = TREE_TYPE ((*params)[0]);
-  if (TREE_CODE (type_0) == ARRAY_TYPE)
+  if (TREE_CODE (type_0) == ARRAY_TYPE && c_dialect_cxx ())
     {
       /* Force array-to-pointer decay for C++.  */
-      gcc_assert (c_dialect_cxx());
       (*params)[0] = default_conversion ((*params)[0]);
       type_0 = TREE_TYPE ((*params)[0]);
     }
@@ -10932,6 +10935,12 @@
       /* __atomic_compare_exchange has a bool in the 4th position, skip it.  */
       if (n_param == 6 && x == 3)
         continue;
+      if (TREE_CODE (type) == ARRAY_TYPE && c_dialect_cxx ())
+	{
+	  /* Force array-to-pointer decay for C++.  */
+	  (*params)[x] = default_conversion ((*params)[x]);
+	  type = TREE_TYPE ((*params)[x]);
+	}
       if (!POINTER_TYPE_P (type))
 	{
 	  error_at (loc, "argument %d of %qE must be a pointer type", x + 1,
Index: gcc/c-family/c-omp.c
===================================================================
--- a/src/gcc/c-family/c-omp.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/c-family/c-omp.c	(.../branches/gcc-6-branch)
@@ -518,6 +518,12 @@
 	{
 	  bool cond_ok = false;
 
+	  /* E.g. C sizeof (vla) could add COMPOUND_EXPRs with
+	     evaluation of the vla VAR_DECL.  We need to readd
+	     them to the non-decl operand.  See PR45784.  */
+	  while (TREE_CODE (cond) == COMPOUND_EXPR)
+	    cond = TREE_OPERAND (cond, 1);
+
 	  if (EXPR_HAS_LOCATION (cond))
 	    elocus = EXPR_LOCATION (cond);
 
@@ -592,6 +598,21 @@
 		  else if (code != CILK_SIMD && code != CILK_FOR)
 		    cond_ok = false;
 		}
+
+	      if (cond_ok && TREE_VEC_ELT (condv, i) != cond)
+		{
+		  tree ce = NULL_TREE, *pce = &ce;
+		  tree type = TREE_TYPE (TREE_OPERAND (cond, 1));
+		  for (tree c = TREE_VEC_ELT (condv, i); c != cond;
+		       c = TREE_OPERAND (c, 1))
+		    {
+		      *pce = build2 (COMPOUND_EXPR, type, TREE_OPERAND (c, 0),
+				     TREE_OPERAND (cond, 1));
+		      pce = &TREE_OPERAND (*pce, 1);
+		    }
+		  TREE_OPERAND (cond, 1) = ce;
+		  TREE_VEC_ELT (condv, i) = cond;
+		}
 	    }
 
 	  if (!cond_ok)
Index: gcc/c-family/c-pragma.c
===================================================================
--- a/src/gcc/c-family/c-pragma.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/c-family/c-pragma.c	(.../branches/gcc-6-branch)
@@ -813,7 +813,7 @@
     }
 
   struct cl_option_handlers handlers;
-  set_default_handlers (&handlers);
+  set_default_handlers (&handlers, NULL);
   const char *arg = NULL;
   if (cl_options[option_index].flags & CL_JOINED)
     arg = option_string + 1 + cl_options[option_index].opt_len;
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-6-branch)
@@ -1 +1 @@
-20170704
+20170920
Index: gcc/gcc.c
===================================================================
--- a/src/gcc/gcc.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/gcc.c	(.../branches/gcc-6-branch)
@@ -869,8 +869,7 @@
 #endif
 
 #ifdef ENABLE_DEFAULT_PIE
-#define NO_PIE_SPEC		"no-pie|static"
-#define PIE_SPEC		NO_PIE_SPEC "|r|shared:;"
+#define PIE_SPEC		"!no-pie"
 #define NO_FPIE1_SPEC		"fno-pie"
 #define FPIE1_SPEC		NO_FPIE1_SPEC ":;"
 #define NO_FPIE2_SPEC		"fno-PIE"
@@ -891,7 +890,6 @@
 #define FPIE_OR_FPIC_SPEC	NO_FPIE_AND_FPIC_SPEC ":;"
 #else
 #define PIE_SPEC		"pie"
-#define NO_PIE_SPEC		PIE_SPEC "|r|shared:;"
 #define FPIE1_SPEC		"fpie"
 #define NO_FPIE1_SPEC		FPIE1_SPEC ":;"
 #define FPIE2_SPEC		"fPIE"
@@ -920,7 +918,7 @@
 #else
 #define LD_PIE_SPEC ""
 #endif
-#define LINK_PIE_SPEC "%{no-pie:} " "%{" PIE_SPEC ":" LD_PIE_SPEC "} "
+#define LINK_PIE_SPEC "%{static|shared|r:;" PIE_SPEC ":" LD_PIE_SPEC "} "
 #endif
 
 #ifndef LINK_BUILDID_SPEC
@@ -999,8 +997,10 @@
 #endif
 
 /* -u* was put back because both BSD and SysV seem to support it.  */
-/* %{static:} simply prevents an error message if the target machine
-   doesn't handle -static.  */
+/* %{static|no-pie:} simply prevents an error message:
+   1. If the target machine doesn't handle -static.
+   2. If PIE isn't enabled by default.
+ */
 /* We want %{T*} after %{L*} and %D so that it can be used to specify linker
    scripts which exist in user specified directories, or in standard
    directories.  */
@@ -1017,7 +1017,7 @@
    "%{fuse-ld=*:-fuse-ld=%*} " LINK_COMPRESS_DEBUG_SPEC \
    "%X %{o*} %{e*} %{N} %{n} %{r}\
     %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}} \
-    %{static:} %{L*} %(mfwrap) %(link_libgcc) " \
+    %{static|no-pie:} %{L*} %(mfwrap) %(link_libgcc) " \
     VTABLE_VERIFICATION_SPEC " " SANITIZER_EARLY_SPEC " %o " CHKP_SPEC " \
     %{fopenacc|fopenmp|%:gt(%{ftree-parallelize-loops=*:%*} 1):\
 	%:include(libgomp.spec)%(link_gomp)}\
@@ -3702,7 +3702,8 @@
 		      unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,
 		      location_t loc,
 		      const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED,
-		      diagnostic_context *dc)
+		      diagnostic_context *dc,
+		      void (*) (void))
 {
   size_t opt_index = decoded->opt_index;
   const char *arg = decoded->arg;
Index: gcc/fold-const.c
===================================================================
--- a/src/gcc/fold-const.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/fold-const.c	(.../branches/gcc-6-branch)
@@ -7356,15 +7356,10 @@
 static int
 native_encode_string (const_tree expr, unsigned char *ptr, int len, int off)
 {
-  tree type = TREE_TYPE (expr);
-  HOST_WIDE_INT total_bytes;
+  if (! can_native_encode_string_p (expr))
+    return 0;
 
-  if (TREE_CODE (type) != ARRAY_TYPE
-      || TREE_CODE (TREE_TYPE (type)) != INTEGER_TYPE
-      || GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type))) != BITS_PER_UNIT
-      || !tree_fits_shwi_p (TYPE_SIZE_UNIT (type)))
-    return 0;
-  total_bytes = tree_to_shwi (TYPE_SIZE_UNIT (type));
+  HOST_WIDE_INT total_bytes = tree_to_shwi (TYPE_SIZE_UNIT (TREE_TYPE (expr)));
   if ((off == -1 && total_bytes > len)
       || off >= total_bytes)
     return 0;
@@ -7638,6 +7633,22 @@
     }
 }
 
+/* Return true iff a STRING_CST S is accepted by
+   native_encode_expr.  */
+
+bool
+can_native_encode_string_p (const_tree expr)
+{
+  tree type = TREE_TYPE (expr);
+
+  if (TREE_CODE (type) != ARRAY_TYPE
+      || TREE_CODE (TREE_TYPE (type)) != INTEGER_TYPE
+      || (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type))) != BITS_PER_UNIT)
+      || !tree_fits_shwi_p (TYPE_SIZE_UNIT (type)))
+    return false;
+  return true;
+}
+
 /* Fold a VIEW_CONVERT_EXPR of a constant expression EXPR to type
    TYPE at compile-time.  If we're unable to perform the conversion
    return NULL_TREE.  */
@@ -13980,8 +13991,8 @@
 	bool overflow;
 	wide_int val = wi::neg (arg0, &overflow);
 	t = force_fit_type (type, val, 1,
-			    (overflow | TREE_OVERFLOW (arg0))
-			    && !TYPE_UNSIGNED (type));
+			    (overflow && ! TYPE_UNSIGNED (type))
+			    || TREE_OVERFLOW (arg0));
 	break;
       }
 
Index: gcc/fold-const.h
===================================================================
--- a/src/gcc/fold-const.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/fold-const.h	(.../branches/gcc-6-branch)
@@ -27,6 +27,7 @@
 /* Convert between trees and native memory representation.  */
 extern int native_encode_expr (const_tree, unsigned char *, int, int off = -1);
 extern tree native_interpret_expr (tree, const unsigned char *, int);
+extern bool can_native_encode_string_p (const_tree);
 
 /* Fold constants as much as possible in an expression.
    Returns the simplified expression.
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-6-branch)
@@ -1559,6 +1559,8 @@
 
   if (TREE_CODE (var) == LABEL_DECL)
     {
+      if (FORCED_LABEL (var) || DECL_NONLOCAL (var))
+	return var;
       new_var = create_artificial_label (DECL_SOURCE_LOCATION (var));
       DECL_CONTEXT (new_var) = current_function_decl;
       insert_decl_map (&ctx->cb, var, new_var);
@@ -10651,12 +10653,14 @@
 	      tree itype2 = TREE_TYPE (fd->loops[i - 1].v);
 	      if (POINTER_TYPE_P (itype2))
 		itype2 = signed_type_for (itype2);
+	      t = fold_convert (itype2, fd->loops[i - 1].step);
+	      t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true,
+					    GSI_SAME_STMT);
 	      t = build3 (COND_EXPR, itype2,
 			  build2 (fd->loops[i].cond_code, boolean_type_node,
 				  fd->loops[i].v,
 				  fold_convert (itype, fd->loops[i].n2)),
-			  build_int_cst (itype2, 0),
-			  fold_convert (itype2, fd->loops[i - 1].step));
+			  build_int_cst (itype2, 0), t);
 	      if (POINTER_TYPE_P (TREE_TYPE (fd->loops[i - 1].v)))
 		t = fold_build_pointer_plus (fd->loops[i - 1].v, t);
 	      else
@@ -10663,12 +10667,14 @@
 		t = fold_build2 (PLUS_EXPR, itype2, fd->loops[i - 1].v, t);
 	      expand_omp_build_assign (&gsi, fd->loops[i - 1].v, t);
 
+	      t = fold_convert (itype, fd->loops[i].n1);
+	      t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true,
+					    GSI_SAME_STMT);
 	      t = build3 (COND_EXPR, itype,
 			  build2 (fd->loops[i].cond_code, boolean_type_node,
 				  fd->loops[i].v,
 				  fold_convert (itype, fd->loops[i].n2)),
-			  fd->loops[i].v,
-			  fold_convert (itype, fd->loops[i].n1));
+			  fd->loops[i].v, t);
 	      expand_omp_build_assign (&gsi, fd->loops[i].v, t);
 	    }
 	}
@@ -15175,10 +15181,14 @@
       rhs_p = gimple_omp_for_initial_ptr (stmt, i);
       if (!is_gimple_min_invariant (*rhs_p))
 	*rhs_p = get_formal_tmp_var (*rhs_p, &body);
+      else if (TREE_CODE (*rhs_p) == ADDR_EXPR)
+	recompute_tree_invariant_for_addr_expr (*rhs_p);
 
       rhs_p = gimple_omp_for_final_ptr (stmt, i);
       if (!is_gimple_min_invariant (*rhs_p))
 	*rhs_p = get_formal_tmp_var (*rhs_p, &body);
+      else if (TREE_CODE (*rhs_p) == ADDR_EXPR)
+	recompute_tree_invariant_for_addr_expr (*rhs_p);
 
       rhs_p = &TREE_OPERAND (gimple_omp_for_incr (stmt, i), 1);
       if (!is_gimple_min_invariant (*rhs_p))
@@ -18027,7 +18037,7 @@
     }
   if (kind == NULL)
     {
-      gcc_checking_assert (flag_openmp);
+      gcc_checking_assert (flag_openmp || flag_openmp_simd);
       kind = "OpenMP";
     }
 
@@ -18446,7 +18456,7 @@
   /* opt_pass methods: */
   virtual bool gate (function *)
   {
-    return flag_cilkplus || flag_openacc || flag_openmp;
+    return flag_cilkplus || flag_openacc || flag_openmp || flag_openmp_simd;
   }
   virtual unsigned int execute (function *)
     {
Index: gcc/toplev.c
===================================================================
--- a/src/gcc/toplev.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/toplev.c	(.../branches/gcc-6-branch)
@@ -2100,7 +2100,8 @@
      enough to default flags appropriately.  */
   decode_options (&global_options, &global_options_set,
 		  save_decoded_options, save_decoded_options_count,
-		  UNKNOWN_LOCATION, global_dc);
+		  UNKNOWN_LOCATION, global_dc,
+		  targetm.target_option.override);
 
   handle_common_deferred_options ();
 
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- a/src/gcc/tree-ssa-sccvn.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/tree-ssa-sccvn.c	(.../branches/gcc-6-branch)
@@ -2169,7 +2169,7 @@
       memset (&op, 0, sizeof (op));
       op.type = vr->type;
       op.opcode = MEM_REF;
-      op.op0 = build_int_cst (ptr_type_node, at - rhs_offset);
+      op.op0 = build_int_cst (ptr_type_node, at - lhs_offset + rhs_offset);
       op.off = at - lhs_offset + rhs_offset;
       vr->operands[0] = op;
       op.type = TREE_TYPE (rhs);
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,532 @@
+2017-09-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (fold_builtin_cpu): Add M_AMDFAM17H
+	to processor_model and "amdfam17h" to arch_names_table.
+	* doc/extend.texi (__builtin_cpu_is): Document amdfam17h CPU name.
+
+2017-09-19  Martin Liska  <mliska@suse.cz>
+
+	PR c++/81355
+	* config/i386/i386.c (sorted_attr_string): Skip empty strings.
+
+2017-09-19  Martin Liska  <mliska@suse.cz>
+
+	Revert backport:
+	2017-08-10  Martin Liska  <mliska@suse.cz>
+
+	PR c++/81355
+	* c-attribs.c (handle_target_attribute):
+	Report warning for an empty string argument of target attribute.
+
+2017-09-18  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2017-08-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/81977
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Fix look through
+	memcpy.
+
+	2017-09-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82084
+	* fold-const.h (can_native_encode_string_p): Declare.
+	* fold-const.c (can_native_encode_string_p): Factor out from ...
+	(native_encode_string): ... here.
+	* tree-vect-stmts.c (vectorizable_store): Call it to avoid
+	vectorizing stores from constants we later cannot handle.
+
+	2017-07-25  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/81505
+	* fold-const.c (fold_negate_const): TREE_OVERFLOW should be
+	sticky.
+
+2017-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2017-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/81768
+	* omp-low.c (lower_omp_for): Recompute tree invariant if
+	gimple_omp_for_initial/final is ADDR_EXPR.
+
+	PR middle-end/81768
+	* omp-low.c (expand_omp_simd): Force second operands of COND_EXPR
+	into gimple val before gimplification fo the COND_EXPR.
+
+	2017-09-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* lra-remat.c (reg_overlap_for_remat_p): Fix a pasto.
+
+	2017-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/81687
+	* omp-low.c (omp_copy_decl): Don't remap FORCED_LABEL or DECL_NONLOCAL
+	LABEL_DECLs.
+	* tree-cfg.c (move_stmt_op): Don't adjust DECL_CONTEXT of FORCED_LABEL
+	or DECL_NONLOCAL labels.
+	(move_stmt_r) <case GIMPLE_LABEL>: Adjust DECL_CONTEXT of FORCED_LABEL
+	or DECL_NONLOCAL labels here.
+
+	2017-08-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/81766
+	* function.c (thread_prologue_and_epilogue_insns): Restore
+	behavior of always calling find_many_sub_basic_blocks on
+	the inserted prologue.
+
+	2017-08-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/81621
+	* bb-reorder.c (pass_partition_blocks::execute): Return TODO_df_finish
+	after setting changeable df flags.
+
+	PR middle-end/81052
+	* omp-low.c (diagnose_sb_0): Handle flag_openmp_simd like flag_openmp.
+	(pass_diagnose_omp_blocks::gate): Enable also for flag_openmp_simd.
+
+	2017-08-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/79499
+	* function.c (thread_prologue_and_epilogue_insns): Determine blocks
+	for find_many_sub_basic_blocks bitmap by looking up BLOCK_FOR_INSN
+	of first NONDEBUG_INSN_P in each of the split_prologue_seq and
+	prologue_seq sequences - if any.
+
+	2017-06-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/81225
+	* config/i386/sse.md (vec_extract_lo_<mode><mask_name>): For
+	V8FI, V16FI and VI8F_256 iterators, use <store_mask_predicate> instead
+	of nonimmediate_operand and <store_mask_constraint> instead of m for
+	the input operand.  For V8FI iterator, always split if input is a MEM.
+	For V16FI and V8SF_256 iterators, don't test if both operands are MEM
+	if <mask_applied>.  For VI4F_256 iterator, use <store_mask_predicate>
+	instead of register_operand and <store_mask_constraint> instead of v for
+	the input operand.  Make sure both operands aren't MEMs for if not
+	<mask_applied>.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-11  Martin Liska  <mliska@suse.cz>
+
+	PR tree-opt/79987
+	* tree-chkp.c (chkp_get_bounds_for_decl_addr): Do not instrument
+	variables of void type.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-06-28  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/81224
+	* asan.c (instrument_derefs): Bail out inner references
+	that are hard register variables.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-30  Martin Liska  <mliska@suse.cz>
+
+	PR inline-asm/82001
+	* ipa-icf-gimple.c (func_checker::compare_tree_list_operand):
+	Rename to ...
+	(func_checker::compare_asm_inputs_outputs): ... this function.
+	(func_checker::compare_gimple_asm): Use the function to compare
+	also ASM constrains.
+	* ipa-icf-gimple.h: Rename the function.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-29  Martin Liska  <mliska@suse.cz>
+
+	PR other/39851
+	* gcc.c (driver_handle_option): Add new argument.
+	* opts-common.c (handle_option): Pass
+	target_option_override_hook.
+	* opts-global.c (lang_handle_option): Add new option.
+	(set_default_handlers):  Add new argument.
+	(decode_options): Likewise.
+	* opts.c (target_handle_option): Likewise.
+	(common_handle_option): Call target_option_override_hook.
+	* opts.h (struct cl_option_handler_func): Add hook for
+	target option override.
+	(struct cl_option_handlers): Likewise.
+	(set_default_handlers): Add new argument.
+	(decode_options): Likewise.
+	(common_handle_option): Likewise.
+	(target_handle_option): Likewise.
+	* toplev.c (toplev::main): Pass targetm.target_option.override
+	hook.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-10  Martin Liska  <mliska@suse.cz>
+
+	PR c++/81355
+	* c-attribs.c (handle_target_attribute):
+	Report warning for an empty string argument of target attribute.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-08  Martin Liska  <mliska@suse.cz>
+
+	PR tree-opt/81696
+	* ipa-icf-gimple.c (func_checker::compare_cst_or_decl): Consider
+	LABEL_DECLs that can be from a different function.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-06-28  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/81128
+	* ipa-visibility.c (non_local_p): Handle visibility.
+
+2017-09-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/81833
+	* config/rs6000/altivec.md (altivec_vsum2sws): Convert from a
+	define_insn to a define_expand.
+	(altivec_vsum2sws_direct): New define_insn.
+	(altivec_vsumsws): Convert from a define_insn to a define_expand.
+
+2017-09-11  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	PR target/82181
+	* config/xtensa/xtensa.c (xtensa_mem_offset): Check that both
+	words of DImode object are reachable by xtensa_uimm8x4 access.
+
+2017-09-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2017-08-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/81987
+	* gimple-ssa-strength-reduction.c (insert_initializers): Don't
+	insert an initializer in a location not dominated by the stride
+	definition.
+
+2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-08-29  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/81503
+	* gimple-ssa-strength-reduction.c (replace_mult_candidate): Ensure
+	folded constant fits in the target type; reorder tests for clarity.
+
+2017-08-30  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2017-08-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/81593
+	* config/rs6000/vsx.md (vsx_concat_<mode>_1): New combiner insns
+	to recognize inserting into a vector from a double word element
+	that was extracted from another vector, and eliminate extra
+	XXPERMDI instructions.
+	(vsx_concat_<mode>_2): Likewise.
+	(vsx_concat_<mode>_3): Likewise.
+	(vsx_set_<mode>, VSX_D): Rewrite vector set in terms of vector
+	concat to allow optimizing inserts from previous extracts.
+
+2017-08-29  Alan Modra  <amodra@gmail.com>
+
+	Apply from mainline
+	2017-08-12  Alan Modra  <amodra@gmail.com>
+	PR target/81170
+	PR target/81295
+	* config/rs6000/sysv4.h (STARTFILE_LINUX_SPEC): Upgrade to
+	match gnu-user.h startfile.
+	(ENDFILE_LINUX_SPEC): Similarly.
+
+	2017-08-08  Alan Modra  <amodra@gmail.com>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+	PR target/81170
+	PR target/81295
+	PR driver/81523
+	* gcc.c (NO_PIE_SPEC): Delete.
+	(PIE_SPEC): Define as !no-pie/pie.  Move static|shared|r
+	exclusion..
+	(LINK_PIE_SPEC): ..to here.
+	(LINK_COMMAND_SPEC): Support -no-pie.
+	* config/gnu-user.h (GNU_USER_TARGET_STARTFILE_SPEC): Correct
+	chain of crtbegin*.o selection, update for PIE_SPEC changes and
+	format.
+	(GNU_USER_TARGET_ENDFILE_SPEC): Similarly.
+	* config/sol2.h (STARTFILE_CRTBEGIN_SPEC): Similarly.
+	(ENDFILE_CRTEND_SPEC): Similarly.
+
+2017-08-24  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from mainline
+	2017-04-17  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR c++/80287
+	* class.c (fixup_may_alias): Fix all type variants.
+
+2017-08-22  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2017-08-17  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/80210
+	* config/rs6000/rs6000.c (rs6000_activate_target_options): New function.
+	(rs6000_set_current_function): Rewrite function to use it.
+
+2017-08-22  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2017-08-22 trunk r251256.
+
+	PR target/81910
+	* config/avr/avr.c (avr_handle_addr_attribute): Early return if
+	not VAR_P. Filter attribute warnings with OPT_Wattributes.
+	(avr_attribute_table) <io, io_low, address>: Initialize
+	.decl_required with true.
+
+2017-08-21  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/79883
+	* config/avr/avr.c (avr_set_current_function): Typo in diagnostic.
+
+2017-08-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81894
+	* doc/extend.texi (x86 Built-in Functions): Correct the name of
+	__builtin_ia32_lzcnt_u16.
+
+2017-08-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2017-08-17  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR target/81861
+	* config/i386/i386.c (ix86_option_override_internal): Save target
+	specific options after ix86_stack_protector_guard_reg was changed.
+
+2017-08-16  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-08-08  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/81354
+	* gimple-ssa-strength-reduction.c (create_add_on_incoming_edge):
+	Insert on edges rather than explicitly creating landing pads.
+	(analyze_candidates_and_replace): Commit edge inserts.
+
+2017-08-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81641
+	* config/i386/i386.c (ix86_print_operand_address_as): For -masm=intel
+	print "ds:" only for immediates in generic address space.
+
+2017-07-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/81604
+	* ubsan.c (ubsan_type_descriptor): For UBSAN_PRINT_ARRAY don't
+	change type to the element type, instead add eltype variable and
+	use it where we are interested in the element type.
+
+2017-07-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2017-07-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* config/rs6000/ppc-auxv.h (PPC_FEATURE2_DARN): New define.
+	(PPC_FEATURE2_SCV): Likewise.
+	* config/rs6000/rs6000.c (cpu_supports_info): Use them.
+
+2017-07-28  Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline r250496
+	2017-07-25  Bin Cheng  <bin.cheng@arm.com>
+
+	PR target/81414
+	* config/aarch64/cortex-a57-fma-steering.c (analyze): Skip fmul/fmac
+	instructions if no du chain is found.
+
+2017-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81555
+	PR tree-optimization/81556
+	* tree-ssa-reassoc.c (rewrite_expr_tree): Add NEXT_CHANGED argument,
+	if true, force CHANGED for the recursive invocation.
+	(reassociate_bb): Remember original length of ops array, pass
+	len != orig_len as NEXT_CHANGED in rewrite_expr_tree call.
+
+2017-07-26  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline r235874
+	2016-05-04  Alan Modra  <amodra@gmail.com>
+
+	* config/rs6000/rs6000.c (rs6000_elf_output_toc_section_asm_op):
+	Align .toc.
+
+2017-07-26  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2016-06-15 trunk r237486.
+	Backport from 2017-07-12 trunk r250156.
+
+	PR target/79883
+	PR target/67353
+	* config/avr/avr.c (avr_set_current_function): Warn misspelled ISR
+	only if -Wmisspelled-isr is on.  In diagnostic messages: Quote
+	keywords and (parts of) identifiers.
+	[WITH_AVRLIBC]: Warn functions named "ISR", "SIGNAL" or "INTERUPT".
+	* doc/invoke.texi (AVR Options) <-Wmisspelled-isr>: Decument.
+
+2017-07-26  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2017-07-05 trunk r249995.
+
+	PR target/81305
+	* config/avr/avr.c (avr_out_movhi_mr_r_xmega) [CONSTANT_ADDRESS_P]:
+	Don't depend on "optimize > 0".
+	(out_movhi_r_mr, out_movqi_mr_r): Same.
+	(out_movhi_mr_r, out_movqi_r_mr): Same.
+	(avr_address_cost) [CONSTANT_ADDRESS_P]: Don't depend cost for
+	io_address_operand on "optimize > 0".
+
+2017-07-26  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2017-07-12 trunk r250151.
+
+	PR target/81407
+	* config/avr/avr.c (avr_encode_section_info)
+	[progmem && !TREE_READONLY]: Error if progmem object needs
+	constructing.
+
+2017-07-26  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2017-07-26 gcc-7-branch r250562.
+
+	PR 81487
+	* hsa-brig.c (brig_init): Use xasprintf instead of asprintf.
+	* tree-ssa-structalias.c (alias_get_name): Same.
+
+2017-07-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2016-07-14  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/81162
+	* gimple-ssa-strength-reduction.c (replace_mult_candidate): Don't
+	replace a negate with an add.
+
+2017-07-25  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from trunk r247719.
+
+	2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR rtl-optimization/75964
+	* simplify-rtx.c (simplify_const_relational_operation): Remove
+	invalid handling of comparisons of integer ABS.
+
+2017-07-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/80569
+	* config/i386/i386.c (ix86_option_override_internal): Disable
+	BMI, BMI2 and TBM instructions for -m16.
+
+2017-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81471
+	* config/i386/i386.md (rorx_immediate_operand): New mode attribute.
+	(*bmi2_rorx<mode>3_1): Use rorx_immediate_operand as
+	operand 2 predicate.
+	(*bmi2_rorxsi3_1_zext): Use const_0_to_31_operand as
+	operand 2 predicate.
+	(ror,rol -> rorx splitters): Use const_int_operand as
+	operand 2 predicate.
+
+2017-07-17  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2017-07-17 trunk r250258.
+
+	PR 80929
+	* config/avr/avr.c (avr_mul_highpart_cost): New static function.
+	(avr_rtx_costs_1) [TRUNCATE]: Use it to compute mul_highpart cost.
+	[LSHIFTRT, outer_code = TRUNCATE]: Same.
+
+2017-07-14  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backports from trunk
+
+	2017-03-23  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Change
+	handling of certain combinations of target options, including the
+	combinations -mpower8-vector vs. -mno-vsx, -mpower8-vector vs.
+	-mno-power8-vector, and -mpower9_dform vs. -mno-power9-vector.
+
+	2017-03-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	PR target/80103
+	* config/rs6000/rs6000.c (rs6000_option_override_internal): Add
+	special handling for target option conflicts between dform options
+	(-mpower9-dform, -mpower9-dform-vector, -mpower9-dform-scalar) and
+	-mno-direct-move.
+
+	2017-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	PR target/80101
+	* config/rs6000/power6.md: Replace store_data_bypass_p calls with
+	rs6000_store_data_bypass_p in seven define_bypass directives and
+	in several comments.
+	* config/rs6000/rs6000-protos.h: Add prototype for
+	rs6000_store_data_bypass_p function.
+	* config/rs6000/rs6000.c (rs6000_store_data_bypass_p): New
+	function implements slightly different (rs6000-specific) semantics
+	than store_data_bypass_p, returning false rather than aborting
+	with assertion error when arguments do not satisfy the
+	requirements of store data bypass.
+	(rs6000_adjust_cost): Replace six calls of store_data_bypass_p with
+	rs6000_store_data_bypass_p.
+
+2017-07-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2017-07-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81375
+	* config/i386/i386.md (divsf3): Add TARGET_SSE to TARGET_SSE_MATH.
+	(rcpps): Ditto.
+	(*rsqrtsf2_sse): Ditto.
+	(rsqrtsf2): Ditto.
+	(div<mode>3): Macroize insn from divdf3 and divsf3
+	using MODEF mode iterator.
+
+	Backport from mainline
+	2017-07-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81300
+	* config/i386/i386.md (setcc + movzbl/and to xor + setcc peepholes):
+	Require dead FLAGS_REG at the beginning of a peephole.
+
+2017-07-13  Tom de Vries  <tom@codesourcery.com>
+
+	backport from mainline:
+	PR tree-optimization/81192
+	2017-07-03  Tom de Vries  <tom@codesourcery.com>
+
+	* tree-ssa-tail-merge.c (same_succ_flush_bb): Handle
+	BB_SAME_SUCC (bb) == NULL.
+
+2017-07-06  Andrew Pinski  <apinski@cavium.com>
+
+	* config/aarch64/aarch64.c (aarch64_load_symref_appropriately):
+	Access the lower part of RTX appropriately.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
@@ -83,7 +616,7 @@
 	Backport from mainline
 	2017-05-04  Prakhar Bahuguna  <prakhar.bahuguna@arm.com>
 
-	* gcc/config/arm/arm-builtins.c (arm_init_builtins): Rename
+	* config/arm/arm-builtins.c (arm_init_builtins): Rename
 	__builtin_arm_ldfscr to __builtin_arm_get_fpscr, and rename
 	__builtin_arm_stfscr to __builtin_arm_set_fpscr.
 
@@ -417,7 +950,7 @@
 
 	PR target/80968
 	* config/sparc/sparc.c (sparc_flat_expand_epilogue): Don't
-        emit frame blockage here.
+	emit frame blockage here.
 	(sparc_expand_epilogue): Do it here.
 	* config/sparc/sparc.md (return expander): Emit frame blockage
 	for alloca here too.
@@ -4231,6 +4764,24 @@
 	* gimple-fold.c (fold_builtin_memory_op): Use
 	get_addr_base_and_unit_offset instead of get_ref_base_and_extent.
 
+2017-07-19  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2017-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/81193
+	* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): If GLIBC
+	provides the hardware capability bits, define the macro
+	__BUILTIN_CPU_SUPPORTS__.
+	* config/rs6000/rs6000.c (cpu_expand_builtin): Generate a warning
+	if GLIBC does not provide the hardware capability bits.  Add a
+	gcc_unreachable call if the built-in cpu function is neither
+	__builtin_cpu_is nor __builtin_cpu_supports.
+	* doc/extend.texi (PowerPC built-in functions): Document that
+	GLIBC 2.23 or newer is needed by __builtin_cpu_is and
+	__builtin_cpu_supports.  Document the macros defined by GCC if the
+	newer GLIBC is available.
+
 2016-07-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
 
 	Back port from mainline
Index: gcc/testsuite/gcc.target/powerpc/pr80103-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr80103-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr80103-1.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mpower9-dform-vector -mno-direct-move" } */
+/* { dg-excess-errors "expect error due to conflicting target options" } */
+/* Since the error message is not associated with a particular line
+   number, we cannot use the dg-error directive and cannot specify a
+   regexp to describe the expected error message.  The expected error
+   message is: "-mpower9-dform, -mpower9-dform-vector,
+                -mpower9-dform-scalar require -mdirect-move" */
+
+int a;
+void b (__attribute__ ((__vector_size__ (16))) char c)
+{
+  a = ((__attribute__ ((__vector_size__ (2 * sizeof (long)))) long) c)[0];
+}
Index: gcc/testsuite/gcc.target/powerpc/pr81833-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr81833-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr81833-1.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,59 @@
+/* PR81833: This used to fail due to improper implementation of vec_msum.  */
+/* Test case relies on -mcpu=power7 or later.  Currently we don't have
+   machinery to express that, so we have two separate tests for -mcpu=power7
+   and -mcpu=power8 to catch 32-bit BE on P7 and 64-bit BE/LE on P8.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target p8vector_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2" } */
+
+#include <altivec.h>
+
+#define vec_u8  vector unsigned char
+#define vec_s8  vector signed char
+#define vec_u16 vector unsigned short
+#define vec_s16 vector signed short
+#define vec_u32 vector unsigned int
+#define vec_s32 vector signed int
+#define vec_f   vector float
+
+#define LOAD_ZERO const vec_u8 zerov = vec_splat_u8 (0)
+
+#define zero_u8v  (vec_u8)  zerov
+#define zero_s8v  (vec_s8)  zerov
+#define zero_u16v (vec_u16) zerov
+#define zero_s16v (vec_s16) zerov
+#define zero_u32v (vec_u32) zerov
+#define zero_s32v (vec_s32) zerov
+
+signed int __attribute__((noinline))
+scalarproduct_int16_vsx (const signed short *v1, const signed short *v2,
+			 int order)
+{
+  int i;
+  LOAD_ZERO;
+  register vec_s16 vec1;
+  register vec_s32 res = vec_splat_s32 (0), t;
+  signed int ires;
+
+  for (i = 0; i < order; i += 8) {
+    vec1 = vec_vsx_ld (0, v1);
+    t    = vec_msum (vec1, vec_vsx_ld (0, v2), zero_s32v);
+    res  = vec_sums (t, res);
+    v1  += 8;
+    v2  += 8;
+  }
+  res = vec_splat (res, 3);
+  vec_ste (res, 0, &ires);
+
+  return ires;
+}
+
+int main(void)
+{
+  const signed short test_vec[] = { 1, 1, 1, 1, 1, 1, 1, 1 };
+  if (scalarproduct_int16_vsx (test_vec, test_vec, 8) != 8)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-setup-be-long.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-setup-be-long.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-setup-be-long.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,11 @@
+/* { dg-do run { target { powerpc64le*-*-linux* } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx -maltivec=be" } */
+
+/* Test various ways of creating vectors with 2 double words and accessing the
+   elements.  This test uses the long (on 64-bit systems) or long long datatype
+   (on 32-bit systems).
+
+   This test explicitly tests -maltivec=be to make sure things are correct.  */
+
+#include "vec-setup.h"
Index: gcc/testsuite/gcc.target/powerpc/pr81833-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr81833-2.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr81833-2.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,59 @@
+/* PR81833: This used to fail due to improper implementation of vec_msum.  */
+/* Test case relies on -mcpu=power7 or later.  Currently we don't have
+   machinery to express that, so we have two separate tests for -mcpu=power7
+   and -mcpu=power8 to catch 32-bit BE on P7 and 64-bit BE/LE on P8.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-mcpu=power7 -O2" } */
+
+#include <altivec.h>
+
+#define vec_u8  vector unsigned char
+#define vec_s8  vector signed char
+#define vec_u16 vector unsigned short
+#define vec_s16 vector signed short
+#define vec_u32 vector unsigned int
+#define vec_s32 vector signed int
+#define vec_f   vector float
+
+#define LOAD_ZERO const vec_u8 zerov = vec_splat_u8 (0)
+
+#define zero_u8v  (vec_u8)  zerov
+#define zero_s8v  (vec_s8)  zerov
+#define zero_u16v (vec_u16) zerov
+#define zero_s16v (vec_s16) zerov
+#define zero_u32v (vec_u32) zerov
+#define zero_s32v (vec_s32) zerov
+
+signed int __attribute__((noinline))
+scalarproduct_int16_vsx (const signed short *v1, const signed short *v2,
+			 int order)
+{
+  int i;
+  LOAD_ZERO;
+  register vec_s16 vec1;
+  register vec_s32 res = vec_splat_s32 (0), t;
+  signed int ires;
+
+  for (i = 0; i < order; i += 8) {
+    vec1 = vec_vsx_ld (0, v1);
+    t    = vec_msum (vec1, vec_vsx_ld (0, v2), zero_s32v);
+    res  = vec_sums (t, res);
+    v1  += 8;
+    v2  += 8;
+  }
+  res = vec_splat (res, 3);
+  vec_ste (res, 0, &ires);
+
+  return ires;
+}
+
+int main(void)
+{
+  const signed short test_vec[] = { 1, 1, 1, 1, 1, 1, 1, 1 };
+  if (scalarproduct_int16_vsx (test_vec, test_vec, 8) != 8)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr82112.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr82112.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr82112.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,16 @@
+/* PR target/82112 */
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec -std=gnu90" } */
+
+#include <altivec.h>
+
+struct __attribute__((aligned (16))) S { unsigned char c[64]; } bar (void);
+vector unsigned char v;
+
+void
+foo (void)
+{
+  vec_ld (0, bar ().c);	/* { dg-error "invalid parameter combination for AltiVec intrinsic" } */
+  vec_st (v, 0, bar ().c);	/* { dg-error "invalid parameter combination for AltiVec intrinsic" } */
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-setup.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-setup.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-setup.h	(.../branches/gcc-6-branch)
@@ -0,0 +1,366 @@
+#include <altivec.h>
+
+/* Test various ways of creating vectors with 2 double words and accessing the
+   elements.  This include files supports:
+
+	 testing double
+	 testing long on 64-bit systems
+	 testing long long on 32-bit systems.
+
+   The endian support is:
+
+	big endian
+	little endian with little endian element ordering
+	little endian with big endian element ordering.  */
+
+#ifdef DEBUG
+#include <stdio.h>
+#define DEBUG0(STR)		fputs (STR, stdout)
+#define DEBUG2(STR,A,B)		printf (STR, A, B)
+
+static int errors = 0;
+
+#else
+#include <stdlib.h>
+#define DEBUG0(STR)
+#define DEBUG2(STR,A,B)
+#endif
+
+#if defined(DO_DOUBLE)
+#define TYPE	double
+#define STYPE	"double"
+#define ZERO	0.0
+#define ONE	1.0
+#define TWO	2.0
+#define THREE	3.0
+#define FOUR	4.0
+#define FIVE	5.0
+#define SIX	6.0
+#define FMT	"g"
+
+#elif defined(_ARCH_PPC64)
+#define TYPE	long
+#define STYPE	"long"
+#define ZERO	0L
+#define ONE	1L
+#define TWO	2L
+#define THREE	3L
+#define FOUR	4L
+#define FIVE	5L
+#define SIX	6L
+#define FMT	"ld"
+
+#else
+#define TYPE	long long
+#define STYPE	"long long"
+#define ZERO	0LL
+#define ONE	1LL
+#define TWO	2LL
+#define THREE	3LL
+#define FOUR	4LL
+#define FIVE	5LL
+#define SIX	6LL
+#define FMT	"lld"
+#endif
+
+/* Macros to order the left/right values correctly.  Note, -maltivec=be does
+   not change the order for static initializations, so we have to handle it
+   specially.  */
+
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+#define INIT_ORDER(A, B)	(TYPE) A, (TYPE) B
+#define ELEMENT_ORDER(A, B)	(TYPE) A, (TYPE) B
+#define ENDIAN			"-mbig"
+
+#elif __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__
+#define NO_ARRAY
+#define INIT_ORDER(A, B)	(TYPE) B, (TYPE) A
+#define ELEMENT_ORDER(A, B)	(TYPE) A, (TYPE) B
+#define ENDIAN			"-mlittle -maltivec=be"
+
+#else
+#define INIT_ORDER(A, B)	(TYPE) B, (TYPE) A
+#define ELEMENT_ORDER(A, B)	(TYPE) B, (TYPE) A
+#define ENDIAN			"-mlittle"
+#endif
+
+static volatile TYPE		five	= FIVE;
+static volatile TYPE		six	= SIX;
+static volatile vector TYPE	s_v12 = { ONE,   TWO };
+static volatile vector TYPE	g_v34 = { THREE, FOUR };
+
+
+__attribute__((__noinline__))
+static void
+vector_check (vector TYPE v, TYPE expect_hi, TYPE expect_lo)
+{
+  TYPE actual_hi, actual_lo;
+#ifdef DEBUG
+  const char *pass_fail;
+#endif
+
+  __asm__ ("xxlor %x0,%x1,%x1"		: "=&wa" (actual_hi) : "wa" (v));
+  __asm__ ("xxpermdi %x0,%x1,%x1,3"	: "=&wa" (actual_lo) : "wa" (v));
+
+#ifdef DEBUG
+  if ((actual_hi == expect_hi) && (actual_lo == expect_lo))
+    pass_fail = ", pass";
+  else
+    {
+      pass_fail = ", fail";
+      errors++;
+    }
+
+  printf ("Expected %" FMT ", %" FMT ", got %" FMT ", %" FMT "%s\n",
+	  expect_hi, expect_lo,
+	  actual_hi, actual_lo,
+	  pass_fail);
+#else
+  if ((actual_hi != expect_hi) || (actual_lo != expect_lo))
+    abort ();
+#endif
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+combine (TYPE op0, TYPE op1)
+{
+  return (vector TYPE) { op0, op1 };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+combine_insert (TYPE op0, TYPE op1)
+{
+  vector TYPE ret = (vector TYPE) { ZERO, ZERO };
+  ret = vec_insert (op0, ret, 0);
+  ret = vec_insert (op1, ret, 1);
+  return ret;
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract_00 (vector TYPE a, vector TYPE b)
+{
+  return (vector TYPE) { vec_extract (a, 0), vec_extract (b, 0) };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract_01 (vector TYPE a, vector TYPE b)
+{
+  return (vector TYPE) { vec_extract (a, 0), vec_extract (b, 1) };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract_10 (vector TYPE a, vector TYPE b)
+{
+  return (vector TYPE) { vec_extract (a, 1), vec_extract (b, 0) };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract_11 (vector TYPE a, vector TYPE b)
+{
+  return (vector TYPE) { vec_extract (a, 1), vec_extract (b, 1) };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract2_0s (vector TYPE a, TYPE b)
+{
+  return (vector TYPE) { vec_extract (a, 0), b };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract2_1s (vector TYPE a, TYPE b)
+{
+  return (vector TYPE) { vec_extract (a, 1), b };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract2_s0 (TYPE a, vector TYPE b)
+{
+  return (vector TYPE) { a, vec_extract (b, 0) };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract2_s1 (TYPE a, vector TYPE b)
+{
+  return (vector TYPE) { a, vec_extract (b, 1) };
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+concat_extract_nn (vector TYPE a, vector TYPE b, size_t i, size_t j)
+{
+  return (vector TYPE) { vec_extract (a, i), vec_extract (b, j) };
+}
+
+#ifndef NO_ARRAY
+__attribute__((__noinline__))
+static vector TYPE
+array_0 (vector TYPE v, TYPE a)
+{
+  v[0] = a;
+  return v;
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+array_1 (vector TYPE v, TYPE a)
+{
+  v[1] = a;
+  return v;
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+array_01 (vector TYPE v, TYPE a, TYPE b)
+{
+  v[0] = a;
+  v[1] = b;
+  return v;
+}
+
+__attribute__((__noinline__))
+static vector TYPE
+array_01b (TYPE a, TYPE b)
+{
+  vector TYPE v = (vector TYPE) { 0, 0 };
+  v[0] = a;
+  v[1] = b;
+  return v;
+}
+#endif
+
+int
+main (void)
+{
+  vector TYPE a = (vector TYPE) { ONE,   TWO  };
+  vector TYPE b = (vector TYPE) { THREE, FOUR };
+  size_t i, j;
+
+#ifndef NO_ARRAY
+  vector TYPE z = (vector TYPE) { ZERO,  ZERO };
+#endif
+
+  DEBUG2 ("Endian: %s, type: %s\n", ENDIAN, STYPE);
+  DEBUG0 ("\nStatic/global initialization\n");
+  vector_check (s_v12, INIT_ORDER (1, 2));
+  vector_check (g_v34, INIT_ORDER (3, 4));
+
+  DEBUG0 ("\nVector via constant runtime intiialization\n");
+  vector_check (a, INIT_ORDER (1, 2));
+  vector_check (b, INIT_ORDER (3, 4));
+
+  DEBUG0 ("\nCombine scalars using vector initialization\n");
+  vector_check (combine (1, 2), INIT_ORDER (1, 2));
+  vector_check (combine (3, 4), INIT_ORDER (3, 4));
+
+  DEBUG0 ("\nSetup with vec_insert\n");
+  a = combine_insert (1, 2);
+  b = combine_insert (3, 4);
+  vector_check (a, ELEMENT_ORDER (1, 2));
+  vector_check (b, ELEMENT_ORDER (3, 4));
+
+#ifndef NO_ARRAY
+  DEBUG0 ("\nTesting array syntax\n");
+  vector_check (array_0   (a, FIVE),      ELEMENT_ORDER (5, 2));
+  vector_check (array_1   (b, SIX),       ELEMENT_ORDER (3, 6));
+  vector_check (array_01  (z, FIVE, SIX), ELEMENT_ORDER (5, 6));
+  vector_check (array_01b (FIVE, SIX),    ELEMENT_ORDER (5, 6));
+
+  vector_check (array_0   (a, five),      ELEMENT_ORDER (5, 2));
+  vector_check (array_1   (b, six),       ELEMENT_ORDER (3, 6));
+  vector_check (array_01  (z, five, six), ELEMENT_ORDER (5, 6));
+  vector_check (array_01b (five, six),    ELEMENT_ORDER (5, 6));
+#else
+  DEBUG0 ("\nSkipping array syntax on -maltivec=be\n");
+#endif
+
+  DEBUG0 ("\nTesting concat and extract\n");
+  vector_check (concat_extract_00 (a, b), INIT_ORDER (1, 3));
+  vector_check (concat_extract_01 (a, b), INIT_ORDER (1, 4));
+  vector_check (concat_extract_10 (a, b), INIT_ORDER (2, 3));
+  vector_check (concat_extract_11 (a, b), INIT_ORDER (2, 4));
+
+  DEBUG0 ("\nTesting concat and extract #2\n");
+  vector_check (concat_extract2_0s (a, FIVE), INIT_ORDER (1, 5));
+  vector_check (concat_extract2_1s (a, FIVE), INIT_ORDER (2, 5));
+  vector_check (concat_extract2_s0 (SIX, a),  INIT_ORDER (6, 1));
+  vector_check (concat_extract2_s1 (SIX, a),  INIT_ORDER (6, 2));
+
+  DEBUG0 ("\nTesting variable concat and extract\n");
+  for (i = 0; i < 2; i++)
+    {
+      for (j = 0; j < 2; j++)
+	{
+	  static struct {
+	    TYPE hi;
+	    TYPE lo;
+	  } hilo[2][2] =
+	      { { { ONE, THREE }, { ONE, FOUR } },
+		{ { TWO, THREE }, { TWO, FOUR } } };
+
+	  vector_check (concat_extract_nn (a, b, i, j),
+			INIT_ORDER (hilo[i][j].hi, hilo[i][j].lo));
+	}
+    }
+
+  DEBUG0 ("\nTesting separate function\n");
+  vector_check (combine (vec_extract (a, 0), vec_extract (b, 0)),
+		INIT_ORDER (1, 3));
+
+  vector_check (combine (vec_extract (a, 0), vec_extract (b, 1)),
+		INIT_ORDER (1, 4));
+
+  vector_check (combine (vec_extract (a, 1), vec_extract (b, 0)),
+		INIT_ORDER (2, 3));
+
+  vector_check (combine (vec_extract (a, 1), vec_extract (b, 1)),
+		INIT_ORDER (2, 4));
+
+  vector_check (combine_insert (vec_extract (a, 0), vec_extract (b, 0)),
+		ELEMENT_ORDER (1, 3));
+
+  vector_check (combine_insert (vec_extract (a, 0), vec_extract (b, 1)),
+		ELEMENT_ORDER (1, 4));
+
+  vector_check (combine_insert (vec_extract (a, 1), vec_extract (b, 0)),
+		ELEMENT_ORDER (2, 3));
+
+  vector_check (combine_insert (vec_extract (a, 1), vec_extract (b, 1)),
+		ELEMENT_ORDER (2, 4));
+
+
+#if defined(DO_DOUBLE)
+  DEBUG0 ("\nTesting explicit 2df concat\n");
+  vector_check (__builtin_vsx_concat_2df (FIVE, SIX), INIT_ORDER (5, 6));
+  vector_check (__builtin_vsx_concat_2df (five, six), INIT_ORDER (5, 6));
+
+#elif defined(_ARCH_PPC64)
+  DEBUG0 ("\nTesting explicit 2di concat\n");
+  vector_check (__builtin_vsx_concat_2di (FIVE, SIX), INIT_ORDER (5, 6));
+  vector_check (__builtin_vsx_concat_2di (five, six), INIT_ORDER (5, 6));
+
+#else
+  DEBUG0 ("\nSkip explicit 2di concat on 32-bit\n");
+#endif
+
+#ifdef DEBUG
+  if (errors)
+    printf ("\n%d error%s were found", errors, (errors == 1) ? "" : "s");
+  else
+    printf ("\nNo errors were found.\n");
+
+  return errors;
+
+#else
+  return 0;
+#endif
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-setup-be-double.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-setup-be-double.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-setup-be-double.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,12 @@
+/* { dg-do run { target { powerpc*-*-linux* } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+/* Test various ways of creating vectors with 2 double words and accessing the
+   elements.  This test uses the double datatype.
+
+   This test explicitly tests -maltivec=be to make sure things are correct.  */
+
+#define DO_DOUBLE
+
+#include "vec-setup.h"
Index: gcc/testsuite/gcc.target/powerpc/cpu-builtin-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/cpu-builtin-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/cpu-builtin-1.c	(.../branches/gcc-6-branch)
@@ -4,6 +4,11 @@
 void
 use_cpu_is_builtins (unsigned int *p)
 {
+  /* If GCC was configured to use an old GLIBC (before 2.23), the
+     __builtin_cpu_is and __builtin_cpu_supports built-in functions return 0,
+     and the compiler issues a warning that you need a newer glibc to use them.
+     Use #ifdef to avoid the warning.  */
+#ifdef __BUILTIN_CPU_SUPPORTS__
   p[0] = __builtin_cpu_is ("power9");
   p[1] = __builtin_cpu_is ("power8");
   p[2] = __builtin_cpu_is ("power7");
@@ -19,11 +24,15 @@
   p[12] = __builtin_cpu_is ("ppc440");
   p[13] = __builtin_cpu_is ("ppc405");
   p[14] = __builtin_cpu_is ("ppc-cell-be");
+#else
+  p[0] = 0;
+#endif
 }
 
 void
 use_cpu_supports_builtins (unsigned int *p)
 {
+#ifdef __BUILTIN_CPU_SUPPORTS__
   p[0] = __builtin_cpu_supports ("4xxmac");
   p[1] = __builtin_cpu_supports ("altivec");
   p[2] = __builtin_cpu_supports ("arch_2_05");
@@ -62,4 +71,9 @@
   p[35] = __builtin_cpu_supports ("ucache");
   p[36] = __builtin_cpu_supports ("vcrypto");
   p[37] = __builtin_cpu_supports ("vsx");
+  p[38] = __builtin_cpu_supports ("darn");
+  p[39] = __builtin_cpu_supports ("scv");
+#else
+  p[0] = 0;
+#endif
 }
Index: gcc/testsuite/gcc.target/powerpc/vsx-extract-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-extract-6.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-extract-6.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,25 @@
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O2 -mvsx" } */
+
+vector unsigned long
+test_vpasted (vector unsigned long high, vector unsigned long low)
+{
+  vector unsigned long res;
+  res[1] = high[1];
+  res[0] = low[0];
+  return res;
+}
+
+/* { dg-final { scan-assembler-times {\mxxpermdi\M} 1    } } */
+/* { dg-final { scan-assembler-not   {\mvspltisw\M}      } } */
+/* { dg-final { scan-assembler-not   {\mxxlor\M}         } } */
+/* { dg-final { scan-assembler-not   {\mxxlxor\M}        } } */
+/* { dg-final { scan-assembler-not   {\mxxspltib\M}      } } */
+/* { dg-final { scan-assembler-not   {\mlxvx?\M}         } } */
+/* { dg-final { scan-assembler-not   {\mlxv[dw][24]x\M}  } } */
+/* { dg-final { scan-assembler-not   {\mlvx\M}           } } */
+/* { dg-final { scan-assembler-not   {\mstxvx?\M}        } } */
+/* { dg-final { scan-assembler-not   {\mstxv[dw][24]x\M} } } */
+/* { dg-final { scan-assembler-not   {\mstvx\M}          } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-extract-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-extract-7.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-extract-7.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,25 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O2 -mvsx" } */
+
+vector double
+test_vpasted (vector double high, vector double low)
+{
+  vector double res;
+  res[1] = high[1];
+  res[0] = low[0];
+  return res;
+}
+
+/* { dg-final { scan-assembler-times {\mxxpermdi\M} 1    } } */
+/* { dg-final { scan-assembler-not   {\mvspltisw\M}      } } */
+/* { dg-final { scan-assembler-not   {\mxxlor\M}         } } */
+/* { dg-final { scan-assembler-not   {\mxxlxor\M}        } } */
+/* { dg-final { scan-assembler-not   {\mxxspltib\M}      } } */
+/* { dg-final { scan-assembler-not   {\mlxvx?\M}         } } */
+/* { dg-final { scan-assembler-not   {\mlxv[dw][24]x\M}  } } */
+/* { dg-final { scan-assembler-not   {\mlvx\M}           } } */
+/* { dg-final { scan-assembler-not   {\mstxvx?\M}        } } */
+/* { dg-final { scan-assembler-not   {\mstxv[dw][24]x\M} } } */
+/* { dg-final { scan-assembler-not   {\mstvx\M}          } } */
Index: gcc/testsuite/gcc.target/powerpc/pr80101-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr80101-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr80101-1.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power6" } } */
+/* { dg-require-effective-target dfp_hw } */
+/* { dg-options "-mcpu=power6 -mno-sched-epilog -Ofast" } */
+
+/* Prior to resolving PR 80101, this test case resulted in an internal
+   compiler error.  The role of this test program is to assure that
+   dejagnu's "test for excess errors" does not find any.  */
+
+int b;
+
+void e ();
+
+int c ()
+{
+  struct
+  {
+    int a[b];
+  } d;
+  if (d.a[0])
+    e ();
+}
Index: gcc/testsuite/gcc.target/powerpc/p9-options-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/p9-options-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/p9-options-1.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,28 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -mno-power9-vector" } */
+
+#include <altivec.h>
+
+/* This program's "test for excess errors" demonstrates that combining
+   the target options -mcpu=power9 and -mno-power9-vector does not
+   result in an error.  A previous version of the compiler aborted
+   with the error message:
+
+      "power9-dform requires power9-vector."
+
+   when these two options were used in combination.
+
+   The newer version of the compiler, instead, automatically disables
+   power9-dform when the -mno-power9-vector command-line option is
+   specified.  */
+int
+test_any_equal (vector bool char *arg1_p, vector bool char *arg2_p)
+{
+  vector bool char arg_1 = *arg1_p;
+  vector bool char arg_2 = *arg2_p;
+
+  return vec_any_eq (arg_1, arg_2);
+}
+
Index: gcc/testsuite/gcc.target/powerpc/pr80210.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr80210.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr80210.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,10 @@
+/* Test for ICE arising from GCC target pragma.  */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+double
+foo (double a)
+{
+  return __builtin_sqrt (a);
+}
+#pragma GCC target "no-powerpc-gpopt"
Index: gcc/testsuite/gcc.target/powerpc/vec-setup-double.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-setup-double.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-setup-double.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,11 @@
+/* { dg-do run { target { powerpc*-*-linux* } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+/* Test various ways of creating vectors with 2 double words and accessing the
+   elements.  This test uses the double datatype and the default endian
+   order.  */
+
+#define DO_DOUBLE
+
+#include "vec-setup.h"
Index: gcc/testsuite/gcc.target/powerpc/vec-setup-long.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-setup-long.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-setup-long.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,9 @@
+/* { dg-do run { target { powerpc*-*-linux* } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+/* Test various ways of creating vectors with 2 double words and accessing the
+   elements.  This test uses the long (on 64-bit systems) or long long datatype
+   (on 32-bit systems).  The default endian order is used.  */
+
+#include "vec-setup.h"
Index: gcc/testsuite/gcc.target/avr/isr-test.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/isr-test.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/avr/isr-test.h	(.../branches/gcc-6-branch)
@@ -0,0 +1,282 @@
+#ifndef ISR_TEST_H
+#define ISR_TEST_H
+
+#include <string.h>
+
+#define ISR(N,...)                                                      \
+__attribute__ ((used, externally_visible , ## __VA_ARGS__))             \
+    void __vector_##N (void);                                           \
+    void __vector_##N (void)
+
+#define SFR(ADDR) (*(unsigned char volatile*) (__AVR_SFR_OFFSET__ + (ADDR)))
+#define CORE_SFRS SFR (0x38)
+#define SREG      SFR (0x3F)
+#define SPL       SFR (0x3D)
+#define EIND      SFR (0x3C)
+#define RAMPZ     SFR (0x3B)
+#define RAMPY     SFR (0x3A)
+#define RAMPX     SFR (0x39)
+#define RAMPD     SFR (0x38)
+
+#ifdef __AVR_HAVE_JMP_CALL__
+#define VEC_SIZE 4
+#else
+#define VEC_SIZE 2
+#endif
+
+#ifdef __AVR_TINY__
+#define FIRST_REG 16
+#else
+#define FIRST_REG 0
+#endif
+
+#define CR "\n\t"
+
+typedef struct
+{
+  unsigned char sfrs[8];
+  unsigned char gprs[32 - FIRST_REG];
+} regs_t;
+
+regs_t reginfo1, reginfo2;
+
+__attribute__((noinline))
+static void clear_reginfo (void)
+{
+  memset (reginfo1.sfrs, 0, sizeof (reginfo1.sfrs));
+  memset (reginfo2.sfrs, 0, sizeof (reginfo2.sfrs));
+}
+
+__attribute__((noinline))
+static void compare_reginfo (unsigned long gpr_ignore)
+{
+  signed char regno;
+  const unsigned char *preg1 = &reginfo1.gprs[0];
+  const unsigned char *preg2 = &reginfo2.gprs[0];
+
+  if (memcmp (&reginfo1, &reginfo2, 8))
+    __builtin_abort();
+
+  gpr_ignore >>= FIRST_REG;
+
+    for (regno = FIRST_REG; regno < 32;
+       regno++, preg1++, preg2++, gpr_ignore >>= 1)
+    {
+      if (gpr_ignore & 1)
+        continue;
+
+      if (*preg1 != *preg2)
+        {
+          static signed char volatile failed_regno;
+          failed_regno = regno;
+          __builtin_abort();
+        }
+    }
+}
+
+/* STore GPR */
+#define ST(regno,M)                                     \
+  CR "sts %[" #M "]+8-%[first]+" #regno ", r" #regno
+
+/* STore SFR */
+#define ST_SFR(sfr, n_sfr, M)                   \
+  CR "in __tmp_reg__,%i[s_" #sfr "]"            \
+  CR "sts %[" #M "]+" #n_sfr ", __tmp_reg__"
+
+/* Named asm OPerand for SFR */
+#define OP_SFR(sfr)                             \
+  , [s_ ## sfr] "n" (&(sfr))
+
+/* Write funny value to SFR */
+#define XX_SFR(sfr)                             \
+  CR "dec r31 $ out %i[s_" #sfr "], r31"
+
+/* Write 0 to SFR */
+#define OO_SFR(sfr)                             \
+  CR "out %i[s_" #sfr "], __zero_reg__"
+
+/* Macros for SREG */
+#define ST_SREG(M) ST_SFR (SREG,0,M)
+#define OP_SREG    OP_SFR (SREG)
+#define XX_SREG    XX_SFR (SREG)
+
+/* Macros for EIND */
+#if defined __AVR_HAVE_EIJMP_EICALL__
+#define ST_EIND(M) ST_SFR (EIND,1,M)
+#define OP_EIND    OP_SFR (EIND)
+#else
+#define ST_EIND(M) /* empty */
+#define OP_EIND    /* empty */
+#endif
+
+/* Macros for RAMPX */
+#if defined (__AVR_HAVE_RAMPX__)
+#define ST_RAMPX(M) ST_SFR (RAMPX,2,M)
+#define OP_RAMPX    OP_SFR (RAMPX)
+#define XX_RAMPX    XX_SFR (RAMPX)
+#define OO_RAMPX    OO_SFR (RAMPX)
+#else
+#define ST_RAMPX(M) /* empty */
+#define OP_RAMPX    /* empty */
+#define XX_RAMPX    /* empty */
+#define OO_RAMPX    /* empty */
+#endif
+
+/* Macros for RAMPY */
+#if defined (__AVR_HAVE_RAMPY__)
+#define ST_RAMPY(M) ST_SFR (RAMPY,3,M)
+#define OP_RAMPY    OP_SFR (RAMPY)
+#define XX_RAMPY    XX_SFR (RAMPY)
+#define OO_RAMPY    OO_SFR (RAMPY)
+#else
+#define ST_RAMPY(M) /* empty */
+#define OP_RAMPY    /* empty */
+#define XX_RAMPY    /* empty */
+#define OO_RAMPY    /* empty */
+#endif
+
+/* Macros for RAMPZ */
+#if defined (__AVR_HAVE_RAMPZ__)
+#define ST_RAMPZ(M) ST_SFR (RAMPZ,4,M)
+#define OP_RAMPZ    OP_SFR (RAMPZ)
+#define XX_RAMPZ    XX_SFR (RAMPZ)
+#define OO_RAMPZ    OO_SFR (RAMPZ)
+#else
+#define ST_RAMPZ(M) /* empty */
+#define OP_RAMPZ    /* empty */
+#define XX_RAMPZ    /* empty */
+#define OO_RAMPZ    /* empty */
+#endif
+
+/* Macros for RAMPD */
+#if defined (__AVR_HAVE_RAMPD__)
+#define ST_RAMPD(M) ST_SFR (RAMPD,5,M)
+#define OP_RAMPD    OP_SFR (RAMPD)
+#else
+#define ST_RAMPD(M) /* empty */
+#define OP_RAMPD    /* empty */
+#endif
+
+/* Macros for all GPRs */
+#if defined __AVR_TINY__
+#define ST_REGS_LO(M) /* empty */
+#else
+#define ST_REGS_LO(M)                           \
+  ST(0,M)   ST(1,M)   ST(2,M)   ST(3,M)         \
+  ST(4,M)   ST(5,M)   ST(6,M)   ST(7,M)         \
+  ST(8,M)   ST(9,M)   ST(10,M)  ST(11,M)        \
+  ST(12,M)  ST(13,M)  ST(14,M)  ST(15,M)
+#endif /* AVR_TINY */
+
+#define ST_REGS_HI(M)                           \
+  ST(16,M)    ST(17,M)    ST(18,M)    ST(19,M)  \
+  ST(20,M)    ST(21,M)    ST(22,M)    ST(23,M)  \
+  ST(24,M)    ST(25,M)    ST(26,M)    ST(27,M)  \
+  ST(28,M)    ST(29,M)    ST(30,M)    ST(31,M)
+
+__attribute__((unused,naked,noinline,noclone))
+static void host_store1 (void)
+{
+  __asm __volatile__
+  ("nop"
+   CR ".global do_stores_before"
+   CR ".type   do_stores_before,@function"
+   CR "do_stores_before:"
+   /* Funny values to some SFRs */
+   CR "ldi r31, 1 + 'Z'"
+   XX_RAMPZ
+   XX_RAMPY
+   XX_RAMPX
+   CR "dec __zero_reg__"
+   CR "clr r31"
+   XX_SREG
+   /* Must set I-flag due to RETI of ISR */
+   CR "sei"
+   /* Store core regs before ISR */
+   ST_RAMPX (mem1)
+   ST_RAMPY (mem1)
+   ST_RAMPZ (mem1)
+   ST_RAMPD (mem1)
+   ST_EIND  (mem1)
+   ST_SREG  (mem1)
+   CR "ldi r31, 0xaa"
+   CR "mov __tmp_reg__, r31"
+   CR "ldi r31, 31"
+   ST_REGS_LO (mem1)
+   ST_REGS_HI (mem1)
+   CR "ret"
+   : /* No outputs */
+   : [mem1] "i" (&reginfo1), [first] "n" (FIRST_REG)
+   OP_RAMPX
+   OP_RAMPY
+   OP_RAMPZ
+   OP_RAMPD
+   OP_EIND
+   OP_SREG
+   : "memory", "r31");
+}
+
+__attribute__((unused,naked,noinline,noclone))
+static void host_store2 (void)
+{
+  __asm __volatile__
+  ("nop"
+   CR ".global do_stores_after"
+   CR ".type   do_stores_after,@function"
+   CR "do_stores_after:"
+   /* Store core regs after ISR */
+   ST_REGS_LO (mem2)
+   ST_REGS_HI (mem2)
+   ST_RAMPX (mem2)
+   ST_RAMPY (mem2)
+   ST_RAMPZ (mem2)
+   ST_RAMPD (mem2)
+   ST_EIND  (mem2)
+   ST_SREG  (mem2)
+   /* Undo funny values */
+   CR "clr __zero_reg__"
+   OO_RAMPX
+   OO_RAMPY
+   OO_RAMPZ
+   CR "ret"
+   : /* No outputs */
+   : [mem2] "i" (&reginfo2), [first] "n" (FIRST_REG)
+   OP_RAMPX
+   OP_RAMPY
+   OP_RAMPZ
+   OP_RAMPD
+   OP_EIND
+   OP_SREG
+   : "memory");
+}
+
+#define MK_CALL_ISR(vecno)                      \
+  __asm __volatile__                            \
+  (/* Funny values to some SFRs */              \
+   /* Must set I-flag due to RETI of ISR */     \
+   /* Store core regs before ISR */             \
+   CR "%~call do_stores_before"                 \
+   /* Execute ISR */                            \
+   CR "%~call __vectors + %[vect]"              \
+   /* Store core regs after ISR */              \
+   /* Undo funny values */                      \
+   CR "%~call do_stores_after"                  \
+   : /* No outputs */                           \
+   : [vect] "i" (VEC_SIZE * (vecno))            \
+   , "i" (host_store1)                          \
+   , "i" (host_store2)                          \
+   : "memory", "r31")
+
+
+#define MK_RUN_ISR(N, IGMSK)                    \
+                                                \
+__attribute__((noinline,noclone))               \
+void run_isr_ ## N (void)                       \
+{                                               \
+  clear_reginfo();                              \
+  MK_CALL_ISR (N);                              \
+  compare_reginfo (IGMSK);                      \
+}
+
+#endif /* ISR_TEST_H */
+
Index: gcc/testsuite/gcc.target/avr/torture/isr-01-simple.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/torture/isr-01-simple.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/avr/torture/isr-01-simple.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,98 @@
+/* { dg-do run } */
+/* { dg-options "-std=c99" } */
+
+#include "../isr-test.h"
+
+int volatile v;
+
+/**********************************************************************/
+
+ISR (1, signal)
+{
+}
+
+MK_RUN_ISR (1, 0)
+
+void test1 (void)
+{
+  run_isr_1();
+}
+
+/**********************************************************************/
+
+ISR (2, signal)
+{
+  v++;
+}
+
+MK_RUN_ISR (2, 0)
+
+void test2 (void)
+{
+  v = 0;
+  run_isr_2();
+  if (v != 1)
+    __builtin_abort();
+}
+
+
+/**********************************************************************/
+
+ISR (3, signal)
+{
+  __asm __volatile__ ("$ lds  r27, v"
+                      "$ swap r27"
+                      "$ sts  v, r27"
+                      ::: "memory", "r27");
+}
+
+MK_RUN_ISR (3, 0)
+
+void test3 (void)
+{
+  run_isr_3();
+  if (v != 0x10)
+    __builtin_abort();
+}
+
+/**********************************************************************/
+
+ISR (4, signal)
+{
+  __asm __volatile__ ("sts v,__zero_reg__" ::: "memory");
+}
+
+MK_RUN_ISR (4, 0)
+
+void test4 (void)
+{
+  run_isr_4();
+  if (v != 0)
+    __builtin_abort();
+}
+
+/**********************************************************************/
+
+ISR (5, signal)
+{
+  __asm __volatile__ ("clt");
+}
+
+MK_RUN_ISR (5, 0)
+
+void test5 (void)
+{
+  run_isr_5();
+}
+
+/**********************************************************************/
+
+int main (void)
+{
+  test1();
+  test2();
+  test3();
+  test4();
+  test5();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/avr/torture/isr-02-call.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/torture/isr-02-call.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/avr/torture/isr-02-call.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,60 @@
+/* { dg-do run } */
+/* { dg-options "-std=c99" } */
+
+#include "../isr-test.h"
+
+int volatile v;
+
+__attribute__((noinline,noclone))
+void inc_v (void)
+{
+  v++;
+}
+
+/**********************************************************************/
+
+ISR (1, signal)
+{
+  inc_v();
+}
+
+MK_RUN_ISR (1, 0)
+
+void test1 (void)
+{
+  run_isr_1();
+  if (v != 1)
+    __builtin_abort();
+}
+
+/**********************************************************************/
+
+ISR (2, signal)
+{
+  if (v == 1)
+    inc_v();
+  else
+    v += 2;
+}
+
+MK_RUN_ISR (2, 0)
+
+void test2 (void)
+{
+  run_isr_2();
+  if (v != 2)
+    __builtin_abort();
+  run_isr_2();
+  if (v != 4)
+    __builtin_abort();
+}
+
+
+/**********************************************************************/
+
+int main (void)
+{
+  test1();
+  test2();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/avr/torture/isr-03-fixed.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/torture/isr-03-fixed.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/avr/torture/isr-03-fixed.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,146 @@
+/* { dg-do run } */
+/* { dg-options "-std=gnu99 -fno-lto -fno-toplevel-reorder" } */
+
+// No LTO for now due to PR lto/68384.
+
+#ifdef __AVR_TINY__
+unsigned char reg2;
+#else
+register unsigned char reg2 __asm("r2");
+#endif
+
+#include "../isr-test.h"
+
+#define SET_REG(reg,val)                        \
+  do {                                          \
+    reg = (val);                                \
+    __asm __volatile__("" : "+r" (reg));        \
+  } while (0)                                   \
+
+#define GET_REG(reg)                            \
+  ({                                            \
+    __asm __volatile__("" : "+r" (reg));        \
+    reg;                                        \
+  })
+
+/**********************************************************************/
+
+ISR (1, signal)
+{
+  reg2++;
+}
+
+MK_RUN_ISR (1, 1ul << 2)
+
+void test1 (void)
+{
+  SET_REG (reg2, 0);
+  run_isr_1();
+  if (GET_REG (reg2) != 1)
+    __builtin_abort();
+}
+
+/**********************************************************************/
+
+__attribute__((noinline,noclone))
+void inc_r2 (void)
+{
+  reg2++;
+}
+
+ISR (2, signal)
+{
+  inc_r2 ();
+}
+
+MK_RUN_ISR (2, 1ul << 2)
+
+void test2 (void)
+{
+  run_isr_2();
+  if (GET_REG (reg2) != 2)
+    __builtin_abort();
+}
+
+
+/**********************************************************************/
+
+ISR (3, signal)
+{
+#ifndef __AVR_TINY__
+  register char r4 __asm ("r4");
+  __asm __volatile ("inc %0" : "+r" (r4));
+  __asm __volatile ("inc r5" ::: "r5");
+#endif
+}
+
+MK_RUN_ISR (3, 0)
+
+void test3 (void)
+{
+  run_isr_3();
+}
+
+
+/**********************************************************************/
+
+#define CLOBB(reg)                                 \
+  do {                                             \
+    __asm __volatile__ ("inc " #reg ::: #reg);     \
+  } while (0)
+
+ISR (4, signal)
+{
+  char volatile v;
+  v = 1;
+
+#ifndef __AVR_TINY__
+  CLOBB (r3);
+  CLOBB (r4);
+  CLOBB (r5);
+  CLOBB (r6);
+  CLOBB (r7);
+  CLOBB (r8);
+  CLOBB (r9);
+  CLOBB (r10);
+  CLOBB (r11);
+  CLOBB (r12);
+  CLOBB (r13);
+  CLOBB (r14);
+  CLOBB (r15);
+  CLOBB (r16);
+  CLOBB (r17);
+#endif
+
+  CLOBB (r18);
+  CLOBB (r19);
+  CLOBB (r20);
+  CLOBB (r21);
+  CLOBB (r22);
+  CLOBB (r23);
+  CLOBB (r24);
+  CLOBB (r25);
+  CLOBB (r26);
+  CLOBB (r27);
+  CLOBB (r30);
+  CLOBB (r31);
+}
+
+MK_RUN_ISR (4, 0)
+
+void test4 (void)
+{
+  run_isr_4();
+}
+
+
+/**********************************************************************/
+
+int main (void)
+{
+  test1();
+  test2();
+  test3();
+  test4();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/aarch64/pr71112.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr71112.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr71112.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,10 @@
+/* PR target/71112.  */
+/* { dg-additional-options "-fpie" { target pie } } */
+
+extern int dbs[100];
+void f (int *);
+int nscd_init (void)
+{
+  f (dbs);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/aarch64/pr81414.C
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr81414.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr81414.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mcpu=cortex-a57" } */
+
+typedef __Float32x2_t float32x2_t;
+float32x2_t
+foo1 (float32x2_t __a, float32x2_t __b, float32x2_t __c) {
+  return __b * __c + __a;
+}
+
Index: gcc/testsuite/gcc.target/i386/pr81471.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr81471.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr81471.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,13 @@
+/* PR target/81471 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-O2 -mbmi2" } */
+
+static inline unsigned int rotl (unsigned int x, int k)
+{
+  return (x << k) | (x >> (32 - k));
+}
+
+unsigned long long test (unsigned int z)
+{
+  return rotl (z, 55);
+}
Index: gcc/testsuite/gcc.target/i386/pr81225.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr81225.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr81225.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,14 @@
+/* PR target/81225 */
+/* { dg-do compile } */
+/* { dg-options "-mavx512ifma -O3 -ffloat-store" } */
+
+long a[24];
+float b[4], c[24];
+int d;
+
+void
+foo ()
+{
+  for (d = 0; d < 24; d++)
+    c[d] = (float) d ? : b[a[d]];
+}
Index: gcc/testsuite/gcc.target/i386/pr80569.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr80569.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr80569.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,9 @@
+/* PR target/80569 */
+/* { dg-do assemble } */
+/* { dg-options "-O2 -m16 -march=haswell" } */
+
+void load_kernel(void *setup_addr)
+{
+    unsigned int seg = (unsigned int)setup_addr >> 4;
+    asm("movl %0, %%es" : : "r"(seg));
+}
Index: gcc/testsuite/gcc.target/i386/pr81641.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr81641.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr81641.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,11 @@
+/* PR target/81641 */
+/* { dg-do assemble } */
+/* { dg-options "-O -masm=intel" } */
+/* { dg-require-effective-target masm_intel } */
+
+int test(void)
+{
+  int __seg_fs *f = (int __seg_fs *)16;
+  int __seg_gs *g = (int __seg_gs *)16;
+  return *f + *g;
+}
Index: gcc/testsuite/gcc.target/i386/pr81300.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr81300.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr81300.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,30 @@
+/* PR target/81300 */
+/* { dg-do run { target { ! ia32 } } } */
+/* { dg-options "-O2" } */
+
+int
+__attribute__((noinline, noclone))
+foo (void)
+{
+  unsigned long long _discard = 0, zero = 0, maxull = 0;
+  unsigned char zero1 = __builtin_ia32_addcarryx_u64 (0, 0, 0, &_discard);
+  unsigned char zero2 = __builtin_ia32_addcarryx_u64 (zero1, 0, 0, &zero);
+  __builtin_ia32_sbb_u64 (0x0, 2, -1, &_discard);
+  unsigned char one = __builtin_ia32_sbb_u64 (0, zero, 1, &maxull);
+  unsigned long long x = __builtin_ia32_sbb_u64 (one, zero2, 0, &_discard);
+
+  unsigned long long z1 = 0;
+  __asm__ ("mov{q}\t{%1, %0|%0, %1}" : "+r" (z1) : "r" (x));
+  unsigned long long z2 = 3;
+  __asm__ ("mov{q}\t{%1, %0|%0, %1}" : "+r" (z2) : "r" (x));
+
+  return 1 - (z1 | z2);
+}
+
+int main ()
+{
+  if (foo ())
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr81766.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr81766.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr81766.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,5 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O2 -fPIE -mcmodel=large" } */
+
+int main() { return 0; }
Index: gcc/testsuite/gcc.target/i386/pr81128.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr81128.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr81128.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,65 @@
+/* PR ipa/81128 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+/* { dg-require-ifunc "" } */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+int resolver_fn = 0;
+int resolved_fn = 0;
+
+static inline void
+do_it_right_at_runtime_A ()
+{
+  resolved_fn++;
+}
+
+static inline void
+do_it_right_at_runtime_B ()
+{
+  resolved_fn++;
+}
+
+static inline void do_it_right_at_runtime (void);
+
+void do_it_right_at_runtime (void)
+  __attribute__ ((ifunc ("resolve_do_it_right_at_runtime")));
+
+static void (*resolve_do_it_right_at_runtime (void)) (void)
+{
+  srand (time (NULL));
+  int r = rand ();
+  resolver_fn++;
+
+  /* Use intermediate variable to get a warning for non-matching
+   * prototype. */
+  typeof(do_it_right_at_runtime) *func;
+  if (r & 1)
+    func = do_it_right_at_runtime_A;
+  else
+    func = do_it_right_at_runtime_B;
+
+  return (void *) func;
+}
+
+int
+main (void)
+{
+  const unsigned int ITERS = 10;
+
+  for (int i = ITERS; i > 0; i--)
+    {
+      do_it_right_at_runtime ();
+    }
+
+  if (resolver_fn != 1)
+    __builtin_abort ();
+
+  if (resolved_fn != 10)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-nov.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-nov.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-nov.c	(.../branches/gcc-6-branch)
@@ -25,7 +25,7 @@
 static __attribute__((always_inline)) int
 foo1 (int *p1, ...)
 {
-  return foo2 (10, p1, __va_arg_pack ());
+  return foo2 (10, p1, __builtin_va_arg_pack ());
 }
 
 int prebuf[100];
Index: gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-lbv.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-lbv.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-lbv.c	(.../branches/gcc-6-branch)
@@ -28,7 +28,7 @@
 static __attribute__((always_inline)) int
 foo1 (int *p1, ...)
 {
-  return foo2 (10, p1, __va_arg_pack ());
+  return foo2 (10, p1, __builtin_va_arg_pack ());
 }
 
 int prebuf[100];
Index: gcc/testsuite/gcc.target/i386/mpx/pr79987.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/pr79987.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/pr79987.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,5 @@
+/* { dg-do compile } */
+/* { dg-options "-fcheck-pointer-bounds -mmpx" } */
+
+extern void foo;
+void *bar = &foo; /* { dg-warning "taking address of expression of type .void." } */
Index: gcc/testsuite/gcc.target/i386/mpx/mpx-os-support.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/mpx-os-support.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/mpx-os-support.h	(.../branches/gcc-6-branch)
@@ -0,0 +1,16 @@
+/* Check if the OS supports executing MPX instructions.  */
+
+#define XCR_XFEATURE_ENABLED_MASK	0x0
+
+#define XSTATE_BNDREGS	0x8
+
+static int
+mpx_os_support (void)
+{
+  unsigned int eax, edx;
+  unsigned int ecx = XCR_XFEATURE_ENABLED_MASK;
+
+  __asm__ ("xgetbv" : "=a" (eax), "=d" (edx) : "c" (ecx));
+
+  return (eax & XSTATE_BNDREGS) != 0;
+}
Index: gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-ubv.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-ubv.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-1-ubv.c	(.../branches/gcc-6-branch)
@@ -28,7 +28,7 @@
 static __attribute__((always_inline)) int
 foo1 (int *p1, ...)
 {
-  return foo2 (10, p1, __va_arg_pack ());
+  return foo2 (10, p1, __builtin_va_arg_pack ());
 }
 
 int prebuf[100];
Index: gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-nov.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-nov.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-nov.c	(.../branches/gcc-6-branch)
@@ -27,7 +27,7 @@
 static __attribute__((always_inline)) int
 foo1 (int *p1, ...)
 {
-  return foo2 (10, p1, __va_arg_pack ());
+  return foo2 (10, p1, __builtin_va_arg_pack ());
 }
 
 int prebuf[100];
Index: gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-lbv.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-lbv.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-lbv.c	(.../branches/gcc-6-branch)
@@ -30,7 +30,7 @@
 static __attribute__((always_inline)) int
 foo1 (int *p1, ...)
 {
-  return foo2 (10, p1, __va_arg_pack ());
+  return foo2 (10, p1, __builtin_va_arg_pack ());
 }
 
 int prebuf[100];
Index: gcc/testsuite/gcc.target/i386/mpx/mpx-check.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/mpx-check.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/mpx-check.h	(.../branches/gcc-6-branch)
@@ -1,8 +1,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <assert.h>
-
 #include "cpuid.h"
+#include "mpx-os-support.h"
 
 static int
 __attribute__ ((noinline))
@@ -16,18 +16,25 @@
 
 #define DEBUG
 
+static int
+check_osxsave (void)
+{
+  unsigned int eax, ebx, ecx, edx;
+
+  __cpuid (1, eax, ebx, ecx, edx);
+  return (ecx & bit_OSXSAVE) != 0;
+}
+
 int
 main (int argc, const char **argv)
 {
   unsigned int eax, ebx, ecx, edx;
 
-  if (__get_cpuid_max (0, NULL) < 7)
-    return 0;
+  if (!__get_cpuid_count (7, 0, &eax, &ebx, &ecx, &edx))
+    return NORUNRES;
 
-  __cpuid_count (7, 0, eax, ebx, ecx, edx);
-
   /* Run MPX test only if host has MPX support.  */
-  if (ebx & bit_MPX)
+  if (check_osxsave () && (ebx & bit_MPX) && mpx_os_support ())
     mpx_test (argc, argv);
   else
     {
Index: gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-ubv.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-ubv.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/mpx/va-arg-pack-2-ubv.c	(.../branches/gcc-6-branch)
@@ -30,7 +30,7 @@
 static __attribute__((always_inline)) int
 foo1 (int *p1, ...)
 {
-  return foo2 (10, p1, __va_arg_pack ());
+  return foo2 (10, p1, __builtin_va_arg_pack ());
 }
 
 int prebuf[100];
Index: gcc/testsuite/gcc.target/i386/pr81375.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr81375.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr81375.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,8 @@
+/* PR target/81375 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-mno-80387 -mno-sse -mfpmath=sse" } */
+
+float foo (float a, float b)
+{
+  return a / b;
+}
Index: gcc/testsuite/gfortran.dg/warn_target_lifetime_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_target_lifetime_3.f90	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_target_lifetime_3.f90	(.../branches/gcc-6-branch)
@@ -3,7 +3,7 @@
 !
 ! PR fortran/55476
 !
-! Contribued by  Janus Weil
+! Contributed by Janus Weil
 !
 subroutine test
   integer, pointer :: p
Index: gcc/testsuite/gfortran.dg/warn_target_lifetime_4.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_target_lifetime_4.f90	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_target_lifetime_4.f90	(.../branches/gcc-6-branch)
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! { dg-options "-Wtarget-lifetime" }
+!
+! PR fortran/81770: [5/6/7 Regression] Bogus warning: Pointer in pointer assignment might outlive the pointer target
+!
+! Contributed by Janus Weil <janus@gcc.gnu.org>
+
+module m
+
+   type t
+      integer, allocatable :: l
+   end type
+
+contains
+
+   subroutine sub(c_in, list)
+      type(t), target, intent(in)  :: c_in
+      integer, pointer, intent(out) :: list
+
+      type(t), pointer :: container
+
+      container => c_in
+
+      list => container%l
+
+   end subroutine
+
+end
Index: gcc/testsuite/gcc.c-torture/execute/pr81555.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr81555.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr81555.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,24 @@
+/* PR tree-optimization/81555 */
+
+unsigned int a = 1, d = 0xfaeU, e = 0xe376U;
+_Bool b = 0, f = 1;
+unsigned char g = 1;
+
+void
+foo (void)
+{
+  _Bool c = a != b;
+  if (c)
+    f = 0;
+  if (e & c & (unsigned char)d & c)
+    g = 0;
+}
+
+int
+main ()
+{
+  foo ();
+  if (f || g != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr81503.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr81503.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr81503.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,15 @@
+unsigned short a = 41461;
+unsigned short b = 3419;
+int c = 0;
+
+void foo() {
+  if (a + b * ~(0 != 5))
+    c = -~(b * ~(0 != 5)) + 2147483647;
+}
+
+int main() {
+  foo();
+  if (c != 2147476810)
+    return -1;
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr81556.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr81556.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr81556.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,23 @@
+/* PR tree-optimization/81556 */
+
+unsigned long long int b = 0xb82ff73c5c020599ULL;
+unsigned long long int c = 0xd4e8188733a29d8eULL;
+unsigned long long int d = 2, f = 1, g = 0, h = 0;
+unsigned long long int e = 0xf27771784749f32bULL;
+
+__attribute__((noinline, noclone)) void
+foo (void)
+{
+  _Bool a = d > 1;
+  g = f % ((d > 1) << 9);
+  h = a & (e & (a & b & c));
+}
+
+int
+main ()
+{
+  foo ();
+  if (g != 1 || h != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gnat.dg/array29.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/array29.adb	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/array29.adb	(.../branches/gcc-6-branch)
@@ -0,0 +1,26 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Array29 is
+
+  procedure Copy (Src : in Matrix; Dst : out Matrix) is
+  begin
+    for I in Src'Range (1) loop
+      for J in Src'Range (2) loop
+        Dst (I, J) := Src (I, J);
+      end loop;
+    end loop;
+  end;
+
+  procedure Proc is
+    N : constant := 2;
+    FM1 : constant Matrix (1 .. N, 1 .. N) := ((1.0, 2.0), (3.0, 4.0));
+    FM2 : constant Matrix (1 .. N, 1 .. N) := ((1.0, 2.0), (3.0, 4.0));
+    A : constant array (1 .. 2) of Matrix (1 .. N, 1 .. N)
+      := (Matrix (FM1), Matrix (FM2));
+    Final : Matrix (1 .. N, 1 .. N);
+  begin
+    Copy (Src => A (1), Dst => Final);
+  end;
+
+end Array29;
Index: gcc/testsuite/gnat.dg/array29.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/array29.ads	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/array29.ads	(.../branches/gcc-6-branch)
@@ -0,0 +1,7 @@
+package Array29 is
+
+  type Matrix is array (Integer range <>, Integer range <>) of Long_Float;
+
+  procedure Proc;
+
+end Array29;
Index: gcc/testsuite/gnat.dg/specs/uc2.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/specs/uc2.ads	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gnat.dg/specs/uc2.ads	(.../branches/gcc-6-branch)
@@ -0,0 +1,18 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+with Ada.Unchecked_Conversion;
+
+package UC2 is
+
+  subtype Word_Type is Integer range 0 .. 0;
+  type Arr is array (1 .. Word_Type'Size) of Boolean;
+  pragma Pack(Arr);
+
+  function Conv is
+     new Ada.Unchecked_Conversion (Source => Arr, Target => Word_Type);
+
+  A : Arr;
+  W : Word_Type := Conv(A);
+
+end UC2;
Index: gcc/testsuite/gcc.dg/pr82112.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr82112.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr82112.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,21 @@
+/* PR target/82112 */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu90" } */
+
+struct S { int a[10]; } bar (void);
+int b, c;
+
+void
+foo (void)
+{
+  __atomic_load (bar ().a, &b, __ATOMIC_ACQUIRE);	/* { dg-error "argument 1 of .__atomic_load. must be a non-void pointer type" } */
+  __atomic_load (&b, bar ().a, __ATOMIC_ACQUIRE);	/* { dg-error "argument 2 of .__atomic_load. must be a pointer type" } */
+  __atomic_store (bar ().a, &b, __ATOMIC_SEQ_CST);	/* { dg-error "argument 1 of .__atomic_store. must be a non-void pointer type" } */
+  __atomic_store (&b, bar ().a, __ATOMIC_SEQ_CST);	/* { dg-error "argument 2 of .__atomic_store. must be a pointer type" } */
+  __atomic_exchange (bar ().a, &b, &c, __ATOMIC_RELAXED);	/* { dg-error "argument 1 of .__atomic_exchange. must be a non-void pointer type" } */
+  __atomic_exchange (&b, bar ().a, &c, __ATOMIC_RELAXED);	/* { dg-error "argument 2 of .__atomic_exchange. must be a pointer type" } */
+  __atomic_exchange (&b, &c, bar ().a, __ATOMIC_RELAXED);	/* { dg-error "argument 3 of .__atomic_exchange. must be a pointer type" } */
+  __atomic_compare_exchange (bar ().a, &b, &c, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);	/* { dg-error "argument 1 of .__atomic_compare_exchange. must be a non-void pointer type" } */
+  __atomic_compare_exchange (&b, bar ().a, &c, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);	/* { dg-error "argument 2 of .__atomic_compare_exchange. must be a pointer type" } */
+  __atomic_compare_exchange (&b, &c, bar ().a, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);	/* { dg-error "argument 3 of .__atomic_compare_exchange. must be a pointer type" } */
+}
Index: gcc/testsuite/gcc.dg/gomp/pr81768-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr81768-2.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr81768-2.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,15 @@
+/* PR middle-end/81768 */
+/* { dg-do compile } */
+
+float b[10][15][10];
+
+void
+foo (void)
+{
+  float *i;
+#pragma omp target parallel for schedule(static, 32) collapse(3)
+  for (i = &b[0][0][0]; i < &b[0][0][10]; i++)
+    for (float *j = &b[0][15][0]; j > &b[0][0][0]; j -= 10)
+      for (float *k = &b[0][0][10]; k > &b[0][0][0]; --k)
+        b[i - &b[0][0][0]][(j - &b[0][0][0]) / 10 - 1][(k - &b[0][0][0]) - 1] -= 3.5;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr81768-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr81768-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr81768-1.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,15 @@
+/* PR middle-end/81768 */
+/* { dg-do compile } */
+
+float b[10][15][10];
+
+void
+foo (void)
+{
+  float *i;
+#pragma omp target parallel for simd schedule(static, 32) collapse(3)
+  for (i = &b[0][0][0]; i < &b[0][0][10]; i++)
+    for (float *j = &b[0][15][0]; j > &b[0][0][0]; j -= 10)
+      for (float *k = &b[0][0][10]; k > &b[0][0][0]; --k)
+	b[i - &b[0][0][0]][(j - &b[0][0][0]) / 10 - 1][(k - &b[0][0][0]) - 1] -= 3.5;
+}
Index: gcc/testsuite/gcc.dg/ubsan/pr81162.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ubsan/pr81162.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ubsan/pr81162.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,17 @@
+/* PR tree-optimization/81162 */
+/* { dg-do run } */
+/* { dg-options "-fsanitize=undefined -O2" } */
+
+short s;
+int i1 = 1;
+int i2 = 1;
+unsigned char uc = 147;
+
+int main() {
+  s = (-uc + 2147483647) << 0;
+  if (9031239389974324562ULL >= (-((i1 && i2) + uc) ^ -21096) ) {
+    return 0;
+  } else {
+    return -1;
+  }
+}
Index: gcc/testsuite/gcc.dg/ubsan/pr81505.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ubsan/pr81505.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ubsan/pr81505.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -fsanitize=signed-integer-overflow" } */
+
+int a, b, c, h;
+
+int i[5][5];
+
+void
+fn1 ()
+{
+  int l = 0;
+
+  for (a = 0; a <= 3; a++)
+    for (b = 1; b >= 0; b -= 1)
+      l |= i[0][b];
+  c = l;
+}
Index: gcc/testsuite/gcc.dg/pr79499.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr79499.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr79499.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,13 @@
+/* PR middle-end/79499 */
+/* { dg-do compile { target split_stack } } */
+/* { dg-options "-O2 -fsplit-stack -fno-omit-frame-pointer" } */
+
+struct S { struct S *a, *b; };
+
+void
+foo (struct S *x)
+{
+  do
+    x->b = x->a;
+  while (x = x->a);
+}
Index: gcc/testsuite/gcc.dg/pr81621.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr81621.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr81621.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,5 @@
+/* PR target/81621 */
+/* { dg-do compile { target freorder } } */
+/* { dg-options "-Og -fno-split-wide-types -freorder-blocks-and-partition" } */
+
+#include "graphite/scop-10.c"
Index: gcc/testsuite/gcc.dg/pr81192.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr81192.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr81192.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,22 @@
+/* { dg-options "-Os -fdump-tree-pre-details" } */
+
+unsigned a;
+int b, c;
+
+static int
+fn1 (int p1, int p2)
+{
+  return p1 > 2147483647 - p2 ? p1 : p1 + p2;
+}
+
+void
+fn2 (void)
+{
+  int j;
+  a = 30;
+  for (; a;)
+    for (; c; b = fn1 (j, 1))
+      ;
+}
+
+/* { dg-final { scan-tree-dump-times "(?n)find_duplicates: <bb .*> duplicate of <bb .*>" 1 "pre" } } */
Index: gcc/testsuite/gcc.dg/torture/pr75964.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr75964.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr75964.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+typedef __UINT8_TYPE__ uint8_t;
+
+uint8_t __attribute__ ((noinline, noclone))
+abs8 (uint8_t x)
+{
+  if (x & 0x80)
+    x = -x;
+
+  if (x & 0x80)
+    x = 0x7f;
+
+  return x;
+}
+
+int
+main (void)
+{
+  if (abs8 (0) != 0
+      || abs8 (1) != 1
+      || abs8 (127) != 127
+      || abs8 (128) != 127
+      || abs8 (129) != 127
+      || abs8 (255) != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr80341.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr80341.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr80341.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+/* { dg-additional-options "-Wno-overflow" } */
+/* { dg-require-effective-target int32plus } */
+
+const signed char c = -84;
+signed char s;
+
+void
+foo ()
+{
+  s = (unsigned short) c / -55;
+}
+
+int
+main ()
+{
+  foo ();
+  if (s != 90)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.dg/torture/pr80281.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr80281.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr80281.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,14 @@
+/* { dg-run } */
+/* { dg-require-effective-target int32plus } */
+
+int
+main ()
+{
+  volatile int a = 0;
+  long long b = 2147483648LL;
+  int c = a % 2;
+  int x = ((int) -b + c) % -2147483647;
+  if (x != -1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/ipa/pr82001.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr82001.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr82001.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,21 @@
+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -fdump-ipa-icf-details"  } */
+
+int
+mullo (int a, int b)
+{
+  asm("mul %%edx   # %%1 was %1"
+      : "+"
+	"a"(a),
+	"+d"(b));
+  return a;
+}
+
+int
+mulhi (int a, int b)
+{
+  asm("mul %%edx   # %%1 was %1" : "+d"(a), "+a"(b));
+  return a;
+}
+
+/* { dg-final { scan-ipa-dump "Equal symbols: 0" "icf"  } } */
Index: gcc/testsuite/gcc.dg/ipa/pr81696.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr81696.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr81696.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,26 @@
+/* { dg-options "-O2 -fdump-ipa-icf-details"  } */
+
+int
+main (int argc, char **argv)
+{
+  __label__ lab4, lab5, lab6;
+
+  void foo (void) { goto lab4; }
+  void foo2 (void) { goto lab4; }
+  void bar (void) { goto lab5; }
+  void baz (void) { goto lab6; }
+
+  if (argc)
+    foo ();
+  else
+    foo2 ();
+
+ lab4:;
+  bar ();
+ lab5:;
+  baz ();
+ lab6:;
+  return 0;
+}
+
+/* { dg-final { scan-ipa-dump "Equal symbols: 1" "icf"  } } */
Index: gcc/testsuite/gcc.dg/loop-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/loop-8.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/gcc.dg/loop-8.c	(.../branches/gcc-6-branch)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O1 -fdump-rtl-loop2_invariant" } */
-/* { dg-skip-if "unexpected IV" { "hppa*-*-* visium-*-*" } { "*" } { "" } } */
+/* { dg-skip-if "unexpected IV" { "hppa*-*-* visium-*-* powerpc*-*-*" } { "*" } { "" } } */
 
 void
 f (int *a, int *b)
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,383 @@
+2017-09-19  Martin Liska  <mliska@suse.cz>
+
+	Revert backport:
+	2017-08-10  Martin Liska  <mliska@suse.cz>
+
+	PR c++/81355
+	* g++.dg/other/pr81355.C: New test.
+
+2017-09-18  Richard Biener  <rguenther@suse.de>
+ 
+	Backport from mainline
+	2017-04-07  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/80341
+	* gcc.dg/torture/pr80341.c: New testcase.
+
+	2017-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/80281
+	* gcc.dg/torture/pr80281.c: New testcase.
+
+2017-09-18  Richard Biener  <rguenther@suse.de>
+ 
+	Backport from mainline
+	2017-08-28  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/81977
+	* g++.dg/torture/pr81977.C: New testcase.
+
+	2017-09-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82084
+	* g++.dg/torture/pr82084.C: New testcase.
+
+	2017-07-25  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/81505
+	* gcc.dg/ubsan/pr81505.c: New testcase.
+
+2017-09-18  Martin Liska  <mliska@suse.cz>
+
+	* gcc.dg/asan/pr81224.c: Remove.
+
+2017-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2017-09-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/82112
+	* gcc.target/powerpc/pr82112.c: New test.
+	* g++.dg/ext/altivec-18.C: New test.
+
+	PR target/82112
+	* c-c++-common/pr82112.c: New test.
+	* gcc.dg/pr82112.c: New test.
+
+	2017-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/81768
+	* gcc.dg/gomp/pr81768-2.c: New test.
+
+	PR middle-end/81768
+	* gcc.dg/gomp/pr81768-1.c: New test.
+
+	2017-08-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/81766
+	* gcc.target/i386/pr81766.c: New testcase.
+
+	2017-08-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/81621
+	* gcc.dg/pr81621.c: New test.
+
+	PR middle-end/81052
+	* c-c++-common/pr81052.c: New test.
+
+	2017-08-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/79499
+	* gcc.dg/pr79499.c: New test.
+
+	2017-06-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/81225
+	* gcc.target/i386/pr81225.c: New test.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-11  Martin Liska  <mliska@suse.cz>
+
+	PR tree-opt/79987
+	* gcc.target/i386/mpx/pr79987.c: New test.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-06-28  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/81224
+	* gcc.dg/asan/pr81224.c: New test.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-30  Martin Liska  <mliska@suse.cz>
+
+	PR inline-asm/82001
+	* gcc.dg/ipa/pr82001.c: New test.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-10  Martin Liska  <mliska@suse.cz>
+
+	PR c++/81355
+	* g++.dg/other/pr81355.C: New test.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-08  Martin Liska  <mliska@suse.cz>
+
+	PR tree-opt/81696
+	* gcc.dg/ipa/pr81696.c: New test.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-07-19  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/63361
+	* c-c++-common/ubsan/float-cast-overflow-1.c: Add either
+	-ffloat-store or -mieee for targets that need it.
+
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-06-28  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/81128
+	* gcc.target/i386/pr81128.c: New test.
+
+2017-09-12  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/81833
+	* gcc.target/powerpc/pr81833-1.c: New file.
+	* gcc.target/powerpc/pr81833-2.c: New file.
+
+2017-09-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/81852
+	* g++.dg/cpp1y/feat-cxx11.C: Check __cpp_threadsafe_static_init.
+	* g++.dg/cpp1y/feat-cxx14.C: Likewise.
+	* g++.dg/cpp1y/feat-cxx98.C: Likewise.
+	* g++.dg/cpp1y/feat-neg.C: Likewise.
+	* g++.dg/cpp1z/feat-cxx1z.C: Likewise.
+
+2017-09-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2017-08-30  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/81987
+	* g++.dg/torture/pr81987.C: New file.
+
+2017-09-05  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-08-29  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/81503
+	* gcc.c-torture/execute/pr81503.c: New file.
+
+2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/uc2.ads: New test.
+
+2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* testsuite/gnat.dg/array29.ad[sb]: New test.
+
+2017-09-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/mpx/mpx-os-support.h: New file.
+	* gcc.target/i386/mpx/mpx-check.h: Include mpx-os-support.h.
+	(check_osxsave): New function.
+	(main): Use __get_cpuid_count and return NORUNRES on failure.
+	Use check_osxsave.
+	* gcc.target/i386/mpx/va-arg-pack-1-lbv.c (foo1): Use
+	__builtin_va_arg_pack instead of __va_arg_pack.
+	* gcc.target/i386/mpx/va-arg-pack-1-nov.c (foo1): Ditto.
+	* gcc.target/i386/mpx/va-arg-pack-1-ubv.c (foo1): Ditto.
+	* gcc.target/i386/mpx/va-arg-pack-2-lbv.c (foo1): Ditto.
+	* gcc.target/i386/mpx/va-arg-pack-2-nov.c (foo1): Ditto.
+	* gcc.target/i386/mpx/va-arg-pack-2-ubv.c (foo1): Ditto.
+
+2017-09-02  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/81770
+	* gfortran.dg/warn_target_lifetime_3.f90: Fix a typo.
+	* gfortran.dg/warn_target_lifetime_4.f90: New testcase.
+
+2017-08-30  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2017-08-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/81593
+	* gcc.target/powerpc/vec-setup.h: New tests to test various
+	combinations of setting up vectors of 2 double word elements.
+	* gcc.target/powerpc/vec-setup-long.c: Likewise.
+	* gcc.target/powerpc/vec-setup-double.c: Likewise.
+	* gcc.target/powerpc/vec-setup-be-long.c: Likewise.
+	* gcc.target/powerpc/vec-setup-be-double.c: Likewise.
+	* gcc.target/powerpc/vsx-extract-6.c: New tests for optimzing
+	vector inserts from vector extracts.
+	* gcc.target/powerpc/vsx-extract-7.c: Likewise.
+
+2017-08-24  Yvan Roux  <yvan.roux@linaro.org>
+
+	Backport from mainline
+	2017-08-22  Yvan Roux  <yvan.roux@linaro.org>
+
+	PR c++/80287
+	* g++.dg/pr8028.C: New test.
+
+2017-08-22  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2017-08-17  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/80210
+	* gcc.target/powerpc/pr80210.c: New test.
+
+2017-08-16  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-08-08  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/81354
+	* g++.dg/torture/pr81354.C: New file.
+
+2017-08-14  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/71570
+	* g++.dg/cpp0x/lambda/lambda-ice17.C: New.
+
+2017-08-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81641
+	* gcc.target/i386/pr81641.c: New test.
+
+2017-07-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/81604
+	* c-c++-common/ubsan/pr81604.c: New test.
+
+2017-07-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2017-07-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	* gcc.target/powerpc/cpu-builtin-1.c (darn, scv): Add tests.
+
+2017-07-28  Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline r250496
+	2017-07-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/81414
+	* gcc.target/aarch64/pr81414.C: New.
+
+2017-07-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81555
+	PR tree-optimization/81556
+	* gcc.c-torture/execute/pr81555.c: New test.
+	* gcc.c-torture/execute/pr81556.c: New test.
+
+2017-07-26  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2017-07-05 trunk r249995, r249996.
+
+	PR target/81305
+	* gcc.target/avr/isr-test.h: New file.
+	* gcc.target/avr/torture/isr-01-simple.c: New test.
+	* gcc.target/avr/torture/isr-02-call.c: New test.
+	* gcc.target/avr/torture/isr-03-fixed.c: New test.
+
+2017-07-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2017-07-14  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR tree-optimization/81162
+	* gcc.dg/ubsan/pr81162.c: New file.
+
+2017-07-25  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from trunk r247719.
+
+	2017-05-06  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR rtl-optimization/75964
+	* gcc.dg/torture/pr75964.c: New test.
+
+2017-07-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/80569
+	* gcc.target/i386/pr80569.c: New test.
+
+2017-07-18  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81471
+	* gcc.target/i386/pr81471.c: New test.
+
+2017-07-14  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backports from trunk:
+
+	2017-01-23  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	PR target/66669
+	* gcc.dg/loop-8.c: Modify dg-skip-if directive to exclude this
+	test on powerpc targets.
+
+	2017-02-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	PR target/68972
+	* g++.dg/cpp1y/vla-initlist1.C: Add dg-skip-if directive to
+	disable this test on power architecture.
+
+	2017-03-23  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	* gcc.target/powerpc/p9-options-1.c: New test.
+
+	2017-03-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	PR target/80103
+	* gcc.target/powerpc/pr80103-1.c: New test.
+
+	2017-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	PR target/80101
+	* gcc.target/powerpc/pr80101-1.c: New test.
+
+	2017-07-05  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+	PR target/80103
+	* gcc.target/powerpc/pr80103-1.c (b): Correct spelling of
+	__attribute__.
+
+2017-07-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2017-07-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81375
+	* gcc.target/i386/pr81375.c: New test.
+
+	Backport from mainline
+	2017-07-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81300
+	* gcc.target/i386/pr81300.c: New test.
+
+2017-07-13  Tom de Vries  <tom@codesourcery.com>
+
+	backport from mainline:
+	PR tree-optimization/81192
+	2017-07-03  Tom de Vries  <tom@codesourcery.com>
+
+	* gcc.dg/pr81192.c: New test.
+
+2017-07-06  Andrew Pinski  <apinski@cavium.com>
+
+	* gcc.target/aarch64/pr71112.c : New Testcase.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
@@ -2922,6 +3302,23 @@
 	* g++.dg/cpp0x/pr70869.C: New test.
 	* g++.dg/cpp0x/pr71054.C: New test.
 
+2017-07-19  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2017-06-28  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/81193
+	* lib/target-supports.exp
+	(check_ppc_cpu_supports_hw_available): New test to make sure
+	__builtin_cpu_supports works on power7 and newer.
+
+	Back port from trunk
+	2017-07-12  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/81193
+	* gcc.target/powerpc/cpu-builtin-1.c: Add guard against using
+	__builtin_cpu_supports with old GLIBC's.
+
 2016-07-18  Michael Meissner  <meissner@linux.vnet.ibm.com>
 
 	Back port from mainline
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice17.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice17.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-ice17.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,12 @@
+// PR c++/71570
+// { dg-do compile { target c++11 } }
+
+void foo (int);
+
+void foo (void)
+{
+  [&foo] // { dg-error "cannot capture" }
+  {
+    foo (0);
+  };
+}
Index: gcc/testsuite/g++.dg/torture/pr81354.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr81354.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr81354.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,24 @@
+// PR81354 reported this test as crashing in a limited range of revisions.
+// { dg-do compile }
+
+struct T { double a; double b; };
+
+void foo(T Ad[], int As[2])
+{
+  int j;
+  int i;
+  int Bs[2] = {0,0};
+  T Bd[16];
+
+  for (j = 0; j < 4; j++) {
+    for (i = 0; i + 1 <= j + 1; i++) {
+      Ad[i + As[0] * j] = Bd[i + Bs[0] * j];
+    }
+
+    i = j + 1;  // <- comment out this line and it does not crash
+    for (; i + 1 < 5; i++) {
+      Ad[i + As[0] * j].a = 0.0;
+      Ad[i + As[0] * j].b = 0.0;
+    }
+  }
+}
Index: gcc/testsuite/g++.dg/torture/pr82084.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr82084.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr82084.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,9 @@
+// { dg-do compile }
+
+#include <string>
+int main()
+{
+  wchar_t strs[4][2]= {  L"A", L"B", L"C" , L"D"};
+  std::wstring ss(strs[0]);
+  return 0;
+}
Index: gcc/testsuite/g++.dg/torture/pr81977.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr81977.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr81977.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,55 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+
+#include <cstdint>
+
+typedef struct
+{
+  uint16_t  x ;
+  uint16_t  y ;
+  uint64_t  z ;
+} __attribute__((packed, aligned(1))) TestMsgType;
+
+struct Payload
+{
+  uint16_t header_info[2];
+  TestMsgType _pref;
+  void Pack(uint8_t *buffer)
+    {
+      __builtin_memcpy(buffer, &_pref, sizeof(_pref));
+    }
+  void UnPack(uint8_t *buffer)
+    {
+      __builtin_memcpy(&_pref, buffer, sizeof(_pref));
+    }
+};
+
+
+struct Msg
+{
+  Payload _payload;
+  void Pack(uint8_t *buffer)
+    {
+      _payload.Pack(buffer);
+    }
+
+  void UnPack(uint8_t *buffer)
+    {
+      _payload.UnPack(buffer);
+    }
+};
+
+int main()
+{
+  uint8_t * buffer = new uint8_t [30];
+  Msg msg;
+  Msg msg1;
+  msg._payload._pref.x             = 0xabcd;
+  msg._payload._pref.y             = 0xa;
+  msg._payload._pref.z             = 0x0001020304051617;
+  msg.Pack(&buffer[0]);
+  msg1.UnPack(&buffer[0]);
+  if (msg1._payload._pref.x != 0xabcd)
+    __builtin_abort ();
+  delete [] buffer;
+}
Index: gcc/testsuite/g++.dg/torture/pr81987.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr81987.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr81987.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,61 @@
+extern short var_1;
+extern const short var_3;
+extern unsigned long int var_9;
+extern short var_13;
+extern const unsigned long int var_15;
+extern const unsigned long int var_37;
+extern unsigned long int var_40;
+extern long long int var_47;
+extern short var_48;
+extern const short var_54;
+extern long long int var_79;
+extern long long int var_81;
+extern long long int var_94;
+extern long long int var_95;
+extern long long int var_701;
+extern unsigned long int var_786;
+extern short var_788;
+extern long long int var_844;
+
+struct struct_1 {
+  short member_1_2 : 15;
+  static long long int member_1_3;
+};
+
+extern struct_1 struct_obj_6;
+extern struct_1 struct_obj_8;
+
+void foo() {
+  int a = var_3 <= 602154393864UL;
+  if (var_81 ? 0 : var_3 && var_9)
+    ;
+  else {
+    var_94 = 0;
+    if (var_3 && var_48 || var_13) {
+      if (var_48)
+	var_95 = 0;
+      short b((2364461588881776511UL + var_3) * (2 ? var_13 : 0) || var_1);
+      struct_obj_8.member_1_2 = b;
+      if (var_15) {
+	if (var_81)
+	  if (var_47)
+	    ;
+	  else if (var_40)
+	    var_701 = 0;
+      } else {
+	if (var_40)
+	  var_79 = 0;
+	if (var_54) {
+	  if (var_37)
+	    var_786 = 0;
+	  else
+	    var_788 = 0;
+	            struct_obj_6.member_1_3 =
+		      (2364461588881776511UL + var_3) * (2 ? var_13 : 0);
+	}
+      }
+      if ((2364461588881776511UL + var_3) * (2 ? var_13 : 0))
+	var_844 = 0;
+    }
+  }
+}
Index: gcc/testsuite/g++.dg/cpp1y/vla-initlist1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/vla-initlist1.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/vla-initlist1.C	(.../branches/gcc-6-branch)
@@ -1,4 +1,5 @@
 // { dg-do run { target c++11 } }
+// { dg-skip-if "power overwrites two slots of array i" { "power*-*-*" } }
 // { dg-options "-Wno-vla" }
 
 #include <initializer_list>
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx11.C	(.../branches/gcc-6-branch)
@@ -125,6 +125,12 @@
 #  error "__cpp_alias_templates != 200704"
 #endif
 
+#ifndef __cpp_threadsafe_static_init
+#  error "__cpp_threadsafe_static_init"
+#elif __cpp_threadsafe_static_init != 200806
+#  error "__cpp_threadsafe_static_init != 200806"
+#endif
+
 //  C++14 features allowed in C++11 in non-ANSI modes:
 
 #ifndef __cpp_binary_literals
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C	(.../branches/gcc-6-branch)
@@ -118,6 +118,12 @@
 #  error "__cpp_alias_templates != 200704"
 #endif
 
+#ifndef __cpp_threadsafe_static_init
+#  error "__cpp_threadsafe_static_init"
+#elif __cpp_threadsafe_static_init != 200806
+#  error "__cpp_threadsafe_static_init != 200806"
+#endif
+
 //  C++14 features:
 
 #ifndef __cpp_binary_literals
Index: gcc/testsuite/g++.dg/cpp1y/feat-cxx98.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx98.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-cxx98.C	(.../branches/gcc-6-branch)
@@ -15,6 +15,14 @@
 #  error "__cpp_exceptions != 199711"
 #endif
 
+//  C++11 features allowed in C++98:
+
+#ifndef __cpp_threadsafe_static_init
+#  error "__cpp_threadsafe_static_init"
+#elif __cpp_threadsafe_static_init != 200806
+#  error "__cpp_threadsafe_static_init != 200806"
+#endif
+
 //  C++14 features allowed in C++98 in non-ANSI modes:
 
 #ifndef __cpp_binary_literals
Index: gcc/testsuite/g++.dg/cpp1y/feat-neg.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/feat-neg.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/feat-neg.C	(.../branches/gcc-6-branch)
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-fno-rtti -fno-exceptions" }
+// { dg-options "-fno-rtti -fno-exceptions -fno-threadsafe-statics" }
 
 //  C++98 features with explicit opt-out:
 
@@ -10,3 +10,9 @@
 #ifndef __cpp_exceptions
 #  error "__cpp_exceptions" // { dg-error "error" }
 #endif
+
+//  C++11 features with explicit opt-out:
+
+#ifndef __cpp_threadsafe_static_init
+#  error "__cpp_threadsafe_static_init" // { dg-error "error" }
+#endif
Index: gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C	(.../branches/gcc-6-branch)
@@ -106,6 +106,12 @@
 #  error "__cpp_alias_templates != 200704"
 #endif
 
+#ifndef __cpp_threadsafe_static_init
+#  error "__cpp_threadsafe_static_init"
+#elif __cpp_threadsafe_static_init != 200806
+#  error "__cpp_threadsafe_static_init != 200806"
+#endif
+
 //  C++14 features:
 
 #ifndef __cpp_binary_literals
Index: gcc/testsuite/g++.dg/ext/altivec-18.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/altivec-18.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/altivec-18.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,14 @@
+// PR target/82112
+// { dg-do compile { target powerpc*-*-* } }
+// { dg-require-effective-target powerpc_altivec_ok }
+// { dg-options "-maltivec" }
+
+#include <altivec.h>
+
+__attribute__((aligned (16))) extern const unsigned char c[16];
+
+void
+foo (void)
+{
+  vec_ld (0, c);
+}
Index: gcc/testsuite/g++.dg/pr80287.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr80287.C	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/g++.dg/pr80287.C	(.../branches/gcc-6-branch)
@@ -0,0 +1,13 @@
+// PR c++/80287
+// { dg-do compile { target c++11 } }
+// { dg-options "-g" }
+
+struct A {
+  operator long() {}
+} __attribute__((__may_alias__));
+
+struct {
+  A ino;
+} a;
+
+char b = a.ino;
Index: gcc/testsuite/c-c++-common/ubsan/pr81604.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/ubsan/pr81604.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/ubsan/pr81604.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,31 @@
+/* PR sanitizer/81604 */
+/* { dg-do run } */
+/* { dg-options "-fsanitize=bounds,signed-integer-overflow" } */
+
+long a[10];
+
+__attribute__((noinline, noclone)) long *
+foo (int i)
+{
+  return &a[i];
+}
+
+__attribute__((noinline, noclone)) long
+bar (long x, long y)
+{
+  return x * y;
+}
+
+int
+main ()
+{
+  volatile int i = -1;
+  volatile long l = __LONG_MAX__;
+  long *volatile p;
+  p = foo (i);
+  l = bar (l, l);
+  return 0;
+}
+
+/* { dg-output "index -1 out of bounds for type 'long int \\\[10\\\]'\[^\n\r]*(\n|\r\n|\r)" } */
+/* { dg-output "\[^\n\r]*signed integer overflow: \[0-9]+ \\* \[0-9]+ cannot be represented in type 'long int'" } */
Index: gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-1.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-1.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/ubsan/float-cast-overflow-1.c	(.../branches/gcc-6-branch)
@@ -1,6 +1,7 @@
 /* { dg-do run { target { lp64 || ilp32 } } } */
 /* { dg-options "-fsanitize=float-cast-overflow" } */
-/* { dg-additional-options "-msse2 -mfpmath=sse" { target { sse2_runtime && ia32 } } } */
+/* { dg-additional-options "-ffloat-store" { target { ia32 } } } */
+/* { dg-additional-options "-mieee" { target { { alpha*-*-* } || { sh*-*-* } } } } */
 
 #include <limits.h>
 #include "float-cast.h"
Index: gcc/testsuite/c-c++-common/pr82112.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr82112.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr82112.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,13 @@
+/* PR target/82112 */
+/* { dg-do compile } */
+
+int c[10], d[10], e[10], f[10], g[10], h[10], i[10], j[10], k[10], l[10];
+
+void
+foo (void)
+{
+  __atomic_load (c, d, __ATOMIC_ACQUIRE);
+  __atomic_store (e, f, __ATOMIC_SEQ_CST);
+  __atomic_exchange (g, h, i, __ATOMIC_RELAXED);
+  __atomic_compare_exchange (j, k, l, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);
+}
Index: gcc/testsuite/c-c++-common/pr81052.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr81052.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr81052.c	(.../branches/gcc-6-branch)
@@ -0,0 +1,28 @@
+/* PR middle-end/81052 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp-simd -O2" } */
+
+int
+foo (int x, int y)
+{
+  int i;
+#pragma omp simd
+  for (i = x; i < y; ++i)
+    return 0;			/* { dg-error "invalid branch to/from OpenMP structured block" } */
+  return 1;
+}
+
+#ifdef __cplusplus
+template <typename T>
+T
+bar (T x, T y)
+{
+  T i;
+#pragma omp simd
+  for (i = x; i < y; ++i)
+    return 0;			/* { dg-error "invalid branch to/from OpenMP structured block" "" { target c++ } } */
+  return 1;
+}
+
+int x = bar (1, 7);
+#endif
Index: gcc/cp/class.c
===================================================================
--- a/src/gcc/cp/class.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/cp/class.c	(.../branches/gcc-6-branch)
@@ -1999,12 +1999,14 @@
 static void
 fixup_may_alias (tree klass)
 {
-  tree t;
+  tree t, v;
 
   for (t = TYPE_POINTER_TO (klass); t; t = TYPE_NEXT_PTR_TO (t))
-    TYPE_REF_CAN_ALIAS_ALL (t) = true;
+    for (v = TYPE_MAIN_VARIANT (t); v; v = TYPE_NEXT_VARIANT (v))
+      TYPE_REF_CAN_ALIAS_ALL (v) = true;
   for (t = TYPE_REFERENCE_TO (klass); t; t = TYPE_NEXT_REF_TO (t))
-    TYPE_REF_CAN_ALIAS_ALL (t) = true;
+    for (v = TYPE_MAIN_VARIANT (t); v; v = TYPE_NEXT_VARIANT (v))
+      TYPE_REF_CAN_ALIAS_ALL (v) = true;
 }
 
 /* Early variant fixups: we apply attributes at the beginning of the class
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,18 @@
+2017-09-15  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2017-09-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/81314
+	* cp-gimplify.c (omp_var_to_track): Look through references.
+	(omp_cxx_notice_variable): Likewise.
+
+2017-08-14  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/71570
+	* lambda.c (add_capture): Early return if we cannot capture by
+	reference.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: gcc/cp/cp-gimplify.c
===================================================================
--- a/src/gcc/cp/cp-gimplify.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/cp/cp-gimplify.c	(.../branches/gcc-6-branch)
@@ -853,6 +853,8 @@
   tree type = TREE_TYPE (decl);
   if (is_invisiref_parm (decl))
     type = TREE_TYPE (type);
+  else if (TREE_CODE (type) == REFERENCE_TYPE)
+    type = TREE_TYPE (type);
   while (TREE_CODE (type) == ARRAY_TYPE)
     type = TREE_TYPE (type);
   if (type == error_mark_node || !CLASS_TYPE_P (type))
@@ -905,6 +907,8 @@
 	      tree type = TREE_TYPE (decl);
 	      if (is_invisiref_parm (decl))
 		type = TREE_TYPE (type);
+	      else if (TREE_CODE (type) == REFERENCE_TYPE)
+		type = TREE_TYPE (type);
 	      while (TREE_CODE (type) == ARRAY_TYPE)
 		type = TREE_TYPE (type);
 	      get_copy_ctor (type, tf_none);
Index: gcc/cp/lambda.c
===================================================================
--- a/src/gcc/cp/lambda.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/cp/lambda.c	(.../branches/gcc-6-branch)
@@ -491,7 +491,10 @@
 	{
 	  type = build_reference_type (type);
 	  if (!dependent_type_p (type) && !real_lvalue_p (initializer))
-	    error ("cannot capture %qE by reference", initializer);
+	    {
+	      error ("cannot capture %qE by reference", initializer);
+	      return error_mark_node;
+	    }
 	}
       else
 	{
Index: gcc/opts.c
===================================================================
--- a/src/gcc/opts.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/opts.c	(.../branches/gcc-6-branch)
@@ -216,7 +216,7 @@
 		      unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,
 		      location_t loc,
 		      const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED,
-		      diagnostic_context *dc)
+		      diagnostic_context *dc, void (*) (void))
 {
   gcc_assert (dc == global_dc);
   gcc_assert (kind == DK_UNSPECIFIED);
@@ -1543,7 +1543,8 @@
 		      unsigned int lang_mask, int kind ATTRIBUTE_UNUSED,
 		      location_t loc,
 		      const struct cl_option_handlers *handlers,
-		      diagnostic_context *dc)
+		      diagnostic_context *dc,
+		      void (*target_option_override_hook) (void))
 {
   size_t scode = decoded->opt_index;
   const char *arg = decoded->arg;
@@ -1570,6 +1571,7 @@
 	undoc_mask = ((opts->x_verbose_flag | opts->x_extra_warnings)
 		      ? 0
 		      : CL_UNDOCUMENTED);
+	target_option_override_hook ();
 	/* First display any single language specific options.  */
 	for (i = 0; i < cl_lang_count; i++)
 	  print_specific_help
@@ -1589,6 +1591,7 @@
       if (lang_mask == CL_DRIVER)
 	break;
 
+      target_option_override_hook ();
       print_specific_help (CL_TARGET, CL_UNDOCUMENTED, 0, opts, lang_mask);
       opts->x_exit_after_options = true;
       break;
@@ -1710,8 +1713,11 @@
 	  }
 
 	if (include_flags)
-	  print_specific_help (include_flags, exclude_flags, 0, opts,
-			       lang_mask);
+	  {
+	    target_option_override_hook ();
+	    print_specific_help (include_flags, exclude_flags, 0, opts,
+				 lang_mask);
+	  }
 	opts->x_exit_after_options = true;
 	break;
       }
Index: gcc/opts.h
===================================================================
--- a/src/gcc/opts.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/opts.h	(.../branches/gcc-6-branch)
@@ -267,7 +267,8 @@
 		   const struct cl_decoded_option *decoded,
 		   unsigned int lang_mask, int kind, location_t loc,
 		   const struct cl_option_handlers *handlers,
-		   diagnostic_context *dc);
+		   diagnostic_context *dc,
+		   void (*target_option_override_hook) (void));
 
   /* The mask that must have some bit in common with the flags for the
      option for this particular handler to be used.  */
@@ -289,6 +290,9 @@
   void (*wrong_lang_callback) (const struct cl_decoded_option *decoded,
 			       unsigned int lang_mask);
 
+  /* Target option override hook.  */
+  void (*target_option_override_hook) (void);
+
   /* The number of individual handlers.  */
   size_t num_handlers;
 
@@ -333,13 +337,15 @@
 							  const char **argv, 
 							  struct cl_decoded_option **decoded_options,
 							  unsigned int *decoded_options_count);
-extern void set_default_handlers (struct cl_option_handlers *handlers);
+extern void set_default_handlers (struct cl_option_handlers *handlers,
+				  void (*target_option_override_hook) (void));
 extern void decode_options (struct gcc_options *opts,
 			    struct gcc_options *opts_set,
 			    struct cl_decoded_option *decoded_options,
 			    unsigned int decoded_options_count,
 			    location_t loc,
-			    diagnostic_context *dc);
+			    diagnostic_context *dc,
+			    void (*target_option_override_hook) (void));
 extern int option_enabled (int opt_idx, void *opts);
 extern bool get_option_state (struct gcc_options *, int,
 			      struct cl_option_state *);
@@ -384,7 +390,8 @@
 				  unsigned int lang_mask, int kind,
 				  location_t loc,
 				  const struct cl_option_handlers *handlers,
-				  diagnostic_context *dc);
+				  diagnostic_context *dc,
+				  void (*target_option_override_hook) (void));
 extern bool target_handle_option (struct gcc_options *opts,
 				  struct gcc_options *opts_set,
 				  const struct cl_decoded_option *decoded,
@@ -391,7 +398,8 @@
 				  unsigned int lang_mask, int kind,
 				  location_t loc,
 				  const struct cl_option_handlers *handlers,
-				  diagnostic_context *dc);
+				  diagnostic_context *dc,
+				  void (*target_option_override_hook) (void));
 extern void finish_options (struct gcc_options *opts,
 			    struct gcc_options *opts_set,
 			    location_t loc);
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,27 @@
+2017-09-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-08-29  Martin Liska  <mliska@suse.cz>
+
+	PR other/39851
+	* gcc-interface/trans.c (Pragma_to_gnu): Set argument to NULL.
+
+2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (unchecked_convert): When the result type is a
+	non-biased integral type with size 0, set the result to 0 directly.
+
+2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Call_to_gnu): If this is a function call and
+	there is no target, do not create a temporary for the return value for
+	an allocator either.
+
+2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (pos_to_constructor): Skip conversions to an
+	unconstrained array type.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: gcc/ada/gcc-interface/utils.c
===================================================================
--- a/src/gcc/ada/gcc-interface/utils.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ada/gcc-interface/utils.c	(.../branches/gcc-6-branch)
@@ -5207,20 +5207,26 @@
       && !(code == INTEGER_TYPE && TYPE_BIASED_REPRESENTATION_P (type))
       && !(TYPE_UNSIGNED (type) && TYPE_UNSIGNED (etype)))
     {
-      tree base_type
-	= gnat_type_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),
-			      TYPE_UNSIGNED (type));
-      tree shift_expr
-	= convert (base_type,
-		   size_binop (MINUS_EXPR,
-			       TYPE_SIZE (type), TYPE_RM_SIZE (type)));
-      expr
-	= convert (type,
-		   build_binary_op (RSHIFT_EXPR, base_type,
-				    build_binary_op (LSHIFT_EXPR, base_type,
-						     convert (base_type, expr),
-						     shift_expr),
-				    shift_expr));
+      if (integer_zerop (TYPE_RM_SIZE (type)))
+	expr = build_int_cst (type, 0);
+      else
+	{
+	  tree base_type
+	    = gnat_type_for_size (TREE_INT_CST_LOW (TYPE_SIZE (type)),
+				  TYPE_UNSIGNED (type));
+	  tree shift_expr
+	    = convert (base_type,
+		       size_binop (MINUS_EXPR,
+				   TYPE_SIZE (type), TYPE_RM_SIZE (type)));
+	  expr
+	    = convert (type,
+		       build_binary_op (RSHIFT_EXPR, base_type,
+				        build_binary_op (LSHIFT_EXPR, base_type,
+							 convert (base_type,
+								  expr),
+							 shift_expr),
+				        shift_expr));
+	}
     }
 
   /* An unchecked conversion should never raise Constraint_Error.  The code
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- a/src/gcc/ada/gcc-interface/trans.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ada/gcc-interface/trans.c	(.../branches/gcc-6-branch)
@@ -1469,7 +1469,7 @@
 	else
 	  option_index = 0;
 
-	set_default_handlers (&handlers);
+	set_default_handlers (&handlers, NULL);
 	control_warning_option (option_index, (int) kind, arg, imply, location,
 				lang_mask, &handlers, &global_options,
 				&global_options_set, global_dc);
@@ -4303,11 +4303,11 @@
 	  parameters.
 
        2. There is no target and the call is made for neither an object nor a
-	  renaming declaration, nor a return statement, and the return type has
-	  variable size, because in this case the gimplifier cannot create the
-	  temporary, or more generally is simply an aggregate type, because the
-	  gimplifier would create the temporary in the outermost scope instead
-	  of locally.
+	  renaming declaration, nor a return statement, nor an allocator, and
+	  the return type has variable size because in this case the gimplifier
+	  cannot create the temporary, or more generally is simply an aggregate
+	  type, because the gimplifier would then create the temporary in the
+	  outermost scope instead of locally.
 
        3. There is a target and it is a slice or an array with fixed size,
 	  and the return type has variable size, because the gimplifier
@@ -4326,6 +4326,8 @@
 	      && Nkind (Parent (gnat_node)) != N_Object_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Object_Renaming_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Simple_Return_Statement
+	      && !(Nkind (Parent (gnat_node)) == N_Qualified_Expression
+		   && Nkind (Parent (Parent (gnat_node))) == N_Allocator)
 	      && AGGREGATE_TYPE_P (gnu_result_type)
 	      && !TYPE_IS_FAT_POINTER_P (gnu_result_type))
 	  || (gnu_target
@@ -9649,7 +9651,14 @@
 				       gnat_component_type);
       else
 	{
-	  gnu_expr = gnat_to_gnu (gnat_expr);
+	  /* If the expression is a conversion to an unconstrained array type,
+	     skip it to avoid spilling to memory.  */
+	  if (Nkind (gnat_expr) == N_Type_Conversion
+	      && Is_Array_Type (Etype (gnat_expr))
+	      && !Is_Constrained (Etype (gnat_expr)))
+	    gnu_expr = gnat_to_gnu (Expression (gnat_expr));
+	  else
+	    gnu_expr = gnat_to_gnu (gnat_expr);
 
 	  /* Before assigning the element to the array, make sure it is
 	     in range.  */
Index: gcc/asan.c
===================================================================
--- a/src/gcc/asan.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/asan.c	(.../branches/gcc-6-branch)
@@ -1800,6 +1800,9 @@
       || bitsize != size_in_bytes * BITS_PER_UNIT)
     return;
 
+  if (TREE_CODE (inner) == VAR_DECL && DECL_HARD_REGISTER (inner))
+    return;
+
   if (TREE_CODE (inner) == VAR_DECL
       && offset == NULL_TREE
       && bitpos >= 0
Index: gcc/lra-remat.c
===================================================================
--- a/src/gcc/lra-remat.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/lra-remat.c	(.../branches/gcc-6-branch)
@@ -753,7 +753,7 @@
 
 	if (regno2 >= FIRST_PSEUDO_REGISTER && reg_renumber[regno2] >= 0)
 	  regno2 = reg_renumber[regno2];
-	if (regno >= FIRST_PSEUDO_REGISTER)
+	if (regno2 >= FIRST_PSEUDO_REGISTER)
 	  nregs2 = 1;
 	else
 	  nregs2 = hard_regno_nregs[regno2][reg->biggest_mode];
Index: gcc/gimple-ssa-strength-reduction.c
===================================================================
--- a/src/gcc/gimple-ssa-strength-reduction.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/gimple-ssa-strength-reduction.c	(.../branches/gcc-6-branch)
@@ -2005,91 +2005,92 @@
   tree target_type = TREE_TYPE (gimple_assign_lhs (c->cand_stmt));
   enum tree_code cand_code = gimple_assign_rhs_code (c->cand_stmt);
 
-  /* It is highly unlikely, but possible, that the resulting
-     bump doesn't fit in a HWI.  Abandon the replacement
-     in this case.  This does not affect siblings or dependents
-     of C.  Restriction to signed HWI is conservative for unsigned
-     types but allows for safe negation without twisted logic.  */
-  if (wi::fits_shwi_p (bump)
-      && bump.to_shwi () != HOST_WIDE_INT_MIN
-      /* It is not useful to replace casts, copies, or adds of
-	 an SSA name and a constant.  */
-      && cand_code != MODIFY_EXPR
-      && !CONVERT_EXPR_CODE_P (cand_code)
-      && cand_code != PLUS_EXPR
-      && cand_code != POINTER_PLUS_EXPR
-      && cand_code != MINUS_EXPR)
+  /* It is not useful to replace casts, copies, negates, or adds of
+     an SSA name and a constant.  */
+  if (cand_code == MODIFY_EXPR
+      || CONVERT_EXPR_CODE_P (cand_code)
+      || cand_code == PLUS_EXPR
+      || cand_code == POINTER_PLUS_EXPR
+      || cand_code == MINUS_EXPR
+      || cand_code == NEGATE_EXPR)
+    return;
+
+  enum tree_code code = PLUS_EXPR;
+  tree bump_tree;
+  gimple *stmt_to_print = NULL;
+
+  /* If the basis name and the candidate's LHS have incompatible
+     types, introduce a cast.  */
+  if (!useless_type_conversion_p (target_type, TREE_TYPE (basis_name)))
+    basis_name = introduce_cast_before_cand (c, target_type, basis_name);
+  if (wi::neg_p (bump))
     {
-      enum tree_code code = PLUS_EXPR;
-      tree bump_tree;
-      gimple *stmt_to_print = NULL;
+      code = MINUS_EXPR;
+      bump = -bump;
+    }
 
-      /* If the basis name and the candidate's LHS have incompatible
-	 types, introduce a cast.  */
-      if (!useless_type_conversion_p (target_type, TREE_TYPE (basis_name)))
-	basis_name = introduce_cast_before_cand (c, target_type, basis_name);
-      if (wi::neg_p (bump))
-	{
-	  code = MINUS_EXPR;
-	  bump = -bump;
-	}
+ /* It is possible that the resulting bump doesn't fit in target_type.
+    Abandon the replacement in this case.  This does not affect
+    siblings or dependents of C.  */
+  if (bump != wi::ext (bump, TYPE_PRECISION (target_type),
+		       TYPE_SIGN (target_type)))
+    return;
 
-      bump_tree = wide_int_to_tree (target_type, bump);
+  bump_tree = wide_int_to_tree (target_type, bump);
 
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+      fputs ("Replacing: ", dump_file);
+      print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);
+    }
+
+  if (bump == 0)
+    {
+      tree lhs = gimple_assign_lhs (c->cand_stmt);
+      gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
+      gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
+      gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
+      gsi_replace (&gsi, copy_stmt, false);
+      c->cand_stmt = copy_stmt;
       if (dump_file && (dump_flags & TDF_DETAILS))
+	stmt_to_print = copy_stmt;
+    }
+  else
+    {
+      tree rhs1, rhs2;
+      if (cand_code != NEGATE_EXPR) {
+	rhs1 = gimple_assign_rhs1 (c->cand_stmt);
+	rhs2 = gimple_assign_rhs2 (c->cand_stmt);
+      }
+      if (cand_code != NEGATE_EXPR
+	  && ((operand_equal_p (rhs1, basis_name, 0)
+	       && operand_equal_p (rhs2, bump_tree, 0))
+	      || (operand_equal_p (rhs1, bump_tree, 0)
+		  && operand_equal_p (rhs2, basis_name, 0))))
 	{
-	  fputs ("Replacing: ", dump_file);
-	  print_gimple_stmt (dump_file, c->cand_stmt, 0, 0);
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    {
+	      fputs ("(duplicate, not actually replacing)", dump_file);
+	      stmt_to_print = c->cand_stmt;
+	    }
 	}
-
-      if (bump == 0)
+      else
 	{
-	  tree lhs = gimple_assign_lhs (c->cand_stmt);
-	  gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
-	  gsi_replace (&gsi, copy_stmt, false);
-	  c->cand_stmt = copy_stmt;
+	  gimple_assign_set_rhs_with_ops (&gsi, code,
+					  basis_name, bump_tree);
+	  update_stmt (gsi_stmt (gsi));
+	  c->cand_stmt = gsi_stmt (gsi);
 	  if (dump_file && (dump_flags & TDF_DETAILS))
-	    stmt_to_print = copy_stmt;
+	    stmt_to_print = gsi_stmt (gsi);
 	}
-      else
-	{
-	  tree rhs1, rhs2;
-	  if (cand_code != NEGATE_EXPR) {
-	    rhs1 = gimple_assign_rhs1 (c->cand_stmt);
-	    rhs2 = gimple_assign_rhs2 (c->cand_stmt);
-	  }
-	  if (cand_code != NEGATE_EXPR
-	      && ((operand_equal_p (rhs1, basis_name, 0)
-		   && operand_equal_p (rhs2, bump_tree, 0))
-		  || (operand_equal_p (rhs1, bump_tree, 0)
-		      && operand_equal_p (rhs2, basis_name, 0))))
-	    {
-	      if (dump_file && (dump_flags & TDF_DETAILS))
-		{
-		  fputs ("(duplicate, not actually replacing)", dump_file);
-		  stmt_to_print = c->cand_stmt;
-		}
-	    }
-	  else
-	    {
-	      gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	      gimple_assign_set_rhs_with_ops (&gsi, code,
-					      basis_name, bump_tree);
-	      update_stmt (gsi_stmt (gsi));
-              c->cand_stmt = gsi_stmt (gsi);
-	      if (dump_file && (dump_flags & TDF_DETAILS))
-		stmt_to_print = gsi_stmt (gsi);
-	    }
-	}
+    }
   
-      if (dump_file && (dump_flags & TDF_DETAILS))
-	{
-	  fputs ("With: ", dump_file);
-	  print_gimple_stmt (dump_file, stmt_to_print, 0, 0);
-	  fputs ("\n", dump_file);
-  	}
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+      fputs ("With: ", dump_file);
+      print_gimple_stmt (dump_file, stmt_to_print, 0, 0);
+      fputs ("\n", dump_file);
     }
 }
 
@@ -2141,8 +2142,6 @@
 			     widest_int increment, edge e, location_t loc,
 			     bool known_stride)
 {
-  basic_block insert_bb;
-  gimple_stmt_iterator gsi;
   tree lhs, basis_type;
   gassign *new_stmt;
 
@@ -2197,19 +2196,13 @@
 	gcc_unreachable ();
     }
 
-  insert_bb = single_succ_p (e->src) ? e->src : split_edge (e);
-  gsi = gsi_last_bb (insert_bb);
-
-  if (!gsi_end_p (gsi) && is_ctrl_stmt (gsi_stmt (gsi)))
-    gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);
-  else
-    gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);
-
   gimple_set_location (new_stmt, loc);
+  gsi_insert_on_edge (e, new_stmt);
 
   if (dump_file && (dump_flags & TDF_DETAILS))
     {
-      fprintf (dump_file, "Inserting in block %d: ", insert_bb->index);
+      fprintf (dump_file, "Inserting on edge %d->%d: ", e->src->index,
+	       e->dest->index);
       print_gimple_stmt (dump_file, new_stmt, 0, 0);
     }
 
@@ -3136,6 +3129,23 @@
 	 that block, the earliest one will be returned in WHERE.  */
       bb = nearest_common_dominator_for_cands (c, incr, &where);
 
+      /* If the NCD is not dominated by the block containing the
+	 definition of the stride, we can't legally insert a
+	 single initializer.  Mark the increment as unprofitable
+	 so we don't make any replacements.  FIXME: Multiple
+	 initializers could be placed with more analysis.  */
+      gimple *stride_def = SSA_NAME_DEF_STMT (c->stride);
+      basic_block stride_bb = gimple_bb (stride_def);
+
+      if (stride_bb && !dominated_by_p (CDI_DOMINATORS, bb, stride_bb))
+	{
+	  if (dump_file && (dump_flags & TDF_DETAILS))
+	    fprintf (dump_file,
+		     "Initializer #%d cannot be legally placed\n", i);
+	  incr_vec[i].cost = COST_INFINITE;
+	  continue;
+	}
+
       /* Create a new SSA name to hold the initializer's value.  */
       stride_type = TREE_TYPE (c->stride);
       new_name = make_temp_ssa_name (stride_type, NULL, "slsr");
@@ -3577,6 +3587,10 @@
 	  free (incr_vec);
 	}
     }
+
+  /* For conditional candidates, we may have uncommitted insertions
+     on edges to clean up.  */
+  gsi_commit_edge_inserts ();
 }
 
 namespace {
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-6-branch)
@@ -1,3 +1,10 @@
+2017-09-02  Janus Weil  <janus@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/81770
+	* expr.c (gfc_check_pointer_assign): Improve the check whether pointer
+	may outlive pointer target.
+
 2017-07-04  Release Manager
 
 	* GCC 6.4.0 released.
Index: gcc/fortran/expr.c
===================================================================
--- a/src/gcc/fortran/expr.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/fortran/expr.c	(.../branches/gcc-6-branch)
@@ -3768,7 +3768,8 @@
   if (warn_target_lifetime
       && rvalue->expr_type == EXPR_VARIABLE
       && !rvalue->symtree->n.sym->attr.save
-      && !attr.pointer && !rvalue->symtree->n.sym->attr.host_assoc
+      && !rvalue->symtree->n.sym->attr.pointer && !attr.pointer
+      && !rvalue->symtree->n.sym->attr.host_assoc
       && !rvalue->symtree->n.sym->attr.in_common
       && !rvalue->symtree->n.sym->attr.use_assoc
       && !rvalue->symtree->n.sym->attr.dummy)
Index: gcc/function.c
===================================================================
--- a/src/gcc/function.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/function.c	(.../branches/gcc-6-branch)
@@ -6068,13 +6068,19 @@
 
   try_shrink_wrapping (&entry_edge, &bb_flags, prologue_seq);
 
+  rtx_insn *split_prologue_insn = split_prologue_seq;
   if (split_prologue_seq != NULL_RTX)
     {
+      while (split_prologue_insn && !NONDEBUG_INSN_P (split_prologue_insn))
+	split_prologue_insn = NEXT_INSN (split_prologue_insn);
       insert_insn_on_edge (split_prologue_seq, orig_entry_edge);
       inserted = true;
     }
+  rtx_insn *prologue_insn = prologue_seq;
   if (prologue_seq != NULL_RTX)
     {
+      while (prologue_insn && !NONDEBUG_INSN_P (prologue_insn))
+	prologue_insn = NEXT_INSN (prologue_insn);
       insert_insn_on_edge (prologue_seq, entry_edge);
       inserted = true;
     }
@@ -6215,8 +6221,19 @@
       commit_edge_insertions ();
 
       /* Look for basic blocks within the prologue insns.  */
+      if (split_prologue_insn
+	  && BLOCK_FOR_INSN (split_prologue_insn) == NULL)
+	split_prologue_insn = NULL;
+      if (prologue_insn
+	  && BLOCK_FOR_INSN (prologue_insn) == NULL)
+	prologue_insn = NULL;
       blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));
       bitmap_clear (blocks);
+      if (split_prologue_insn)
+	bitmap_set_bit (blocks,
+			BLOCK_FOR_INSN (split_prologue_insn)->index);
+      if (prologue_insn)
+	bitmap_set_bit (blocks, BLOCK_FOR_INSN (prologue_insn)->index);
       bitmap_set_bit (blocks, entry_edge->dest->index);
       bitmap_set_bit (blocks, orig_entry_edge->dest->index);
       find_many_sub_basic_blocks (blocks);
Index: gcc/simplify-rtx.c
===================================================================
--- a/src/gcc/simplify-rtx.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/simplify-rtx.c	(.../branches/gcc-6-branch)
@@ -5235,34 +5235,14 @@
 	{
 	case LT:
 	  /* Optimize abs(x) < 0.0.  */
-	  if (!HONOR_SNANS (mode)
-	      && (!INTEGRAL_MODE_P (mode)
-		  || (!flag_wrapv && !flag_trapv && flag_strict_overflow)))
-	    {
-	      if (INTEGRAL_MODE_P (mode)
-		  && (issue_strict_overflow_warning
-		      (WARN_STRICT_OVERFLOW_CONDITIONAL)))
-		warning (OPT_Wstrict_overflow,
-			 ("assuming signed overflow does not occur when "
-			  "assuming abs (x) < 0 is false"));
-	       return const0_rtx;
-	    }
+	  if (!INTEGRAL_MODE_P (mode) && !HONOR_SNANS (mode))
+	    return const0_rtx;
 	  break;
 
 	case GE:
 	  /* Optimize abs(x) >= 0.0.  */
-	  if (!HONOR_NANS (mode)
-	      && (!INTEGRAL_MODE_P (mode)
-		  || (!flag_wrapv && !flag_trapv && flag_strict_overflow)))
-	    {
-	      if (INTEGRAL_MODE_P (mode)
-	          && (issue_strict_overflow_warning
-	    	  (WARN_STRICT_OVERFLOW_CONDITIONAL)))
-	        warning (OPT_Wstrict_overflow,
-			 ("assuming signed overflow does not occur when "
-			  "assuming abs (x) >= 0 is true"));
-	      return const_true_rtx;
-	    }
+	  if (!INTEGRAL_MODE_P (mode) && !HONOR_NANS (mode))
+	    return const_true_rtx;
 	  break;
 
 	case UNGE:
Index: gcc/ubsan.c
===================================================================
--- a/src/gcc/ubsan.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/ubsan.c	(.../branches/gcc-6-branch)
@@ -380,6 +380,7 @@
     /* We weren't able to determine the type name.  */
     tname = "<unknown>";
 
+  tree eltype = type;
   if (pstyle == UBSAN_PRINT_POINTER)
     {
       pp_printf (&pretty_name, "'%s%s%s%s%s%s%s",
@@ -430,12 +431,12 @@
       pp_quote (&pretty_name);
 
       /* Save the tree with stripped types.  */
-      type = t;
+      eltype = t;
     }
   else
     pp_printf (&pretty_name, "'%s'", tname);
 
-  switch (TREE_CODE (type))
+  switch (TREE_CODE (eltype))
     {
     case BOOLEAN_TYPE:
     case ENUMERAL_TYPE:
@@ -445,9 +446,9 @@
     case REAL_TYPE:
       /* FIXME: libubsan right now only supports float, double and
 	 long double type formats.  */
-      if (TYPE_MODE (type) == TYPE_MODE (float_type_node)
-	  || TYPE_MODE (type) == TYPE_MODE (double_type_node)
-	  || TYPE_MODE (type) == TYPE_MODE (long_double_type_node))
+      if (TYPE_MODE (eltype) == TYPE_MODE (float_type_node)
+	  || TYPE_MODE (eltype) == TYPE_MODE (double_type_node)
+	  || TYPE_MODE (eltype) == TYPE_MODE (long_double_type_node))
 	tkind = 0x0001;
       else
 	tkind = 0xffff;
@@ -456,7 +457,7 @@
       tkind = 0xffff;
       break;
     }
-  tinfo = get_ubsan_type_info_for_type (type);
+  tinfo = get_ubsan_type_info_for_type (eltype);
 
   /* Create a new VAR_DECL of type descriptor.  */
   const char *tmp = pp_formatted_text (&pretty_name);
Index: gcc/tree-vect-stmts.c
===================================================================
--- a/src/gcc/tree-vect-stmts.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/tree-vect-stmts.c	(.../branches/gcc-6-branch)
@@ -5317,6 +5317,12 @@
 
   op = gimple_assign_rhs1 (stmt);
 
+  /* In the case this is a store from a STRING_CST make sure
+     native_encode_expr can handle it.  */
+  if (TREE_CODE (op) == STRING_CST
+      && ! can_native_encode_string_p (op))
+    return false;
+
   if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt, &rhs_vectype))
     {
       if (dump_enabled_p ())
Index: gcc/bb-reorder.c
===================================================================
--- a/src/gcc/bb-reorder.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/bb-reorder.c	(.../branches/gcc-6-branch)
@@ -2905,7 +2905,8 @@
 
   crossing_edges = find_rarely_executed_basic_blocks_and_crossing_edges ();
   if (!crossing_edges.exists ())
-    return 0;
+    /* Make sure to process deferred rescans and clear changeable df flags.  */
+    return TODO_df_finish;
 
   crtl->has_bb_partition = true;
 
@@ -2971,7 +2972,8 @@
       df_analyze ();
     }
 
-  return 0;
+  /* Make sure to process deferred rescans and clear changeable df flags.  */
+  return TODO_df_finish;
 }
 
 } // anon namespace
Index: gcc/hsa-brig.c
===================================================================
--- a/src/gcc/hsa-brig.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/hsa-brig.c	(.../branches/gcc-6-branch)
@@ -492,7 +492,7 @@
 	  else
 	    part++;
 	  char *modname2;
-	  asprintf (&modname2, "%s_%s", modname, part);
+	  modname2 = xasprintf ("%s_%s", modname, part);
 	  free (modname);
 	  modname = modname2;
 	}
Index: gcc/opts-global.c
===================================================================
--- a/src/gcc/opts-global.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/opts-global.c	(.../branches/gcc-6-branch)
@@ -167,7 +167,8 @@
 		    unsigned int lang_mask ATTRIBUTE_UNUSED, int kind,
 		    location_t loc,
 		    const struct cl_option_handlers *handlers,
-		    diagnostic_context *dc)
+		    diagnostic_context *dc,
+		    void (*) (void))
 {
   gcc_assert (opts == &global_options);
   gcc_assert (opts_set == &global_options_set);
@@ -267,10 +268,12 @@
 /* Set *HANDLERS to the default set of option handlers for use in the
    compilers proper (not the driver).  */
 void
-set_default_handlers (struct cl_option_handlers *handlers)
+set_default_handlers (struct cl_option_handlers *handlers,
+		      void (*target_option_override_hook) (void))
 {
   handlers->unknown_option_callback = unknown_option_callback;
   handlers->wrong_lang_callback = complain_wrong_lang;
+  handlers->target_option_override_hook = target_option_override_hook;
   handlers->num_handlers = 3;
   handlers->handlers[0].handler = lang_handle_option;
   handlers->handlers[0].mask = initial_lang_mask;
@@ -288,7 +291,8 @@
 decode_options (struct gcc_options *opts, struct gcc_options *opts_set,
 		struct cl_decoded_option *decoded_options,
 		unsigned int decoded_options_count,
-		location_t loc, diagnostic_context *dc)
+		location_t loc, diagnostic_context *dc,
+		void (*target_option_override_hook) (void))
 {
   struct cl_option_handlers handlers;
 
@@ -296,7 +300,7 @@
 
   lang_mask = initial_lang_mask;
 
-  set_default_handlers (&handlers);
+  set_default_handlers (&handlers, target_option_override_hook);
 
   default_options_optimization (opts, opts_set,
 				decoded_options, decoded_options_count,
Index: gcc/tree-ssa-structalias.c
===================================================================
--- a/src/gcc/tree-ssa-structalias.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/tree-ssa-structalias.c	(.../branches/gcc-6-branch)
@@ -2833,7 +2833,6 @@
 {
   const char *res = NULL;
   char *temp;
-  int num_printed = 0;
 
   if (!dump_file)
     return "NULL";
@@ -2842,14 +2841,11 @@
     {
       res = get_name (decl);
       if (res)
-	num_printed = asprintf (&temp, "%s_%u", res, SSA_NAME_VERSION (decl));
+	temp = xasprintf ("%s_%u", res, SSA_NAME_VERSION (decl));
       else
-	num_printed = asprintf (&temp, "_%u", SSA_NAME_VERSION (decl));
-      if (num_printed > 0)
-	{
-	  res = ggc_strdup (temp);
-	  free (temp);
-	}
+	temp = xasprintf ("_%u", SSA_NAME_VERSION (decl));
+      res = ggc_strdup (temp);
+      free (temp);
     }
   else if (DECL_P (decl))
     {
@@ -2860,12 +2856,9 @@
 	  res = get_name (decl);
 	  if (!res)
 	    {
-	      num_printed = asprintf (&temp, "D.%u", DECL_UID (decl));
-	      if (num_printed > 0)
-		{
-		  res = ggc_strdup (temp);
-		  free (temp);
-		}
+	      temp = xasprintf ("D.%u", DECL_UID (decl));
+	      res = ggc_strdup (temp);
+	      free (temp);
 	    }
 	}
     }
Index: gcc/tree-cfg.c
===================================================================
--- a/src/gcc/tree-cfg.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/tree-cfg.c	(.../branches/gcc-6-branch)
@@ -6527,7 +6527,15 @@
 		*tp = t = out->to;
 	    }
 
-	  DECL_CONTEXT (t) = p->to_context;
+	  /* For FORCED_LABELs we can end up with references from other
+	     functions if some SESE regions are outlined.  It is UB to
+	     jump in between them, but they could be used just for printing
+	     addresses etc.  In that case, DECL_CONTEXT on the label should
+	     be the function containing the glabel stmt with that LABEL_DECL,
+	     rather than whatever function a reference to the label was seen
+	     last time.  */
+	  if (!FORCED_LABEL (t) && !DECL_NONLOCAL (t))
+	    DECL_CONTEXT (t) = p->to_context;
 	}
       else if (p->remap_decls_p)
 	{
@@ -6646,6 +6654,21 @@
     case GIMPLE_OMP_RETURN:
     case GIMPLE_OMP_CONTINUE:
       break;
+
+    case GIMPLE_LABEL:
+      {
+	/* For FORCED_LABEL, move_stmt_op doesn't adjust DECL_CONTEXT,
+	   so that such labels can be referenced from other regions.
+	   Make sure to update it when seeing a GIMPLE_LABEL though,
+	   that is the owner of the label.  */
+	walk_gimple_op (stmt, move_stmt_op, wi);
+	*handled_ops_p = true;
+	tree label = gimple_label_label (as_a <glabel *> (stmt));
+	if (FORCED_LABEL (label) || DECL_NONLOCAL (label))
+	  DECL_CONTEXT (label) = p->to_context;
+      }
+      break;
+
     default:
       if (is_gimple_omp (stmt))
 	{
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- a/src/gcc/tree-ssa-reassoc.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/tree-ssa-reassoc.c	(.../branches/gcc-6-branch)
@@ -3710,11 +3710,15 @@
 
 /* Recursively rewrite our linearized statements so that the operators
    match those in OPS[OPINDEX], putting the computation in rank
-   order.  Return new lhs.  */
+   order.  Return new lhs.
+   CHANGED is true if we shouldn't reuse the lhs SSA_NAME both in
+   the current stmt and during recursive invocations.
+   NEXT_CHANGED is true if we shouldn't reuse the lhs SSA_NAME in
+   recursive invocations.  */
 
 static tree
 rewrite_expr_tree (gimple *stmt, unsigned int opindex,
-		   vec<operand_entry *> ops, bool changed)
+		   vec<operand_entry *> ops, bool changed, bool next_changed)
 {
   tree rhs1 = gimple_assign_rhs1 (stmt);
   tree rhs2 = gimple_assign_rhs2 (stmt);
@@ -3794,7 +3798,8 @@
      be the non-leaf side.  */
   tree new_rhs1
     = rewrite_expr_tree (SSA_NAME_DEF_STMT (rhs1), opindex + 1, ops,
-			 changed || oe->op != rhs2);
+			 changed || oe->op != rhs2 || next_changed,
+			 false);
 
   if (oe->op != rhs2 || new_rhs1 != rhs1)
     {
@@ -5115,6 +5120,7 @@
 	      gimple_set_visited (stmt, true);
 	      linearize_expr_tree (&ops, stmt, true, true);
 	      ops.qsort (sort_by_operand_rank);
+	      int orig_len = ops.length ();
 	      optimize_ops_list (rhs_code, &ops);
 	      if (undistribute_ops_list (rhs_code, &ops,
 					 loop_containing_stmt (stmt)))
@@ -5179,7 +5185,8 @@
                         swap_ops_for_binary_stmt (ops, len - 3, stmt);
 
 		      new_lhs = rewrite_expr_tree (stmt, 0, ops,
-						   powi_result != NULL);
+						   powi_result != NULL,
+						   len != orig_len);
                     }
 
 		  /* If we combined some repeated factors into a 
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-6-branch)
@@ -5393,7 +5393,7 @@
 (define_expand "floatunsdisf2"
   [(use (match_operand:SF 0 "register_operand"))
    (use (match_operand:DI 1 "nonimmediate_operand"))]
-  "TARGET_64BIT && TARGET_SSE_MATH"
+  "TARGET_64BIT && TARGET_SSE && TARGET_SSE_MATH"
   "x86_emit_floatuns (operands); DONE;")
 
 (define_expand "floatunsdidf2"
@@ -7415,21 +7415,15 @@
 		(match_operand:XF 2 "register_operand")))]
   "TARGET_80387")
 
-(define_expand "divdf3"
-  [(set (match_operand:DF 0 "register_operand")
- 	(div:DF (match_operand:DF 1 "register_operand")
- 		(match_operand:DF 2 "nonimmediate_operand")))]
-   "(TARGET_80387 && X87_ENABLE_ARITH (DFmode))
-    || (TARGET_SSE2 && TARGET_SSE_MATH)")
-
-(define_expand "divsf3"
-  [(set (match_operand:SF 0 "register_operand")
-	(div:SF (match_operand:SF 1 "register_operand")
-		(match_operand:SF 2 "nonimmediate_operand")))]
-  "(TARGET_80387 && X87_ENABLE_ARITH (SFmode))
-    || TARGET_SSE_MATH"
+(define_expand "div<mode>3"
+  [(set (match_operand:MODEF 0 "register_operand")
+	(div:MODEF (match_operand:MODEF 1 "register_operand")
+		   (match_operand:MODEF 2 "nonimmediate_operand")))]
+  "(TARGET_80387 && X87_ENABLE_ARITH (<MODE>mode))
+    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)"
 {
-  if (TARGET_SSE_MATH
+  if (<MODE>mode == SFmode
+      && TARGET_SSE && TARGET_SSE_MATH
       && TARGET_RECIP_DIV
       && optimize_insn_for_speed_p ()
       && flag_finite_math_only && !flag_trapping_math
@@ -10863,10 +10857,15 @@
   split_double_mode (<DWI>mode, &operands[0], 1, &operands[4], &operands[5]);
 })
 
+(define_mode_attr rorx_immediate_operand
+	[(SI "const_0_to_31_operand")
+	 (DI "const_0_to_63_operand")])
+
 (define_insn "*bmi2_rorx<mode>3_1"
   [(set (match_operand:SWI48 0 "register_operand" "=r")
-	(rotatert:SWI48 (match_operand:SWI48 1 "nonimmediate_operand" "rm")
-			(match_operand:QI 2 "immediate_operand" "<S>")))]
+	(rotatert:SWI48
+	  (match_operand:SWI48 1 "nonimmediate_operand" "rm")
+	  (match_operand:QI 2 "<rorx_immediate_operand>" "<S>")))]
   "TARGET_BMI2"
   "rorx\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "type" "rotatex")
@@ -10909,7 +10908,7 @@
 (define_split
   [(set (match_operand:SWI48 0 "register_operand")
 	(rotate:SWI48 (match_operand:SWI48 1 "nonimmediate_operand")
-		      (match_operand:QI 2 "immediate_operand")))
+		      (match_operand:QI 2 "const_int_operand")))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_BMI2 && reload_completed"
   [(set (match_dup 0)
@@ -10923,7 +10922,7 @@
 (define_split
   [(set (match_operand:SWI48 0 "register_operand")
 	(rotatert:SWI48 (match_operand:SWI48 1 "nonimmediate_operand")
-			(match_operand:QI 2 "immediate_operand")))
+			(match_operand:QI 2 "const_int_operand")))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_BMI2 && reload_completed"
   [(set (match_dup 0)
@@ -10933,7 +10932,7 @@
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
 	  (rotatert:SI (match_operand:SI 1 "nonimmediate_operand" "rm")
-		       (match_operand:QI 2 "immediate_operand" "I"))))]
+		       (match_operand:QI 2 "const_0_to_31_operand" "I"))))]
   "TARGET_64BIT && TARGET_BMI2"
   "rorx\t{%2, %1, %k0|%k0, %1, %2}"
   [(set_attr "type" "rotatex")
@@ -10977,7 +10976,7 @@
   [(set (match_operand:DI 0 "register_operand")
 	(zero_extend:DI
 	  (rotate:SI (match_operand:SI 1 "nonimmediate_operand")
-		     (match_operand:QI 2 "immediate_operand"))))
+		     (match_operand:QI 2 "const_int_operand"))))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && TARGET_BMI2 && reload_completed"
   [(set (match_dup 0)
@@ -10992,7 +10991,7 @@
   [(set (match_operand:DI 0 "register_operand")
 	(zero_extend:DI
 	  (rotatert:SI (match_operand:SI 1 "nonimmediate_operand")
-		       (match_operand:QI 2 "immediate_operand"))))
+		       (match_operand:QI 2 "const_int_operand"))))
    (clobber (reg:CC FLAGS_REG))]
   "TARGET_64BIT && TARGET_BMI2 && reload_completed"
   [(set (match_dup 0)
@@ -11879,7 +11878,8 @@
 	(zero_extend (match_dup 1)))]
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
-   && ! reg_overlap_mentioned_p (operands[3], operands[0])"
+   && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && peep2_regno_dead_p (0, FLAGS_REG)"
   [(set (match_dup 4) (match_dup 0))
    (set (strict_low_part (match_dup 5))
 	(match_dup 2))]
@@ -11900,7 +11900,8 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
-   && ! reg_set_p (operands[3], operands[4])"
+   && ! reg_set_p (operands[3], operands[4])
+   && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
 	      (match_dup 4)])
    (set (strict_low_part (match_dup 6))
@@ -11922,7 +11923,8 @@
 		   (and:SI (match_dup 3) (const_int 255)))
 	      (clobber (reg:CC FLAGS_REG))])]
   "REGNO (operands[1]) == REGNO (operands[3])
-   && ! reg_overlap_mentioned_p (operands[3], operands[0])"
+   && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && peep2_regno_dead_p (0, FLAGS_REG)"
   [(set (match_dup 4) (match_dup 0))
    (set (strict_low_part (match_dup 5))
 	(match_dup 2))]
@@ -11944,7 +11946,8 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
-   && ! reg_set_p (operands[3], operands[4])"
+   && ! reg_set_p (operands[3], operands[4])
+   && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
 	      (match_dup 4)])
    (set (strict_low_part (match_dup 6))
@@ -14223,7 +14226,7 @@
   [(set (match_operand:SF 0 "register_operand" "=x")
 	(unspec:SF [(match_operand:SF 1 "nonimmediate_operand" "xm")]
 		   UNSPEC_RCP))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
   "%vrcpss\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
    (set_attr "atom_sse_attr" "rcp")
@@ -14548,7 +14551,7 @@
   [(set (match_operand:SF 0 "register_operand" "=x")
 	(unspec:SF [(match_operand:SF 1 "nonimmediate_operand" "xm")]
 		   UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
   "%vrsqrtss\t{%1, %d0|%d0, %1}"
   [(set_attr "type" "sse")
    (set_attr "atom_sse_attr" "rcp")
@@ -14560,7 +14563,7 @@
   [(set (match_operand:SF 0 "register_operand")
 	(unspec:SF [(match_operand:SF 1 "nonimmediate_operand")]
 		   UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
 {
   ix86_emit_swsqrtsf (operands[0], operands[1], SFmode, 1);
   DONE;
@@ -14589,7 +14592,7 @@
    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)"
 {
   if (<MODE>mode == SFmode
-      && TARGET_SSE_MATH
+      && TARGET_SSE && TARGET_SSE_MATH
       && TARGET_RECIP_SQRT
       && !optimize_function_for_size_p (cfun)
       && flag_finite_math_only && !flag_trapping_math
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-6-branch)
@@ -7230,12 +7230,13 @@
 (define_insn "vec_extract_lo_<mode><mask_name>"
   [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=<store_mask_constraint>,v")
 	(vec_select:<ssehalfvecmode>
-	  (match_operand:V8FI 1 "nonimmediate_operand" "v,m")
+	  (match_operand:V8FI 1 "<store_mask_predicate>" "v,<store_mask_constraint>")
 	  (parallel [(const_int 0) (const_int 1)
             (const_int 2) (const_int 3)])))]
-  "TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+  "TARGET_AVX512F
+   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))"
 {
-  if (<mask_applied> || !TARGET_AVX512VL)
+  if (<mask_applied> || (!TARGET_AVX512VL && !MEM_P (operands[1])))
     return "vextract<shuffletype>64x4\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}";
   else
     return "#";
@@ -7374,7 +7375,8 @@
 (define_insn "vec_extract_lo_<mode><mask_name>"
   [(set (match_operand:<ssehalfvecmode> 0 "nonimmediate_operand" "=v,m")
 	(vec_select:<ssehalfvecmode>
-	  (match_operand:V16FI 1 "nonimmediate_operand" "vm,v")
+	  (match_operand:V16FI 1 "<store_mask_predicate>"
+				 "<store_mask_constraint>,v")
 	  (parallel [(const_int 0) (const_int 1)
                      (const_int 2) (const_int 3)
                      (const_int 4) (const_int 5)
@@ -7381,7 +7383,7 @@
                      (const_int 6) (const_int 7)])))]
   "TARGET_AVX512F
    && <mask_mode512bit_condition>
-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))"
 {
   if (<mask_applied>)
     return "vextract<shuffletype>32x8\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}";
@@ -7413,11 +7415,12 @@
 (define_insn "vec_extract_lo_<mode><mask_name>"
   [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=v,m")
 	(vec_select:<ssehalfvecmode>
-	  (match_operand:VI8F_256 1 "nonimmediate_operand" "vm,v")
+	  (match_operand:VI8F_256 1 "<store_mask_predicate>"
+				    "<store_mask_constraint>,v")
 	  (parallel [(const_int 0) (const_int 1)])))]
   "TARGET_AVX
    && <mask_avx512vl_condition> && <mask_avx512dq_condition>
-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
+   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))"
 {
   if (<mask_applied>)
     return "vextract<shuffletype>64x2\t{$0x0, %1, %0%{%3%}|%0%{%3%}, %1, 0x0}";
@@ -7493,12 +7496,16 @@
 
 
 (define_insn "vec_extract_lo_<mode><mask_name>"
-  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>" "=<store_mask_constraint>")
+  [(set (match_operand:<ssehalfvecmode> 0 "<store_mask_predicate>"
+					  "=<store_mask_constraint>,v")
 	(vec_select:<ssehalfvecmode>
-	  (match_operand:VI4F_256 1 "register_operand" "v")
+	  (match_operand:VI4F_256 1 "<store_mask_predicate>"
+				    "v,<store_mask_constraint>")
 	  (parallel [(const_int 0) (const_int 1)
 		     (const_int 2) (const_int 3)])))]
-  "TARGET_AVX && <mask_avx512vl_condition> && <mask_avx512dq_condition>"
+  "TARGET_AVX
+   && <mask_avx512vl_condition> && <mask_avx512dq_condition>
+   && (<mask_applied> || !(MEM_P (operands[0]) && MEM_P (operands[1])))"
 {
   if (<mask_applied>)
     return "vextract<shuffletype>32x4\t{$0x0, %1, %0<mask_operand2>|%0<mask_operand2>, %1, 0x0}";
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-6-branch)
@@ -5196,6 +5196,12 @@
     opts->x_ix86_isa_flags
       |= OPTION_MASK_ISA_LZCNT & ~opts->x_ix86_isa_flags_explicit;
 
+  /* Disable BMI, BMI2 and TBM instructions for -m16.  */
+  if (TARGET_16BIT_P(opts->x_ix86_isa_flags))
+    opts->x_ix86_isa_flags
+      &= ~((OPTION_MASK_ISA_BMI | OPTION_MASK_ISA_BMI2 | OPTION_MASK_ISA_TBM)
+	   & ~opts->x_ix86_isa_flags_explicit);
+
   /* Validate -mpreferred-stack-boundary= value or default it to
      PREFERRED_STACK_BOUNDARY_DEFAULT.  */
   ix86_preferred_stack_boundary = PREFERRED_STACK_BOUNDARY_DEFAULT;
@@ -5552,12 +5558,6 @@
   gcc_assert ((opts->x_target_flags & MASK_LONG_DOUBLE_64) == 0
 	      || (opts->x_target_flags & MASK_LONG_DOUBLE_128) == 0);
 
-  /* Save the initial options in case the user does function specific
-     options.  */
-  if (main_args_p)
-    target_option_default_node = target_option_current_node
-      = build_target_option_node (opts);
-
   /* Handle stack protector */
   if (!opts_set->x_ix86_stack_protector_guard)
     opts->x_ix86_stack_protector_guard
@@ -5577,6 +5577,12 @@
       ix86_parse_stringop_strategy_string (str, true);
       free (str);
     }
+
+  /* Save the initial options in case the user does function specific
+     options.  */
+  if (main_args_p)
+    target_option_default_node = target_option_current_node
+      = build_target_option_node (opts);
 }
 
 /* Implement the TARGET_OPTION_OVERRIDE hook.  */
@@ -17521,7 +17527,7 @@
       /* Displacement only requires special attention.  */
       if (CONST_INT_P (disp))
 	{
-	  if (ASSEMBLER_DIALECT == ASM_INTEL && parts.seg == ADDR_SPACE_GENERIC)
+	  if (ASSEMBLER_DIALECT == ASM_INTEL && ADDR_SPACE_GENERIC_P (as))
 	    fputs ("ds:", file);
 	  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (disp));
 	}
@@ -36760,6 +36766,9 @@
     {
       const char *str = TREE_STRING_POINTER (TREE_VALUE (arg));
       size_t len = strlen (str);
+      /* Skip empty string.  */
+      if (len == 0)
+	continue;
       str_len_sum += len + 1;
       if (arg != arglist)
 	argnum++;
@@ -36774,11 +36783,21 @@
     {
       const char *str = TREE_STRING_POINTER (TREE_VALUE (arg));
       size_t len = strlen (str);
+      /* Skip empty string.  */
+      if (len == 0)
+	continue;
       memcpy (attr_str + str_len_sum, str, len);
       attr_str[str_len_sum + len] = TREE_CHAIN (arg) ? ',' : '\0';
       str_len_sum += len + 1;
     }
 
+  /* Strip ',' character at the end.  */
+  if (str_len_sum > 0 && attr_str[str_len_sum - 1] == ',')
+    {
+      attr_str[str_len_sum - 1] = '\0';
+      str_len_sum--;
+    }
+
   /* Replace "=,-" with "_".  */
   for (i = 0; i < strlen (attr_str); i++)
     if (attr_str[i] == '=' || attr_str[i]== '-')
@@ -37395,6 +37414,7 @@
     M_INTEL_KNL,
     M_AMD_BTVER1,
     M_AMD_BTVER2,    
+    M_AMDFAM17H,
     M_CPU_SUBTYPE_START,
     M_INTEL_COREI7_NEHALEM,
     M_INTEL_COREI7_WESTMERE,
@@ -37449,6 +37469,7 @@
       {"bdver3", M_AMDFAM15H_BDVER3},
       {"bdver4", M_AMDFAM15H_BDVER4},
       {"btver2", M_AMD_BTVER2},
+      {"amdfam17h", M_AMDFAM17H},
       {"znver1", M_AMDFAM17H_ZNVER1},
     };
 
Index: gcc/config/sol2.h
===================================================================
--- a/src/gcc/config/sol2.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/sol2.h	(.../branches/gcc-6-branch)
@@ -159,9 +159,9 @@
 			    %{!ansi:values-Xa.o%s}"
 
 #if defined(HAVE_LD_PIE) && defined(HAVE_SOLARIS_CRTS)
-#define STARTFILE_CRTBEGIN_SPEC "%{shared:crtbeginS.o%s} \
-				 %{" PIE_SPEC ":crtbeginS.o%s} \
-				 %{" NO_PIE_SPEC ":crtbegin.o%s}"
+#define STARTFILE_CRTBEGIN_SPEC "%{static:crtbegin.o%s; \
+				   shared|" PIE_SPEC ":crtbeginS.o%s; \
+				   :crtbegin.o%s}"
 #else
 #define STARTFILE_CRTBEGIN_SPEC	"crtbegin.o%s"
 #endif
@@ -204,9 +204,9 @@
 #endif
 
 #if defined(HAVE_LD_PIE) && defined(HAVE_SOLARIS_CRTS)
-#define ENDFILE_CRTEND_SPEC "%{shared:crtendS.o%s;: \
-			       %{" PIE_SPEC ":crtendS.o%s} \
-			       %{" NO_PIE_SPEC ":crtend.o%s}}"
+#define ENDFILE_CRTEND_SPEC "%{static:crtend.o%s; \
+			       shared|" PIE_SPEC ":crtendS.o%s; \
+			       :crtend.o%s}"
 #else
 #define ENDFILE_CRTEND_SPEC "crtend.o%s"
 #endif
Index: gcc/config/avr/avr.opt
===================================================================
--- a/src/gcc/config/avr/avr.opt	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/avr/avr.opt	(.../branches/gcc-6-branch)
@@ -91,6 +91,10 @@
 Warning C Report Var(avr_warn_addr_space_convert) Init(0)
 Warn if the address space of an address is changed.
 
+Wmisspelled-isr
+Warning C C++ Report Var(avr_warn_misspelled_isr) Init(1)
+Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default.
+
 mfract-convert-truncate
 Target Report Mask(FRACT_CONV_TRUNC)
 Allow to use truncation instead of rounding towards 0 for fractional int types.
Index: gcc/config/avr/avr.c
===================================================================
--- a/src/gcc/config/avr/avr.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/avr/avr.c	(.../branches/gcc-6-branch)
@@ -735,12 +735,6 @@
 
       name = default_strip_name_encoding (name);
 
-      /* Silently ignore 'signal' if 'interrupt' is present.  AVR-LibC startet
-         using this when it switched from SIGNAL and INTERRUPT to ISR.  */
-
-      if (cfun->machine->is_interrupt)
-        cfun->machine->is_signal = 0;
-
       /* Interrupt handlers must be  void __vector (void)  functions.  */
 
       if (args && TREE_CODE (TREE_VALUE (args)) != VOID_TYPE)
@@ -749,15 +743,37 @@
       if (TREE_CODE (ret) != VOID_TYPE)
         error_at (loc, "%qs function cannot return a value", isr);
 
+#if defined WITH_AVRLIBC
+      /* Silently ignore 'signal' if 'interrupt' is present.  AVR-LibC startet
+         using this when it switched from SIGNAL and INTERRUPT to ISR.  */
+
+      if (cfun->machine->is_interrupt)
+        cfun->machine->is_signal = 0;
+
       /* If the function has the 'signal' or 'interrupt' attribute, ensure
          that the name of the function is "__vector_NN" so as to catch
          when the user misspells the vector name.  */
 
       if (!STR_PREFIX_P (name, "__vector"))
-        warning_at (loc, 0, "%qs appears to be a misspelled %s handler",
-                    name, isr);
+        warning_at (loc, OPT_Wmisspelled_isr, "%qs appears to be a misspelled "
+                    "%qs handler, missing %<__vector%> prefix", name, isr);
+#endif // AVR-LibC naming conventions
     }
 
+#if defined WITH_AVRLIBC
+  // Common problem is using "ISR" without first including avr/interrupt.h.
+  const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));
+  name = default_strip_name_encoding (name);
+  if (0 == strcmp ("ISR", name)
+      || 0 == strcmp ("INTERRUPT", name)
+      || 0 == strcmp ("SIGNAL", name))
+    {
+      warning_at (loc, OPT_Wmisspelled_isr, "%qs is a reserved identifier"
+                  " in AVR-LibC.  Consider %<#include <avr/interrupt.h>%>"
+                  " before using the %qs macro", name, name);
+    }
+#endif // AVR-LibC naming conventions
+
   /* Don't print the above diagnostics more than once.  */
 
   cfun->machine->attributes_checked_p = 1;
@@ -3490,7 +3506,7 @@
   if (CONSTANT_ADDRESS_P (x))
     {
       int n_words = AVR_TINY ? 1 : 2;
-      return optimize > 0 && io_address_operand (x, QImode)
+      return io_address_operand (x, QImode)
         ? avr_asm_len ("in %0,%i1", op, plen, -1)
         : avr_asm_len ("lds %0,%m1", op, plen, -n_words);
     }
@@ -3745,7 +3761,7 @@
   else if (CONSTANT_ADDRESS_P (base))
     {
       int n_words = AVR_TINY ? 2 : 4;
-      return optimize > 0 && io_address_operand (base, HImode)
+      return io_address_operand (base, HImode)
         ? avr_asm_len ("in %A0,%i1" CR_TAB
                        "in %B0,%i1+1", op, plen, -2)
 
@@ -4873,7 +4889,7 @@
   if (CONSTANT_ADDRESS_P (x))
     {
       int n_words = AVR_TINY ? 1 : 2;
-      return optimize > 0 && io_address_operand (x, QImode)
+      return io_address_operand (x, QImode)
         ? avr_asm_len ("out %i0,%1", op, plen, -1)
         : avr_asm_len ("sts %m0,%1", op, plen, -n_words);
     }
@@ -4949,13 +4965,12 @@
 
   if (CONSTANT_ADDRESS_P (base))
     {
-      int n_words = AVR_TINY ? 2 : 4;
-      return optimize > 0 && io_address_operand (base, HImode)
+      return io_address_operand (base, HImode)
         ? avr_asm_len ("out %i0,%A1" CR_TAB
                        "out %i0+1,%B1", op, plen, -2)
 
         : avr_asm_len ("sts %m0,%A1" CR_TAB
-                       "sts %m0+1,%B1", op, plen, -n_words);
+                       "sts %m0+1,%B1", op, plen, -4);
     }
 
   if (reg_base > 0)
@@ -5132,7 +5147,7 @@
   if (CONSTANT_ADDRESS_P (base))
     {
       int n_words = AVR_TINY ? 2 : 4;
-      return optimize > 0 && io_address_operand (base, HImode)
+      return io_address_operand (base, HImode)
         ? avr_asm_len ("out %i0+1,%B1" CR_TAB
                        "out %i0,%A1", op, plen, -2)
 
@@ -9055,10 +9070,12 @@
   bool io_p = (strncmp (IDENTIFIER_POINTER (name), "io", 2) == 0);
   location_t loc = DECL_SOURCE_LOCATION (*node);
 
-  if (TREE_CODE (*node) != VAR_DECL)
+  if (!VAR_P (*node))
     {
-      warning_at (loc, 0, "%qE attribute only applies to variables", name);
+      warning_at (loc, OPT_Wattributes, "%qE attribute only applies to "
+		  "variables", name);
       *no_add = true;
+      return NULL_TREE;
     }
 
   if (args != NULL_TREE)
@@ -9068,8 +9085,8 @@
       tree arg = TREE_VALUE (args);
       if (TREE_CODE (arg) != INTEGER_CST)
 	{
-	  warning (0, "%qE attribute allows only an integer constant argument",
-		   name);
+	  warning_at (loc, OPT_Wattributes, "%qE attribute allows only an "
+		      "integer constant argument", name);
 	  *no_add = true;
 	}
       else if (io_p
@@ -9078,19 +9095,20 @@
 			? low_io_address_operand : io_address_operand)
 			 (GEN_INT (TREE_INT_CST_LOW (arg)), QImode)))
 	{
-	  warning_at (loc, 0, "%qE attribute address out of range", name);
+	  warning_at (loc, OPT_Wattributes, "%qE attribute address "
+		      "out of range", name);
 	  *no_add = true;
 	}
       else
 	{
 	  tree attribs = DECL_ATTRIBUTES (*node);
-	  const char *names[] = { "io", "io_low", "address", NULL } ;
+	  const char *names[] = { "io", "io_low", "address", NULL };
 	  for (const char **p = names; *p; p++)
 	    {
 	      tree other = lookup_attribute (*p, attribs);
 	      if (other && TREE_VALUE (other))
 		{
-		  warning_at (loc, 0,
+		  warning_at (loc, OPT_Wattributes,
 			      "both %s and %qE attribute provide address",
 			      *p, name);
 		  *no_add = true;
@@ -9101,7 +9119,8 @@
     }
 
   if (*no_add == false && io_p && !TREE_THIS_VOLATILE (*node))
-    warning_at (loc, 0, "%qE attribute on non-volatile variable", name);
+    warning_at (loc, OPT_Wattributes, "%qE attribute on non-volatile variable",
+		name);
 
   return NULL_TREE;
 }
@@ -9149,11 +9168,11 @@
     false },
   { "OS_main",   0, 0, false, true,  true,   avr_handle_fntype_attribute,
     false },
-  { "io",        0, 1, false, false, false,  avr_handle_addr_attribute,
+  { "io",        0, 1, true, false, false,  avr_handle_addr_attribute,
     false },
-  { "io_low",    0, 1, false, false, false,  avr_handle_addr_attribute,
+  { "io_low",    0, 1, true, false, false,  avr_handle_addr_attribute,
     false },
-  { "address",   1, 1, false, false, false,  avr_handle_addr_attribute,
+  { "address",   1, 1, true, false, false,  avr_handle_addr_attribute,
     false },
   { NULL,        0, 0, false, false, false, NULL, false }
 };
@@ -9591,18 +9610,26 @@
 
   if (new_decl_p
       && decl && DECL_P (decl)
-      && NULL_TREE == DECL_INITIAL (decl)
       && !DECL_EXTERNAL (decl)
       && avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))
     {
-      // Don't warn for (implicit) aliases like in PR80462.
-      tree asmname = DECL_ASSEMBLER_NAME (decl);
-      varpool_node *node = varpool_node::get_for_asmname (asmname);
-      bool alias_p = node && node->alias;
+      if (!TREE_READONLY (decl))
+        {
+          // This might happen with C++ if stuff needs constructing.
+          error ("variable %q+D with dynamic initialization put "
+                 "into program memory area", decl);
+        }
+      else if (NULL_TREE == DECL_INITIAL (decl))
+        {
+          // Don't warn for (implicit) aliases like in PR80462.
+          tree asmname = DECL_ASSEMBLER_NAME (decl);
+          varpool_node *node = varpool_node::get_for_asmname (asmname);
+          bool alias_p = node && node->alias;
 
-      if (!alias_p)
-        warning (OPT_Wuninitialized, "uninitialized variable %q+D put into "
-                 "program memory area", decl);
+          if (!alias_p)
+            warning (OPT_Wuninitialized, "uninitialized variable %q+D put "
+                     "into program memory area", decl);
+        }
     }
 
   default_encode_section_info (decl, rtl, new_decl_p);
@@ -9864,6 +9891,33 @@
 }
 
 
+/* Cost for mul highpart.  X is a LSHIFTRT, i.e. the outer TRUNCATE is
+   already stripped off.  */
+
+static int
+avr_mul_highpart_cost (rtx x, int)
+{
+  if (AVR_HAVE_MUL
+      && LSHIFTRT == GET_CODE (x)
+      && MULT == GET_CODE (XEXP (x, 0))
+      && CONST_INT_P (XEXP (x, 1)))
+    {
+      // This is the wider mode.
+      machine_mode mode = GET_MODE (x);
+  
+      // The middle-end might still have PR81444, i.e. it is calling the cost
+      // functions with strange modes.  Fix this now by also considering
+      // PSImode (should actually be SImode instead).
+      if (HImode == mode || PSImode == mode || SImode == mode)
+        {
+          return COSTS_N_INSNS (2);
+        }
+    }
+
+  return 10000;
+}
+
+
 /* Mutually recursive subroutine of avr_rtx_cost for calculating the
    cost of an RTX operand given its context.  X is the rtx of the
    operand, MODE is its mode, and OUTER is the rtx_code of this
@@ -9903,7 +9957,7 @@
    In either case, *TOTAL contains the cost result.  */
 
 static bool
-avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,
+avr_rtx_costs_1 (rtx x, machine_mode mode, int outer_code,
                  int opno ATTRIBUTE_UNUSED, int *total, bool speed)
 {
   enum rtx_code code = GET_CODE (x);
@@ -10544,6 +10598,12 @@
       return true;
 
     case LSHIFTRT:
+      if (outer_code == TRUNCATE)
+        {
+          *total = avr_mul_highpart_cost (x, speed);
+          return true;
+        }
+
       switch (mode)
 	{
 	case QImode:
@@ -10721,16 +10781,10 @@
       return true;
 
     case TRUNCATE:
-      if (AVR_HAVE_MUL
-          && LSHIFTRT == GET_CODE (XEXP (x, 0))
-          && MULT == GET_CODE (XEXP (XEXP (x, 0), 0))
-          && CONST_INT_P (XEXP (XEXP (x, 0), 1)))
+      if (LSHIFTRT == GET_CODE (XEXP (x, 0)))
         {
-          if (QImode == mode || HImode == mode)
-            {
-              *total = COSTS_N_INSNS (2);
-              return true;
-            }
+          *total = avr_mul_highpart_cost (XEXP (x, 0), speed);
+          return true;
         }
       break;
 
@@ -10779,8 +10833,7 @@
     }
   else if (CONSTANT_ADDRESS_P (x))
     {
-      if (optimize > 0
-          && io_address_operand (x, QImode))
+      if (io_address_operand (x, QImode))
         cost = 2;
     }
 
Index: gcc/config/xtensa/xtensa.c
===================================================================
--- a/src/gcc/config/xtensa/xtensa.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/xtensa/xtensa.c	(.../branches/gcc-6-branch)
@@ -601,6 +601,7 @@
     case HImode:
       return xtensa_uimm8x2 (v);
 
+    case DImode:
     case DFmode:
       return (xtensa_uimm8x4 (v) && xtensa_uimm8x4 (v + 4));
 
Index: gcc/config/gnu-user.h
===================================================================
--- a/src/gcc/config/gnu-user.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/gnu-user.h	(.../branches/gcc-6-branch)
@@ -50,11 +50,15 @@
 
 #if defined HAVE_LD_PIE
 #define GNU_USER_TARGET_STARTFILE_SPEC \
-  "%{!shared: %{pg|p|profile:gcrt1.o%s;: \
-    %{" PIE_SPEC ":Scrt1.o%s} %{" NO_PIE_SPEC ":crt1.o%s}}} \
-   crti.o%s %{static:crtbeginT.o%s;: %{shared:crtbeginS.o%s} \
-	      %{" PIE_SPEC ":crtbeginS.o%s} \
-	      %{" NO_PIE_SPEC ":crtbegin.o%s}} \
+  "%{shared:; \
+     pg|p|profile:gcrt1.o%s; \
+     static:crt1.o%s; \
+     " PIE_SPEC ":Scrt1.o%s; \
+     :crt1.o%s} \
+   crti.o%s \
+   %{static:crtbeginT.o%s; \
+     shared|" PIE_SPEC ":crtbeginS.o%s; \
+     :crtbegin.o%s} \
    %{fvtable-verify=none:%s; \
      fvtable-verify=preinit:vtv_start_preinit.o%s; \
      fvtable-verify=std:vtv_start.o%s} \
@@ -61,8 +65,13 @@
    " CRTOFFLOADBEGIN
 #else
 #define GNU_USER_TARGET_STARTFILE_SPEC \
-  "%{!shared: %{pg|p|profile:gcrt1.o%s;:crt1.o%s}} \
-   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \
+  "%{shared:; \
+     pg|p|profile:gcrt1.o%s; \
+     :crt1.o%s} \
+   crti.o%s \
+   %{static:crtbeginT.o%s; \
+     shared|pie:crtbeginS.o%s; \
+     :crtbegin.o%s} \
    %{fvtable-verify=none:%s; \
      fvtable-verify=preinit:vtv_start_preinit.o%s; \
      fvtable-verify=std:vtv_start.o%s} \
@@ -82,8 +91,10 @@
   "%{fvtable-verify=none:%s; \
      fvtable-verify=preinit:vtv_end_preinit.o%s; \
      fvtable-verify=std:vtv_end.o%s} \
-   %{shared:crtendS.o%s;: %{" PIE_SPEC ":crtendS.o%s} \
-   %{" NO_PIE_SPEC ":crtend.o%s}} crtn.o%s \
+   %{static:crtend.o%s; \
+     shared|" PIE_SPEC ":crtendS.o%s; \
+     :crtend.o%s} \
+   crtn.o%s \
    " CRTOFFLOADEND
 #else
 #define GNU_USER_TARGET_ENDFILE_SPEC \
@@ -90,7 +101,10 @@
   "%{fvtable-verify=none:%s; \
      fvtable-verify=preinit:vtv_end_preinit.o%s; \
      fvtable-verify=std:vtv_end.o%s} \
-   %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s \
+   %{static:crtend.o%s; \
+     shared|pie:crtendS.o%s; \
+     :crtend.o%s} \
+   crtn.o%s \
    " CRTOFFLOADEND
 #endif
 #undef  ENDFILE_SPEC
Index: gcc/config/aarch64/cortex-a57-fma-steering.c
===================================================================
--- a/src/gcc/config/aarch64/cortex-a57-fma-steering.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/aarch64/cortex-a57-fma-steering.c	(.../branches/gcc-6-branch)
@@ -973,10 +973,17 @@
 		break;
 	    }
 
-	  /* We didn't find a chain with a def for this instruction.  */
-	  gcc_assert (i < dest_op_info->n_chains);
-
-	  this->analyze_fma_fmul_insn (forest, chain, head);
+	  /* Due to implementation of regrename, dest register can slip away
+	     from regrename's analysis.  As a result, there is no chain for
+	     the destination register of insn.  We simply skip the insn even
+	     it is a fmul/fmac instruction.  This can happen when the dest
+	     register is also a source register of insn and one of the below
+	     conditions is satisfied:
+	       1) the source reg is setup in larger mode than this insn;
+	       2) the source reg is uninitialized;
+	       3) the source reg is passed in as parameter.  */
+	  if (i < dest_op_info->n_chains)
+	    this->analyze_fma_fmul_insn (forest, chain, head);
 	}
     }
   free (bb_dfs_preorder);
Index: gcc/config/aarch64/aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/aarch64/aarch64.c	(.../branches/gcc-6-branch)
@@ -1110,7 +1110,7 @@
 	    emit_move_insn (gp_rtx, gen_rtx_HIGH (Pmode, s));
 
 	    if (mode != GET_MODE (gp_rtx))
-	      gp_rtx = simplify_gen_subreg (mode, gp_rtx, GET_MODE (gp_rtx), 0);
+             gp_rtx = gen_lowpart (mode, gp_rtx);
 	  }
 
 	if (mode == ptr_mode)
Index: gcc/config/rs6000/power6.md
===================================================================
--- a/src/gcc/config/rs6000/power6.md	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/power6.md	(.../branches/gcc-6-branch)
@@ -108,7 +108,7 @@
                   power6-store-update-indexed,\
                   power6-fpstore,\
                   power6-fpstore-update"
-  "store_data_bypass_p")
+  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-load-ext" 4 ; fx
   (and (eq_attr "type" "load")
@@ -128,7 +128,7 @@
                   power6-store-update-indexed,\
                   power6-fpstore,\
                   power6-fpstore-update"
-  "store_data_bypass_p")
+  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-load-update" 2 ; fx
   (and (eq_attr "type" "load")
@@ -276,7 +276,7 @@
                   power6-store-update-indexed,\
                   power6-fpstore,\
                   power6-fpstore-update"
-  "store_data_bypass_p")
+  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-cntlz" 2
   (and (eq_attr "type" "cntlz")
@@ -289,7 +289,7 @@
                   power6-store-update-indexed,\
                   power6-fpstore,\
                   power6-fpstore-update"
-  "store_data_bypass_p")
+  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-var-rotate" 4
   (and (eq_attr "type" "shift")
@@ -355,7 +355,7 @@
                   power6-store-update-indexed,\
                   power6-fpstore,\
                   power6-fpstore-update"
-  "store_data_bypass_p")
+  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-delayed-compare" 2 ; N/A
   (and (eq_attr "type" "shift")
@@ -420,7 +420,7 @@
                   power6-store-update-indexed,\
                   power6-fpstore,\
                   power6-fpstore-update"
-  "store_data_bypass_p")
+  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-idiv" 44
   (and (eq_attr "type" "div")
@@ -436,7 +436,7 @@
 ;                  power6-store-update-indexed,\
 ;                  power6-fpstore,\
 ;                  power6-fpstore-update"
-;  "store_data_bypass_p")
+;  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-ldiv" 56
   (and (eq_attr "type" "div")
@@ -452,7 +452,7 @@
 ;                  power6-store-update-indexed,\
 ;                  power6-fpstore,\
 ;                  power6-fpstore-update"
-;  "store_data_bypass_p")
+;  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-mtjmpr" 2
   (and (eq_attr "type" "mtjmpr,mfjmpr")
@@ -510,7 +510,7 @@
 
 (define_bypass 1 "power6-fp"
                  "power6-fpstore,power6-fpstore-update"
-  "store_data_bypass_p")
+  "rs6000_store_data_bypass_p")
 
 (define_insn_reservation "power6-fpcompare" 8
   (and (eq_attr "type" "fpcompare")
Index: gcc/config/rs6000/rs6000-protos.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000-protos.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000-protos.h	(.../branches/gcc-6-branch)
@@ -216,6 +216,7 @@
 extern void rs6000_aix_asm_output_dwarf_table_ref (char *);
 extern void get_ppc476_thunk_name (char name[32]);
 extern bool rs6000_overloaded_builtin_p (enum rs6000_builtins);
+extern int rs6000_store_data_bypass_p (rtx_insn *, rtx_insn *);
 extern HOST_WIDE_INT rs6000_builtin_mask_calculate (void);
 extern void rs6000_asm_output_dwarf_pcrel (FILE *file, int size,
 					   const char *label);
Index: gcc/config/rs6000/ppc-auxv.h
===================================================================
--- a/src/gcc/config/rs6000/ppc-auxv.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/ppc-auxv.h	(.../branches/gcc-6-branch)
@@ -89,6 +89,8 @@
 #define PPC_FEATURE2_HTM_NOSC       0x01000000
 #define PPC_FEATURE2_ARCH_3_00      0x00800000
 #define PPC_FEATURE2_HAS_IEEE128    0x00400000
+#define PPC_FEATURE2_DARN           0x00200000
+#define PPC_FEATURE2_SCV            0x00100000
 
 
 /* Thread Control Block (TCB) offsets of the AT_PLATFORM, AT_HWCAP and
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-6-branch)
@@ -428,6 +428,9 @@
     builtin_define ("__FLOAT128__");
   if (TARGET_FLOAT128_HW)
     builtin_define ("__FLOAT128_HARDWARE__");
+#ifdef TARGET_LIBC_PROVIDES_HWCAP_IN_TCB
+  builtin_define ("__BUILTIN_CPU_SUPPORTS__");
+#endif
 
   if (TARGET_EXTRA_BUILTINS && cpp_get_options (pfile)->lang != CLK_ASM)
     {
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-6-branch)
@@ -365,7 +365,9 @@
   { "tar",		PPC_FEATURE2_HAS_TAR,		1 },
   { "vcrypto",		PPC_FEATURE2_HAS_VEC_CRYPTO,	1 },
   { "arch_3_00",	PPC_FEATURE2_ARCH_3_00,		1 },
-  { "ieee128",		PPC_FEATURE2_HAS_IEEE128,	1 }
+  { "ieee128",		PPC_FEATURE2_HAS_IEEE128,	1 },
+  { "darn",		PPC_FEATURE2_DARN,		1 },
+  { "scv",		PPC_FEATURE2_SCV,		1 }
 };
 
 /* Newer LIBCs explicitly export this symbol to declare that they provide
@@ -494,6 +496,91 @@
 	  != 0);
 }
 
+/* Given that there exists at least one variable that is set (produced)
+   by OUT_INSN and read (consumed) by IN_INSN, return true iff
+   IN_INSN represents one or more memory store operations and none of
+   the variables set by OUT_INSN is used by IN_INSN as the address of a
+   store operation.  If either IN_INSN or OUT_INSN does not represent
+   a "single" RTL SET expression (as loosely defined by the
+   implementation of the single_set function) or a PARALLEL with only
+   SETs, CLOBBERs, and USEs inside, this function returns false.
+
+   This rs6000-specific version of store_data_bypass_p checks for
+   certain conditions that result in assertion failures (and internal
+   compiler errors) in the generic store_data_bypass_p function and
+   returns false rather than calling store_data_bypass_p if one of the
+   problematic conditions is detected.  */
+
+int
+rs6000_store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)
+{
+  rtx out_set, in_set;
+  rtx out_pat, in_pat;
+  rtx out_exp, in_exp;
+  int i, j;
+
+  in_set = single_set (in_insn);
+  if (in_set)
+    {
+      if (MEM_P (SET_DEST (in_set)))
+	{
+	  out_set = single_set (out_insn);
+	  if (!out_set)
+	    {
+	      out_pat = PATTERN (out_insn);
+	      if (GET_CODE (out_pat) == PARALLEL)
+		{
+		  for (i = 0; i < XVECLEN (out_pat, 0); i++)
+		    {
+		      out_exp = XVECEXP (out_pat, 0, i);
+		      if ((GET_CODE (out_exp) == CLOBBER)
+			  || (GET_CODE (out_exp) == USE))
+			continue;
+		      else if (GET_CODE (out_exp) != SET)
+			return false;
+		    }
+		}
+	    }
+	}
+    }
+  else
+    {
+      in_pat = PATTERN (in_insn);
+      if (GET_CODE (in_pat) != PARALLEL)
+	return false;
+
+      for (i = 0; i < XVECLEN (in_pat, 0); i++)
+	{
+	  in_exp = XVECEXP (in_pat, 0, i);
+	  if ((GET_CODE (in_exp) == CLOBBER) || (GET_CODE (in_exp) == USE))
+	    continue;
+	  else if (GET_CODE (in_exp) != SET)
+	    return false;
+
+	  if (MEM_P (SET_DEST (in_exp)))
+	    {
+	      out_set = single_set (out_insn);
+	      if (!out_set)
+		{
+		  out_pat = PATTERN (out_insn);
+		  if (GET_CODE (out_pat) != PARALLEL)
+		    return false;
+		  for (j = 0; j < XVECLEN (out_pat, 0); j++)
+		    {
+		      out_exp = XVECEXP (out_pat, 0, j);
+		      if ((GET_CODE (out_exp) == CLOBBER)
+			  || (GET_CODE (out_exp) == USE))
+			continue;
+		      else if (GET_CODE (out_exp) != SET)
+			return false;
+		    }
+		}
+	    }
+	}
+    }
+  return store_data_bypass_p (out_insn, in_insn);
+}
+
 /* Return true if we have D-form addressing in altivec registers.  */
 static inline bool
 mode_supports_vmx_dform (machine_mode mode)
@@ -4075,9 +4162,22 @@
 
   if (TARGET_P8_VECTOR && !TARGET_VSX)
     {
-      if (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)
+      if ((rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)
+	  && (rs6000_isa_flags_explicit & OPTION_MASK_VSX))
 	error ("-mpower8-vector requires -mvsx");
-      rs6000_isa_flags &= ~OPTION_MASK_P8_VECTOR;
+      else if ((rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR) == 0)
+	{
+	  rs6000_isa_flags &= ~OPTION_MASK_P8_VECTOR;
+	  if (rs6000_isa_flags_explicit & OPTION_MASK_VSX)
+	    rs6000_isa_flags_explicit |= OPTION_MASK_P8_VECTOR;
+	}
+      else
+	{
+	  /* OPTION_MASK_P8_VECTOR is explicit, and OPTION_MASK_VSX is
+	     not explicit.  */
+	  rs6000_isa_flags |= OPTION_MASK_VSX;
+	  rs6000_isa_flags_explicit |= OPTION_MASK_VSX;
+	}
     }
 
   if (TARGET_VSX_TIMODE && !TARGET_VSX)
@@ -4258,9 +4358,22 @@
 	 error messages.  However, if users have managed to select
 	 power9-vector without selecting power8-vector, they
 	 already know about undocumented flags.  */
-      if (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)
+      if ((rs6000_isa_flags_explicit & OPTION_MASK_P9_VECTOR) &&
+	  (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR))
 	error ("-mpower9-vector requires -mpower8-vector");
-      rs6000_isa_flags &= ~OPTION_MASK_P9_VECTOR;
+      else if ((rs6000_isa_flags_explicit & OPTION_MASK_P9_VECTOR) == 0)
+	{
+	  rs6000_isa_flags &= ~OPTION_MASK_P9_VECTOR;
+	  if (rs6000_isa_flags_explicit & OPTION_MASK_P8_VECTOR)
+	    rs6000_isa_flags_explicit |= OPTION_MASK_P9_VECTOR;
+	}
+      else
+	{
+	  /* OPTION_MASK_P9_VECTOR is explicit and
+	     OPTION_MASK_P8_VECTOR is not explicit.  */
+	  rs6000_isa_flags |= OPTION_MASK_P8_VECTOR;
+	  rs6000_isa_flags_explicit |= OPTION_MASK_P8_VECTOR;
+	}
     }
 
   /* -mpower9-dform turns on both -mpower9-dform-scalar and
@@ -4289,12 +4402,54 @@
 	 error messages.  However, if users have managed to select
 	 power9-dform without selecting power9-vector, they
 	 already know about undocumented flags.  */
-      if (rs6000_isa_flags_explicit & OPTION_MASK_P9_VECTOR)
+      if ((rs6000_isa_flags_explicit & OPTION_MASK_P9_VECTOR)
+	  && (rs6000_isa_flags_explicit & (OPTION_MASK_P9_DFORM_SCALAR
+					   | OPTION_MASK_P9_DFORM_VECTOR)))
 	error ("-mpower9-dform requires -mpower9-vector");
-      rs6000_isa_flags &= ~(OPTION_MASK_P9_DFORM_SCALAR
-			    | OPTION_MASK_P9_DFORM_VECTOR);
+      else if (rs6000_isa_flags_explicit & OPTION_MASK_P9_VECTOR)
+	{
+	  rs6000_isa_flags &=
+	    ~(OPTION_MASK_P9_DFORM_SCALAR | OPTION_MASK_P9_DFORM_VECTOR);
+	  rs6000_isa_flags_explicit |=
+	    (OPTION_MASK_P9_DFORM_SCALAR | OPTION_MASK_P9_DFORM_VECTOR);
+	}
+      else
+	{
+	  /* We know that OPTION_MASK_P9_VECTOR is not explicit and
+	     OPTION_MASK_P9_DFORM_SCALAR or OPTION_MASK_P9_DORM_VECTOR
+	     may be explicit.  */
+	  rs6000_isa_flags |= OPTION_MASK_P9_VECTOR;
+	  rs6000_isa_flags_explicit |= OPTION_MASK_P9_VECTOR;
+	}
     }
 
+  if ((TARGET_P9_DFORM_SCALAR || TARGET_P9_DFORM_VECTOR)
+      && !TARGET_DIRECT_MOVE)
+    {
+      /* We prefer to not mention undocumented options in
+	 error messages.  However, if users have managed to select
+	 power9-dform without selecting power9-vector, they
+	 already know about undocumented flags.  */
+      if ((rs6000_isa_flags_explicit & OPTION_MASK_DIRECT_MOVE)
+	  && ((rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR) ||
+	      (rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_SCALAR) ||
+	      (TARGET_P9_DFORM_BOTH == 1)))
+	error ("-mpower9-dform, -mpower9-dform-vector, -mpower9-dform-scalar"
+	       " require -mdirect-move");
+      else if ((rs6000_isa_flags_explicit & OPTION_MASK_DIRECT_MOVE) == 0)
+	{
+	  rs6000_isa_flags |= OPTION_MASK_DIRECT_MOVE;
+	  rs6000_isa_flags_explicit |= OPTION_MASK_DIRECT_MOVE;
+	}
+      else
+	{
+	  rs6000_isa_flags &=
+	    ~(OPTION_MASK_P9_DFORM_SCALAR | OPTION_MASK_P9_DFORM_VECTOR);
+	  rs6000_isa_flags_explicit |=
+	    (OPTION_MASK_P9_DFORM_SCALAR | OPTION_MASK_P9_DFORM_VECTOR);
+	}
+    }
+
   if (TARGET_P9_DFORM_SCALAR && !TARGET_UPPER_REGS_DF)
     {
       /* We prefer to not mention undocumented options in
@@ -14162,6 +14317,8 @@
       emit_insn (gen_eqsi3 (scratch2, scratch1, const0_rtx));
       emit_insn (gen_rtx_SET (target, gen_rtx_XOR (SImode, scratch2, const1_rtx)));
     }
+  else
+    gcc_unreachable ();
 
   /* Record that we have expanded a CPU builtin, so that we can later
      emit a reference to the special symbol exported by LIBC to ensure we
@@ -14169,6 +14326,9 @@
   cpu_builtin_p = true;
 
 #else
+  warning (0, "%s needs GLIBC (2.23 and newer) that exports hardware "
+	   "capability bits", rs6000_builtin_info[(size_t) fcode].name);
+  
   /* For old LIBCs, always return FALSE.  */
   emit_move_insn (target, GEN_INT (0));
 #endif /* TARGET_LIBC_PROVIDES_HWCAP_IN_TCB */
@@ -30187,7 +30347,7 @@
                   case TYPE_LOAD:
                   case TYPE_CNTLZ:
                     {
-                      if (! store_data_bypass_p (dep_insn, insn))
+                      if (! rs6000_store_data_bypass_p (dep_insn, insn))
                         return get_attr_sign_extend (dep_insn)
                                == SIGN_EXTEND_YES ? 6 : 4;
                       break;
@@ -30194,7 +30354,7 @@
                     }
                   case TYPE_SHIFT:
                     {
-                      if (! store_data_bypass_p (dep_insn, insn))
+                      if (! rs6000_store_data_bypass_p (dep_insn, insn))
                         return get_attr_var_shift (dep_insn) == VAR_SHIFT_YES ?
                                6 : 3;
                       break;
@@ -30205,7 +30365,7 @@
                   case TYPE_EXTS:
                   case TYPE_INSERT:
                     {
-                      if (! store_data_bypass_p (dep_insn, insn))
+                      if (! rs6000_store_data_bypass_p (dep_insn, insn))
                         return 3;
                       break;
                     }
@@ -30214,19 +30374,19 @@
                   case TYPE_FPSTORE:
                     {
                       if (get_attr_update (dep_insn) == UPDATE_YES
-                          && ! store_data_bypass_p (dep_insn, insn))
+                          && ! rs6000_store_data_bypass_p (dep_insn, insn))
                         return 3;
                       break;
                     }
                   case TYPE_MUL:
                     {
-                      if (! store_data_bypass_p (dep_insn, insn))
+                      if (! rs6000_store_data_bypass_p (dep_insn, insn))
                         return 17;
                       break;
                     }
                   case TYPE_DIV:
                     {
-                      if (! store_data_bypass_p (dep_insn, insn))
+                      if (! rs6000_store_data_bypass_p (dep_insn, insn))
                         return get_attr_size (dep_insn) == SIZE_32 ? 45 : 57;
                       break;
                     }
@@ -32541,8 +32701,8 @@
     {
       if (!toc_initialized)
 	{
-	  toc_initialized = 1;
 	  fprintf (asm_out_file, "%s\n", TOC_SECTION_ASM_OP);
+	  ASM_OUTPUT_ALIGN (asm_out_file, TARGET_64BIT ? 3 : 2);
 	  (*targetm.asm_out.internal_label) (asm_out_file, "LCTOC", 0);
 	  fprintf (asm_out_file, "\t.tc ");
 	  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, "LCTOC1[TC],");
@@ -32550,8 +32710,10 @@
 	  fprintf (asm_out_file, "\n");
 
 	  fprintf (asm_out_file, "%s\n", MINIMAL_TOC_SECTION_ASM_OP);
+	  ASM_OUTPUT_ALIGN (asm_out_file, TARGET_64BIT ? 3 : 2);
 	  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, "LCTOC1");
 	  fprintf (asm_out_file, " = .+32768\n");
+	  toc_initialized = 1;
 	}
       else
 	fprintf (asm_out_file, "%s\n", MINIMAL_TOC_SECTION_ASM_OP);
@@ -32558,12 +32720,20 @@
     }
   else if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)
 	   && !TARGET_RELOCATABLE)
-    fprintf (asm_out_file, "%s\n", TOC_SECTION_ASM_OP);
+    {
+      fprintf (asm_out_file, "%s\n", TOC_SECTION_ASM_OP);
+      if (!toc_initialized)
+	{
+	  ASM_OUTPUT_ALIGN (asm_out_file, TARGET_64BIT ? 3 : 2);
+	  toc_initialized = 1;
+	}
+    }
   else
     {
       fprintf (asm_out_file, "%s\n", MINIMAL_TOC_SECTION_ASM_OP);
       if (!toc_initialized)
 	{
+	  ASM_OUTPUT_ALIGN (asm_out_file, TARGET_64BIT ? 3 : 2);
 	  ASM_OUTPUT_INTERNAL_LABEL_PREFIX (asm_out_file, "LCTOC1");
 	  fprintf (asm_out_file, " = .+32768\n");
 	  toc_initialized = 1;
@@ -36390,6 +36560,22 @@
 /* Remember the last target of rs6000_set_current_function.  */
 static GTY(()) tree rs6000_previous_fndecl;
 
+/* Restore target's globals from NEW_TREE and invalidate the
+   rs6000_previous_fndecl cache.  */
+
+static void
+rs6000_activate_target_options (tree new_tree)
+{
+  cl_target_option_restore (&global_options, TREE_TARGET_OPTION (new_tree));
+  if (TREE_TARGET_GLOBALS (new_tree))
+    restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
+  else if (new_tree == target_option_default_node)
+    restore_target_globals (&default_target_globals);
+  else
+    TREE_TARGET_GLOBALS (new_tree) = save_target_globals_default_opts ();
+  rs6000_previous_fndecl = NULL_TREE;
+}
+
 /* Establish appropriate back-end context for processing the function
    FNDECL.  The argument might be NULL to indicate processing at top
    level, outside of any function scope.  */
@@ -36396,17 +36582,8 @@
 static void
 rs6000_set_current_function (tree fndecl)
 {
-  tree old_tree = (rs6000_previous_fndecl
-		   ? DECL_FUNCTION_SPECIFIC_TARGET (rs6000_previous_fndecl)
-		   : NULL_TREE);
-
-  tree new_tree = (fndecl
-		   ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)
-		   : NULL_TREE);
-
   if (TARGET_DEBUG_TARGET)
     {
-      bool print_final = false;
       fprintf (stderr, "\n==================== rs6000_set_current_function");
 
       if (fndecl)
@@ -36419,11 +36596,43 @@
 	fprintf (stderr, ", prev_fndecl (%p)", (void *)rs6000_previous_fndecl);
 
       fprintf (stderr, "\n");
+    }
+
+  /* Only change the context if the function changes.  This hook is called
+     several times in the course of compiling a function, and we don't want to
+     slow things down too much or call target_reinit when it isn't safe.  */
+  if (fndecl == rs6000_previous_fndecl)
+    return;
+
+  tree old_tree;
+  if (rs6000_previous_fndecl == NULL_TREE)
+    old_tree = target_option_current_node;
+  else if (DECL_FUNCTION_SPECIFIC_TARGET (rs6000_previous_fndecl))
+    old_tree = DECL_FUNCTION_SPECIFIC_TARGET (rs6000_previous_fndecl);
+  else
+    old_tree = target_option_default_node;
+
+  tree new_tree;
+  if (fndecl == NULL_TREE)
+    {
+      if (old_tree != target_option_current_node)
+	new_tree = target_option_current_node;
+      else
+	new_tree = NULL_TREE;
+    }
+  else
+    {
+      new_tree = DECL_FUNCTION_SPECIFIC_TARGET (fndecl);
+      if (new_tree == NULL_TREE)
+	new_tree = target_option_default_node;
+    }
+
+  if (TARGET_DEBUG_TARGET)
+    {
       if (new_tree)
 	{
 	  fprintf (stderr, "\nnew fndecl target specific options:\n");
 	  debug_tree (new_tree);
-	  print_final = true;
 	}
 
       if (old_tree)
@@ -36430,47 +36639,17 @@
 	{
 	  fprintf (stderr, "\nold fndecl target specific options:\n");
 	  debug_tree (old_tree);
-	  print_final = true;
 	}
 
-      if (print_final)
+      if (old_tree != NULL_TREE || new_tree != NULL_TREE)
 	fprintf (stderr, "--------------------\n");
     }
 
-  /* Only change the context if the function changes.  This hook is called
-     several times in the course of compiling a function, and we don't want to
-     slow things down too much or call target_reinit when it isn't safe.  */
-  if (fndecl && fndecl != rs6000_previous_fndecl)
-    {
-      rs6000_previous_fndecl = fndecl;
-      if (old_tree == new_tree)
-	;
+  if (new_tree && old_tree != new_tree)
+    rs6000_activate_target_options (new_tree);
 
-      else if (new_tree && new_tree != target_option_default_node)
-	{
-	  cl_target_option_restore (&global_options,
-				    TREE_TARGET_OPTION (new_tree));
-	  if (TREE_TARGET_GLOBALS (new_tree))
-	    restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
-	  else
-	    TREE_TARGET_GLOBALS (new_tree)
-	      = save_target_globals_default_opts ();
-	}
-
-      else if (old_tree && old_tree != target_option_default_node)
-	{
-	  new_tree = target_option_current_node;
-	  cl_target_option_restore (&global_options,
-				    TREE_TARGET_OPTION (new_tree));
-	  if (TREE_TARGET_GLOBALS (new_tree))
-	    restore_target_globals (TREE_TARGET_GLOBALS (new_tree));
-	  else if (new_tree == target_option_default_node)
-	    restore_target_globals (&default_target_globals);
-	  else
-	    TREE_TARGET_GLOBALS (new_tree)
-	      = save_target_globals_default_opts ();
-	}
-    }
+  if (fndecl)
+    rs6000_previous_fndecl = fndecl;
 }
 
 
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-6-branch)
@@ -1908,6 +1908,80 @@
 }
   [(set_attr "type" "vecperm")])
 
+;; Combiner patterns to allow creating XXPERMDI's to access either double
+;; word element in a vector register.
+(define_insn "*vsx_concat_<mode>_1"
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSa>")
+	(vec_concat:VSX_D
+	 (vec_select:<VS_scalar>
+	  (match_operand:VSX_D 1 "gpc_reg_operand" "<VSa>")
+	  (parallel [(match_operand:QI 2 "const_0_to_1_operand" "n")]))
+	 (match_operand:<VS_scalar> 3 "gpc_reg_operand" "<VSa>")))]
+  "VECTOR_MEM_VSX_P (<MODE>mode)"
+{
+  HOST_WIDE_INT dword = INTVAL (operands[2]);
+  if (BYTES_BIG_ENDIAN)
+    {
+      operands[4] = GEN_INT (2*dword);
+      return "xxpermdi %x0,%x1,%x3,%4";
+    }
+  else
+    {
+      operands[4] = GEN_INT (!dword);
+      return "xxpermdi %x0,%x3,%x1,%4";
+    }
+}
+  [(set_attr "type" "vecperm")])
+
+(define_insn "*vsx_concat_<mode>_2"
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSa>")
+	(vec_concat:VSX_D
+	 (match_operand:<VS_scalar> 1 "gpc_reg_operand" "<VSa>")
+	 (vec_select:<VS_scalar>
+	  (match_operand:VSX_D 2 "gpc_reg_operand" "<VSa>")
+	  (parallel [(match_operand:QI 3 "const_0_to_1_operand" "n")]))))]
+  "VECTOR_MEM_VSX_P (<MODE>mode)"
+{
+  HOST_WIDE_INT dword = INTVAL (operands[3]);
+  if (BYTES_BIG_ENDIAN)
+    {
+      operands[4] = GEN_INT (dword);
+      return "xxpermdi %x0,%x1,%x2,%4";
+    }
+  else
+    {
+      operands[4] = GEN_INT (2 * !dword);
+      return "xxpermdi %x0,%x2,%x1,%4";
+    }
+}
+  [(set_attr "type" "vecperm")])
+
+(define_insn "*vsx_concat_<mode>_3"
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSa>")
+	(vec_concat:VSX_D
+	 (vec_select:<VS_scalar>
+	  (match_operand:VSX_D 1 "gpc_reg_operand" "<VSa>")
+	  (parallel [(match_operand:QI 2 "const_0_to_1_operand" "n")]))
+	 (vec_select:<VS_scalar>
+	  (match_operand:VSX_D 3 "gpc_reg_operand" "<VSa>")
+	  (parallel [(match_operand:QI 4 "const_0_to_1_operand" "n")]))))]
+  "VECTOR_MEM_VSX_P (<MODE>mode)"
+{
+  HOST_WIDE_INT dword1 = INTVAL (operands[2]);
+  HOST_WIDE_INT dword2 = INTVAL (operands[4]);
+  if (BYTES_BIG_ENDIAN)
+    {
+      operands[5] = GEN_INT ((2 * dword1) + dword2);
+      return "xxpermdi %x0,%x1,%x3,%5";
+    }
+  else
+    {
+      operands[5] = GEN_INT ((2 * !dword2) + !dword1);
+      return "xxpermdi %x0,%x3,%x1,%5";
+    }
+}
+  [(set_attr "type" "vecperm")])
+
 ;; Special purpose concat using xxpermdi to glue two single precision values
 ;; together, relying on the fact that internally scalar floats are represented
 ;; as doubles.  This is used to initialize a V4SF vector with 4 floats
@@ -2088,25 +2162,35 @@
   DONE;
 })
 
-;; Set the element of a V2DI/VD2F mode
-(define_insn "vsx_set_<mode>"
-  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wd,?<VSa>")
-	(unspec:VSX_D
-	 [(match_operand:VSX_D 1 "vsx_register_operand" "wd,<VSa>")
-	  (match_operand:<VS_scalar> 2 "vsx_register_operand" "<VS_64reg>,<VSa>")
-	  (match_operand:QI 3 "u5bit_cint_operand" "i,i")]
-	 UNSPEC_VSX_SET))]
+;; Rewrite V2DF/V2DI set in terms of VEC_CONCAT
+(define_expand "vsx_set_<mode>"
+  [(use (match_operand:VSX_D 0 "vsx_register_operand"))
+   (use (match_operand:VSX_D 1 "vsx_register_operand"))
+   (use (match_operand:<VS_scalar> 2 "gpc_reg_operand"))
+   (use (match_operand:QI 3 "const_0_to_1_operand"))]
   "VECTOR_MEM_VSX_P (<MODE>mode)"
 {
-  int idx_first = BYTES_BIG_ENDIAN ? 0 : 1;
-  if (INTVAL (operands[3]) == idx_first)
-    return \"xxpermdi %x0,%x2,%x1,1\";
-  else if (INTVAL (operands[3]) == 1 - idx_first)
-    return \"xxpermdi %x0,%x1,%x2,0\";
+  rtx dest = operands[0];
+  rtx vec_reg = operands[1];
+  rtx value = operands[2];
+  rtx ele = operands[3];
+  rtx tmp = gen_reg_rtx (<VS_scalar>mode);
+
+  if (ele == const0_rtx)
+    {
+      emit_insn (gen_vsx_extract_<mode> (tmp, vec_reg, const1_rtx));
+      emit_insn (gen_vsx_concat_<mode> (dest, value, tmp));
+      DONE;
+    }
+  else if (ele == const1_rtx)
+    {
+      emit_insn (gen_vsx_extract_<mode> (tmp, vec_reg, const0_rtx));
+      emit_insn (gen_vsx_concat_<mode> (dest, tmp, value));
+      DONE;
+    }
   else
     gcc_unreachable ();
-}
-  [(set_attr "type" "vecperm")])
+})
 
 ;; Extract a DF/DI element from V2DF/V2DI
 (define_expand "vsx_extract_<mode>"
Index: gcc/config/rs6000/altivec.md
===================================================================
--- a/src/gcc/config/rs6000/altivec.md	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/altivec.md	(.../branches/gcc-6-branch)
@@ -1714,51 +1714,61 @@
   "vsum4s<VI_char>s %0,%1,%2"
   [(set_attr "type" "veccomplex")])
 
-;; FIXME: For the following two patterns, the scratch should only be
-;; allocated for !VECTOR_ELT_ORDER_BIG, and the instructions should
-;; be emitted separately.
-(define_insn "altivec_vsum2sws"
-  [(set (match_operand:V4SI 0 "register_operand" "=v")
-        (unspec:V4SI [(match_operand:V4SI 1 "register_operand" "v")
-                      (match_operand:V4SI 2 "register_operand" "v")]
-		     UNSPEC_VSUM2SWS))
-   (set (reg:SI 110) (unspec:SI [(const_int 0)] UNSPEC_SET_VSCR))
-   (clobber (match_scratch:V4SI 3 "=v"))]
+(define_expand "altivec_vsum2sws"
+  [(use (match_operand:V4SI 0 "register_operand"))
+   (use (match_operand:V4SI 1 "register_operand"))
+   (use (match_operand:V4SI 2 "register_operand"))]
   "TARGET_ALTIVEC"
 {
   if (VECTOR_ELT_ORDER_BIG)
-    return "vsum2sws %0,%1,%2";
+    emit_insn (gen_altivec_vsum2sws_direct (operands[0], operands[1],
+                                            operands[2]));
   else
-    return "vsldoi %3,%2,%2,12\n\tvsum2sws %3,%1,%3\n\tvsldoi %0,%3,%3,4";
-}
-  [(set_attr "type" "veccomplex")
-   (set (attr "length")
-     (if_then_else
-       (match_test "VECTOR_ELT_ORDER_BIG")
-       (const_string "4")
-       (const_string "12")))])
+    {
+      rtx tmp1 = gen_reg_rtx (V4SImode);
+      rtx tmp2 = gen_reg_rtx (V4SImode);
+      emit_insn (gen_altivec_vsldoi_v4si (tmp1, operands[2],
+                                          operands[2], GEN_INT (12)));
+      emit_insn (gen_altivec_vsum2sws_direct (tmp2, operands[1], tmp1));
+      emit_insn (gen_altivec_vsldoi_v4si (operands[0], tmp2, tmp2,
+                                          GEN_INT (4)));
+    }
+  DONE;
+})
 
-(define_insn "altivec_vsumsws"
+; FIXME: This can probably be expressed without an UNSPEC.
+(define_insn "altivec_vsum2sws_direct"
   [(set (match_operand:V4SI 0 "register_operand" "=v")
         (unspec:V4SI [(match_operand:V4SI 1 "register_operand" "v")
-                      (match_operand:V4SI 2 "register_operand" "v")]
-		     UNSPEC_VSUMSWS))
-   (set (reg:SI 110) (unspec:SI [(const_int 0)] UNSPEC_SET_VSCR))
-   (clobber (match_scratch:V4SI 3 "=v"))]
+	              (match_operand:V4SI 2 "register_operand" "v")]
+		     UNSPEC_VSUM2SWS))
+   (set (reg:SI VSCR_REGNO) (unspec:SI [(const_int 0)] UNSPEC_SET_VSCR))]
   "TARGET_ALTIVEC"
+  "vsum2sws %0,%1,%2"
+  [(set_attr "type" "veccomplex")])
+
+(define_expand "altivec_vsumsws"
+  [(use (match_operand:V4SI 0 "register_operand"))
+   (use (match_operand:V4SI 1 "register_operand"))
+   (use (match_operand:V4SI 2 "register_operand"))]
+  "TARGET_ALTIVEC"
 {
   if (VECTOR_ELT_ORDER_BIG)
-    return "vsumsws %0,%1,%2";
+    emit_insn (gen_altivec_vsumsws_direct (operands[0], operands[1],
+                                           operands[2]));
   else
-    return "vspltw %3,%2,0\n\tvsumsws %3,%1,%3\n\tvsldoi %0,%3,%3,12";
-}
-  [(set_attr "type" "veccomplex")
-   (set (attr "length")
-     (if_then_else
-       (match_test "(VECTOR_ELT_ORDER_BIG)")
-       (const_string "4")
-       (const_string "12")))])
+    {
+      rtx tmp1 = gen_reg_rtx (V4SImode);
+      rtx tmp2 = gen_reg_rtx (V4SImode);
+      emit_insn (gen_altivec_vspltw_direct (tmp1, operands[2], const0_rtx));
+      emit_insn (gen_altivec_vsumsws_direct (tmp2, operands[1], tmp1));
+      emit_insn (gen_altivec_vsldoi_v4si (operands[0], tmp2, tmp2,
+                                          GEN_INT (12)));
+    }
+  DONE;
+})
 
+; FIXME: This can probably be expressed without an UNSPEC.
 (define_insn "altivec_vsumsws_direct"
   [(set (match_operand:V4SI 0 "register_operand" "=v")
         (unspec:V4SI [(match_operand:V4SI 1 "register_operand" "v")
Index: gcc/config/rs6000/sysv4.h
===================================================================
--- a/src/gcc/config/rs6000/sysv4.h	(.../tags/gcc_6_4_0_release)
+++ b/src/gcc/config/rs6000/sysv4.h	(.../branches/gcc-6-branch)
@@ -752,24 +752,34 @@
 #define CRTOFFLOADEND ""
 #endif
 
-#ifdef HAVE_LD_PIE
-#define	STARTFILE_LINUX_SPEC "\
-%{!shared: %{pg|p|profile:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}} \
-%{mnewlib:ecrti.o%s;:crti.o%s} \
-%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \
-" CRTOFFLOADBEGIN
-#else
-#define	STARTFILE_LINUX_SPEC "\
-%{!shared: %{pg|p|profile:gcrt1.o%s;:crt1.o%s}} \
-%{mnewlib:ecrti.o%s;:crti.o%s} \
-%{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s} \
-" CRTOFFLOADBEGIN
-#endif
+/* STARTFILE_LINUX_SPEC should be the same as GNU_USER_TARGET_STARTFILE_SPEC
+   but with the mnewlib ecrti.o%s selection substituted for crti.o%s.  */
+#define	STARTFILE_LINUX_SPEC \
+  "%{shared:; \
+     pg|p|profile:gcrt1.o%s; \
+     static:crt1.o%s; \
+     " PIE_SPEC ":Scrt1.o%s; \
+     :crt1.o%s} \
+   %{mnewlib:ecrti.o%s;:crti.o%s} \
+   %{static:crtbeginT.o%s; \
+     shared|" PIE_SPEC ":crtbeginS.o%s; \
+     :crtbegin.o%s} \
+   %{fvtable-verify=none:%s; \
+     fvtable-verify=preinit:vtv_start_preinit.o%s; \
+     fvtable-verify=std:vtv_start.o%s} \
+   " CRTOFFLOADBEGIN
 
-#define	ENDFILE_LINUX_SPEC "\
-%{shared|pie:crtendS.o%s;:crtend.o%s} \
-%{mnewlib:ecrtn.o%s;:crtn.o%s} \
-" CRTOFFLOADEND
+/* ENDFILE_LINUX_SPEC should be the same as GNU_USER_TARGET_ENDFILE_SPEC
+   but with the mnewlib ecrtn.o%s selection substituted for crtn.o%s.  */
+#define ENDFILE_LINUX_SPEC \
+  "%{fvtable-verify=none:%s; \
+     fvtable-verify=preinit:vtv_end_preinit.o%s; \
+     fvtable-verify=std:vtv_end.o%s} \
+   %{static:crtend.o%s; \
+     shared|" PIE_SPEC ":crtendS.o%s; \
+     :crtend.o%s} \
+   %{mnewlib:ecrtn.o%s;:crtn.o%s} \
+   " CRTOFFLOADEND
 
 #define LINK_START_LINUX_SPEC ""
 
Index: libgo/go/syscall/syscall_linux_s390x.go
===================================================================
--- a/src/libgo/go/syscall/syscall_linux_s390x.go	(.../tags/gcc_6_4_0_release)
+++ b/src/libgo/go/syscall/syscall_linux_s390x.go	(.../branches/gcc-6-branch)
@@ -12,10 +12,29 @@
 
 func (r *PtraceRegs) SetPC(pc uint64) { r.Psw.Addr = pc }
 
-func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {
-	return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))
+const syscall_PTRACE_PEEKUSR_AREA = 0x5000
+const syscall_PTRACE_POKEUSR_AREA = 0x5001
+
+type syscall_ptrace_area struct {
+	len          uint32
+	kernel_addr  uint64
+	process_addr uint64
 }
 
+func PtraceGetRegs(pid int, regs *PtraceRegs) (err error) {
+	parea := syscall_ptrace_area{
+		24,
+		0,
+		uint64(uintptr(unsafe.Pointer(regs))),
+	}
+	return ptrace(syscall_PTRACE_PEEKUSR_AREA, pid, uintptr(unsafe.Pointer(&parea)), 0)
+}
+
 func PtraceSetRegs(pid int, regs *PtraceRegs) (err error) {
-	return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))
+	parea := syscall_ptrace_area{
+		24,
+		0,
+		uint64(uintptr(unsafe.Pointer(regs))),
+	}
+	return ptrace(syscall_PTRACE_POKEUSR_AREA, pid, uintptr(unsafe.Pointer(&parea)), 0)
 }
Index: libgo/go/syscall/syscall_linux_s390.go
===================================================================
--- a/src/libgo/go/syscall/syscall_linux_s390.go	(.../tags/gcc_6_4_0_release)
+++ b/src/libgo/go/syscall/syscall_linux_s390.go	(.../branches/gcc-6-branch)
@@ -12,10 +12,29 @@
 
 func (r *PtraceRegs) SetPC(pc uint64) { r.Psw.Addr = uint32(pc) }
 
-func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {
-	return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))
+const syscall_PTRACE_PEEKUSR_AREA = 0x5000
+const syscall_PTRACE_POKEUSR_AREA = 0x5001
+
+type syscall_ptrace_area struct {
+	len          uint32
+	kernel_addr  uint32
+	process_addr uint32
 }
 
+func PtraceGetRegs(pid int, regs *PtraceRegs) (err error) {
+	parea := syscall_ptrace_area{
+		12,
+		0,
+		uint32(uintptr(unsafe.Pointer(regs))),
+	}
+	return ptrace(syscall_PTRACE_PEEKUSR_AREA, pid, uintptr(unsafe.Pointer(&parea)), 0)
+}
+
 func PtraceSetRegs(pid int, regs *PtraceRegs) (err error) {
-	return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))
+	parea := syscall_ptrace_area{
+		12,
+		0,
+		uint32(uintptr(unsafe.Pointer(regs))),
+	}
+	return ptrace(syscall_PTRACE_POKEUSR_AREA, pid, uintptr(unsafe.Pointer(&parea)), 0)
 }
