# DP: libiberty updates, taken from the trunk 20161108

2016-11-07  Jason Merrill  <jason@redhat.com>

	* cp-demangle.c (is_fnqual_component_type): New.
	(d_encoding, d_print_comp_inner, d_print_mod_list): Use it.
	(FNQUAL_COMPONENT_CASE): New.
	(d_make_comp, has_return_type, d_print_comp_inner)
	(d_print_function_type): Use it.
	(next_is_type_qual): New.
	(d_cv_qualifiers, d_print_mod): Handle noexcept and throw-spec.

2016-11-02  Mark Wielaard  <mjw@redhat.com>

	* cplus-dem.c (demangle_signature): Move fall through comment.
	(demangle_fund_type): Add fall through comment between 'G' and 'I'.
	* hashtab.c (iterative_hash): Add fall through comments.
	* regex.c (regex_compile): Add Fall through comment after '+'/'?'.
	(byte_re_match_2_internal): Add Fall through comment after jump_n.
	Change "Note fall through" to "Fall through".
	(common_op_match_null_string_p): Return false after set_number_at
	instead of fall through.

2016-11-01  Jason Merrill  <jason@redhat.com>

	* cp-demangle.c (d_ctor_dtor_name): Handle inheriting constructor.

2016-10-31  Mark Wielaard  <mjw@redhat.com>

	* cplus-dem.c (ada_demangle): Initialize demangled to NULL and
	XDELETEVEC demangled when unknown.

2016-09-19  Andrew Stubbs  <ams@codesourcery.com>

	* pex-win32.c (argv_to_cmdline): Quote zero-length parameters.
	* testsuite/test-pexecute.c (main): Insert check for zero-length parameters.

2016-09-10  Mark Wielaard  <mjw@redhat.com>

	* cp-demangle.c (d_substitution): Change struct demangle_component
	variable name from c to dc.

2016-08-12  Marek Polacek  <polacek@redhat.com>

	PR c/7652
	* cp-demangle.c (d_print_mod): Add FALLTHRU.

2016-08-04  Marcel Böhme  <boehme.marcel@gmail.com>

	PR c++/71696
	* cplus-dem.c: Prevent infinite recursion when there is a cycle
	in the referencing of remembered mangled types.
	(work_stuff): New stack to keep track of the remembered mangled
	types that are currently being processed.
	(push_processed_type): New method to push currently processed
	remembered type onto the stack.
	(pop_processed_type): New method to pop currently processed
	remembered type from the stack.
	(work_stuff_copy_to_from): Copy values of new variables.
	(delete_non_B_K_work_stuff): Free stack memory.
	(demangle_args): Push/Pop currently processed remembered type.
	(do_type): Do not demangle a cyclic reference and push/pop
	referenced remembered type.

2016-07-29  Aldy Hernandez  <aldyh@redhat.com>

	* make-relative-prefix.c (make_relative_prefix_1): Fall back to
	malloc if alloca argument is greater than MAX_ALLOCA_SIZE.

2016-07-15  Jason Merrill  <jason@redhat.com>

	* cp-demangle.c (cplus_demangle_operators): Add f[lrLR].
	(d_expression_1): Handle them.
	(d_maybe_print_fold_expression): New.
	(d_print_comp_inner): Use it.
	(d_index_template_argument): Handle negative index.

	* cp-demangle.c (cplus_demangle_operators): Add sP and sZ.
	(d_print_comp_inner): Handle them.
	(d_template_args_1): Split out from d_template_args.
	(d_args_length): New.

2016-07-13  Marcel Böhme  <boehme.marcel@gmail.com>

	PR c++/70926
	* cplus-dem.c: Handle large values and overflow when demangling
	length variables.
	(demangle_template_value_parm): Read only until end of mangled string.
	(do_hpacc_template_literal): Likewise.
	(do_type): Handle overflow when demangling array indices.

2016-06-12  Brooks Moses  <bmoses@google.com>

	* cp-demangle.c (cplus_demangle_print_callback): Avoid zero-length
	  VLAs.

2016-05-31  Alan Modra  <amodra@gmail.com>

	* xmemdup.c (xmemdup): Use xmalloc rather than xcalloc.

2016-05-19  Jakub Jelinek  <jakub@redhat.com>

	PR c++/70498
	* cp-demangle.c (d_expression_1): Formatting fix.

2016-05-18  Artemiy Volkov  <artemiyv@acm.org>

	* cplus-dem.c (enum type_kind_t): Add tk_rvalue_reference
	constant.
	(demangle_template_value_parm): Handle tk_rvalue_reference
	type kind.
	(do_type): Support 'O' type id (rvalue references).

	* testsuite/demangle-expected: Add tests.

--- a/src/libiberty/cp-demangle.c
+++ b/src/libiberty/cp-demangle.c
@@ -436,6 +436,8 @@
 
 static struct demangle_component *d_special_name (struct d_info *);
 
+static struct demangle_component *d_parmlist (struct d_info *);
+
 static int d_call_offset (struct d_info *, int);
 
 static struct demangle_component *d_ctor_dtor_name (struct d_info *);
@@ -559,6 +561,32 @@
                                 demangle_callbackref, void *);
 static char *d_demangle (const char *, int, size_t *);
 
+/* True iff TYPE is a demangling component representing a
+   function-type-qualifier.  */
+
+static int
+is_fnqual_component_type (enum demangle_component_type type)
+{
+  return (type == DEMANGLE_COMPONENT_RESTRICT_THIS
+	  || type == DEMANGLE_COMPONENT_VOLATILE_THIS
+	  || type == DEMANGLE_COMPONENT_CONST_THIS
+	  || type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS
+	  || type == DEMANGLE_COMPONENT_TRANSACTION_SAFE
+	  || type == DEMANGLE_COMPONENT_NOEXCEPT
+	  || type == DEMANGLE_COMPONENT_THROW_SPEC
+	  || type == DEMANGLE_COMPONENT_REFERENCE_THIS);
+}
+
+#define FNQUAL_COMPONENT_CASE				\
+    case DEMANGLE_COMPONENT_RESTRICT_THIS:		\
+    case DEMANGLE_COMPONENT_VOLATILE_THIS:		\
+    case DEMANGLE_COMPONENT_CONST_THIS:			\
+    case DEMANGLE_COMPONENT_REFERENCE_THIS:		\
+    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:	\
+    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:		\
+    case DEMANGLE_COMPONENT_NOEXCEPT:			\
+    case DEMANGLE_COMPONENT_THROW_SPEC
+
 #ifdef CP_DEMANGLE_DEBUG
 
 static void
@@ -984,14 +1012,9 @@
     case DEMANGLE_COMPONENT_RESTRICT:
     case DEMANGLE_COMPONENT_VOLATILE:
     case DEMANGLE_COMPONENT_CONST:
-    case DEMANGLE_COMPONENT_RESTRICT_THIS:
-    case DEMANGLE_COMPONENT_VOLATILE_THIS:
-    case DEMANGLE_COMPONENT_CONST_THIS:
-    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:
-    case DEMANGLE_COMPONENT_REFERENCE_THIS:
-    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
     case DEMANGLE_COMPONENT_ARGLIST:
     case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:
+    FNQUAL_COMPONENT_CASE:
       break;
 
       /* Other types should not be seen here.  */
@@ -1225,12 +1248,7 @@
       return 0;
     case DEMANGLE_COMPONENT_TEMPLATE:
       return ! is_ctor_dtor_or_conversion (d_left (dc));
-    case DEMANGLE_COMPONENT_RESTRICT_THIS:
-    case DEMANGLE_COMPONENT_VOLATILE_THIS:
-    case DEMANGLE_COMPONENT_CONST_THIS:
-    case DEMANGLE_COMPONENT_REFERENCE_THIS:
-    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
-    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:
+    FNQUAL_COMPONENT_CASE:
       return has_return_type (d_left (dc));
     }
 }
@@ -1287,13 +1305,12 @@
 	  while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
 		 || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
 		 || dc->type == DEMANGLE_COMPONENT_CONST_THIS
-		 || dc->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE
 		 || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS
 		 || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)
 	    dc = d_left (dc);
 
 	  /* If the top level is a DEMANGLE_COMPONENT_LOCAL_NAME, then
-	     there may be CV-qualifiers on its right argument which
+	     there may be function-qualifiers on its right argument which
 	     really apply here; this happens when parsing a class
 	     which is local to a function.  */
 	  if (dc->type == DEMANGLE_COMPONENT_LOCAL_NAME)
@@ -1301,12 +1318,7 @@
 	      struct demangle_component *dcr;
 
 	      dcr = d_right (dc);
-	      while (dcr->type == DEMANGLE_COMPONENT_RESTRICT_THIS
-		     || dcr->type == DEMANGLE_COMPONENT_VOLATILE_THIS
-		     || dcr->type == DEMANGLE_COMPONENT_CONST_THIS
-		     || dcr->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE
-		     || dcr->type == DEMANGLE_COMPONENT_REFERENCE_THIS
-		     || dcr->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)
+	      while (is_fnqual_component_type (dcr->type))
 		dcr = d_left (dcr);
 	      dc->u.s_binary.right = dcr;
 	    }
@@ -2168,6 +2180,13 @@
     case 'C':
       {
 	enum gnu_v3_ctor_kinds kind;
+	int inheriting = 0;
+
+	if (d_peek_next_char (di) == 'I')
+	  {
+	    inheriting = 1;
+	    d_advance (di, 1);
+	  }
 
 	switch (d_peek_next_char (di))
 	  {
@@ -2189,7 +2208,12 @@
 	  default:
 	    return NULL;
 	  }
+
 	d_advance (di, 2);
+
+	if (inheriting)
+	  cplus_demangle_type (di);
+
 	return d_make_ctor (di, kind, di->last_name);
       }
 
@@ -2227,6 +2251,24 @@
     }
 }
 
+/* True iff we're looking at an order-insensitive type-qualifier, including
+   function-type-qualifiers.  */
+
+static int
+next_is_type_qual (struct d_info *di)
+{
+  char peek = d_peek_char (di);
+  if (peek == 'r' || peek == 'V' || peek == 'K')
+    return 1;
+  if (peek == 'D')
+    {
+      peek = d_peek_next_char (di);
+      if (peek == 'x' || peek == 'o' || peek == 'O' || peek == 'w')
+	return 1;
+    }
+  return 0;
+}
+
 /* <type> ::= <builtin-type>
           ::= <function-type>
           ::= <class-enum-type>
@@ -2312,9 +2354,7 @@
      __vector, and it treats it as order-sensitive when mangling
      names.  */
 
-  peek = d_peek_char (di);
-  if (peek == 'r' || peek == 'V' || peek == 'K'
-      || (peek == 'D' && d_peek_next_char (di) == 'x'))
+  if (next_is_type_qual (di))
     {
       struct demangle_component **pret;
 
@@ -2349,6 +2389,7 @@
 
   can_subst = 1;
 
+  peek = d_peek_char (di);
   switch (peek)
     {
     case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
@@ -2636,10 +2677,10 @@
 
   pstart = pret;
   peek = d_peek_char (di);
-  while (peek == 'r' || peek == 'V' || peek == 'K'
-	 || (peek == 'D' && d_peek_next_char (di) == 'x'))
+  while (next_is_type_qual (di))
     {
       enum demangle_component_type t;
+      struct demangle_component *right = NULL;
 
       d_advance (di, 1);
       if (peek == 'r')
@@ -2665,12 +2706,41 @@
 	}
       else
 	{
-	  t = DEMANGLE_COMPONENT_TRANSACTION_SAFE;
-	  di->expansion += sizeof "transaction_safe";
-	  d_advance (di, 1);
+	  peek = d_next_char (di);
+	  if (peek == 'x')
+	    {
+	      t = DEMANGLE_COMPONENT_TRANSACTION_SAFE;
+	      di->expansion += sizeof "transaction_safe";
+	    }
+	  else if (peek == 'o'
+		   || peek == 'O')
+	    {
+	      t = DEMANGLE_COMPONENT_NOEXCEPT;
+	      di->expansion += sizeof "noexcept";
+	      if (peek == 'O')
+		{
+		  right = d_expression (di);
+		  if (right == NULL)
+		    return NULL;
+		  if (! d_check_char (di, 'E'))
+		    return NULL;
+		}
+	    }
+	  else if (peek == 'w')
+	    {
+	      t = DEMANGLE_COMPONENT_THROW_SPEC;
+	      di->expansion += sizeof "throw";
+	      right = d_parmlist (di);
+	      if (right == NULL)
+		return NULL;
+	      if (! d_check_char (di, 'E'))
+		return NULL;
+	    }
+	  else
+	    return NULL;
 	}
 
-      *pret = d_make_comp (di, t, NULL, NULL);
+      *pret = d_make_comp (di, t, NULL, right);
       if (*pret == NULL)
 	return NULL;
       pret = &d_left (*pret);
@@ -3769,7 +3839,7 @@
 	    {
 	      const char *s;
 	      int len;
-	      struct demangle_component *c;
+	      struct demangle_component *dc;
 
 	      if (p->set_last_name != NULL)
 		di->last_name = d_make_sub (di, p->set_last_name,
@@ -3785,15 +3855,15 @@
 		  len = p->simple_len;
 		}
 	      di->expansion += len;
-	      c = d_make_sub (di, s, len);
+	      dc = d_make_sub (di, s, len);
 	      if (d_peek_char (di) == 'B')
 		{
 		  /* If there are ABI tags on the abbreviation, it becomes
 		     a substitution candidate.  */
-		  c = d_abi_tags (di, c);
-		  d_add_substitution (di, c);
+		  dc = d_abi_tags (di, dc);
+		  d_add_substitution (di, dc);
 		}
-	      return c;
+	      return dc;
 	    }
 	}
 
@@ -3961,6 +4031,8 @@
     case DEMANGLE_COMPONENT_REFERENCE_THIS:
     case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
     case DEMANGLE_COMPONENT_TRANSACTION_SAFE:
+    case DEMANGLE_COMPONENT_NOEXCEPT:
+    case DEMANGLE_COMPONENT_THROW_SPEC:
     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
     case DEMANGLE_COMPONENT_POINTER:
     case DEMANGLE_COMPONENT_COMPLEX:
@@ -4155,8 +4227,12 @@
 
   {
 #ifdef CP_DYNAMIC_ARRAYS
-    __extension__ struct d_saved_scope scopes[dpi.num_saved_scopes];
-    __extension__ struct d_print_template temps[dpi.num_copy_templates];
+    /* Avoid zero-length VLAs, which are prohibited by the C99 standard
+       and flagged as errors by Address Sanitizer.  */
+    __extension__ struct d_saved_scope scopes[(dpi.num_saved_scopes > 0)
+                                              ? dpi.num_saved_scopes : 1];
+    __extension__ struct d_print_template temps[(dpi.num_copy_templates > 0)
+                                                ? dpi.num_copy_templates : 1];
 
     dpi.saved_scopes = scopes;
     dpi.copy_templates = temps;
@@ -4571,12 +4647,7 @@
 	    adpm[i].templates = dpi->templates;
 	    ++i;
 
-	    if (typed_name->type != DEMANGLE_COMPONENT_RESTRICT_THIS
-		&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS
-		&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS
-		&& typed_name->type != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS
-		&& typed_name->type != DEMANGLE_COMPONENT_TRANSACTION_SAFE
-		&& typed_name->type != DEMANGLE_COMPONENT_REFERENCE_THIS)
+	    if (!is_fnqual_component_type (typed_name->type))
 	      break;
 
 	    typed_name = d_left (typed_name);
@@ -4613,13 +4684,7 @@
 		d_print_error (dpi);
 		return;
 	      }
-	    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS
-		   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS
-		   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS
-		   || local_name->type == DEMANGLE_COMPONENT_REFERENCE_THIS
-		   || local_name->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE
-		   || (local_name->type
-		       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))
+	    while (is_fnqual_component_type (local_name->type))
 	      {
 		if (i >= sizeof adpm / sizeof adpm[0])
 		  {
@@ -4944,16 +5009,11 @@
       }
       /* Fall through.  */
 
-    case DEMANGLE_COMPONENT_RESTRICT_THIS:
-    case DEMANGLE_COMPONENT_VOLATILE_THIS:
-    case DEMANGLE_COMPONENT_CONST_THIS:
-    case DEMANGLE_COMPONENT_REFERENCE_THIS:
-    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
     case DEMANGLE_COMPONENT_POINTER:
     case DEMANGLE_COMPONENT_COMPLEX:
     case DEMANGLE_COMPONENT_IMAGINARY:
-    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:
+    FNQUAL_COMPONENT_CASE:
     modifier:
       {
 	/* We keep a list of modifiers on the stack.  */
@@ -5658,13 +5718,7 @@
 
   if (mods->printed
       || (! suffix
-	  && (mods->mod->type == DEMANGLE_COMPONENT_RESTRICT_THIS
-	      || mods->mod->type == DEMANGLE_COMPONENT_VOLATILE_THIS
-	      || mods->mod->type == DEMANGLE_COMPONENT_CONST_THIS
-	      || mods->mod->type == DEMANGLE_COMPONENT_REFERENCE_THIS
-	      || mods->mod->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE
-	      || (mods->mod->type
-		  == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))))
+	  && (is_fnqual_component_type (mods->mod->type))))
     {
       d_print_mod_list (dpi, options, mods->next, suffix);
       return;
@@ -5717,12 +5771,7 @@
 	  dc = dc->u.s_unary_num.sub;
 	}
 
-      while (dc->type == DEMANGLE_COMPONENT_RESTRICT_THIS
-	     || dc->type == DEMANGLE_COMPONENT_VOLATILE_THIS
-	     || dc->type == DEMANGLE_COMPONENT_CONST_THIS
-	     || dc->type == DEMANGLE_COMPONENT_REFERENCE_THIS
-	     || dc->type == DEMANGLE_COMPONENT_TRANSACTION_SAFE
-	     || dc->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)
+      while (is_fnqual_component_type (dc->type))
 	dc = d_left (dc);
 
       d_print_comp (dpi, options, dc);
@@ -5761,6 +5810,24 @@
     case DEMANGLE_COMPONENT_TRANSACTION_SAFE:
       d_append_string (dpi, " transaction_safe");
       return;
+    case DEMANGLE_COMPONENT_NOEXCEPT:
+      d_append_string (dpi, " noexcept");
+      if (d_right (mod))
+	{
+	  d_append_char (dpi, '(');
+	  d_print_comp (dpi, options, d_right (mod));
+	  d_append_char (dpi, ')');
+	}
+      return;
+    case DEMANGLE_COMPONENT_THROW_SPEC:
+      d_append_string (dpi, " throw");
+      if (d_right (mod))
+	{
+	  d_append_char (dpi, '(');
+	  d_print_comp (dpi, options, d_right (mod));
+	  d_append_char (dpi, ')');
+	}
+      return;
     case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:
       d_append_char (dpi, ' ');
       d_print_comp (dpi, options, d_right (mod));
@@ -5773,11 +5840,13 @@
     case DEMANGLE_COMPONENT_REFERENCE_THIS:
       /* For the ref-qualifier, put a space before the &.  */
       d_append_char (dpi, ' ');
+      /* FALLTHRU */
     case DEMANGLE_COMPONENT_REFERENCE:
       d_append_char (dpi, '&');
       return;
     case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
       d_append_char (dpi, ' ');
+      /* FALLTHRU */
     case DEMANGLE_COMPONENT_RVALUE_REFERENCE:
       d_append_string (dpi, "&&");
       return;
@@ -5846,12 +5915,7 @@
 	  need_space = 1;
 	  need_paren = 1;
 	  break;
-	case DEMANGLE_COMPONENT_RESTRICT_THIS:
-	case DEMANGLE_COMPONENT_VOLATILE_THIS:
-	case DEMANGLE_COMPONENT_CONST_THIS:
-	case DEMANGLE_COMPONENT_REFERENCE_THIS:
-	case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
-	case DEMANGLE_COMPONENT_TRANSACTION_SAFE:
+	FNQUAL_COMPONENT_CASE:
 	  break;
 	default:
 	  break;
@@ -6393,7 +6457,6 @@
 	  case DEMANGLE_COMPONENT_CONST_THIS:
 	  case DEMANGLE_COMPONENT_REFERENCE_THIS:
 	  case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:
-	  case DEMANGLE_COMPONENT_TRANSACTION_SAFE:
 	  default:
 	    dc = NULL;
 	    break;
--- a/src/libiberty/cplus-dem.c
+++ b/src/libiberty/cplus-dem.c
@@ -144,6 +144,9 @@
   string* previous_argument; /* The last function argument demangled.  */
   int nrepeats;         /* The number of times to repeat the previous
 			   argument.  */
+  int *proctypevec;     /* Indices of currently processed remembered typevecs.  */
+  int proctypevec_size;
+  int nproctypes;
 };
 
 #define PRINT_ANSI_QUALIFIERS (work -> options & DMGL_ANSI)
@@ -244,6 +247,7 @@
   tk_none,
   tk_pointer,
   tk_reference,
+  tk_rvalue_reference,
   tk_integral,
   tk_bool,
   tk_char,
@@ -435,6 +439,10 @@
 
 static void remember_type (struct work_stuff *, const char *, int);
 
+static void push_processed_type (struct work_stuff *, int);
+
+static void pop_processed_type (struct work_stuff *);
+
 static void remember_Btype (struct work_stuff *, const char *, int, int);
 
 static int register_Btype (struct work_stuff *);
@@ -903,7 +911,7 @@
   int len0;
   const char* p;
   char *d;
-  char *demangled;
+  char *demangled = NULL;
   
   /* Discard leading _ada_, which is used for library level subprograms.  */
   if (strncmp (mangled, "_ada_", 5) == 0)
@@ -1148,6 +1156,7 @@
   return demangled;
 
  unknown:
+  XDELETEVEC (demangled);
   len0 = strlen (mangled);
   demangled = XNEWVEC (char, len0 + 3);
 
@@ -1301,6 +1310,10 @@
       memcpy (to->btypevec[i], from->btypevec[i], len);
     }
 
+  if (from->proctypevec)
+    to->proctypevec =
+      XDUPVEC (int, from->proctypevec, from->proctypevec_size);
+
   if (from->ntmpl_args)
     to->tmpl_argvec = XNEWVEC (char *, from->ntmpl_args);
 
@@ -1329,11 +1342,17 @@
   /* Discard the remembered types, if any.  */
 
   forget_types (work);
-  if (work -> typevec != NULL)
+  if (work->typevec != NULL)
     {
-      free ((char *) work -> typevec);
-      work -> typevec = NULL;
-      work -> typevec_size = 0;
+      free ((char *) work->typevec);
+      work->typevec = NULL;
+      work->typevec_size = 0;
+    }
+  if (work->proctypevec != NULL)
+    {
+      free (work->proctypevec);
+      work->proctypevec = NULL;
+      work->proctypevec_size = 0;
     }
   if (work->tmpl_argvec)
     {
@@ -1638,9 +1657,7 @@
 	      (*mangled)++;
 	      break;
 	    }
-	  else
-	    /* fall through */
-	    {;}
+	  /* fall through */
 
 	default:
 	  if (AUTO_DEMANGLING || GNU_DEMANGLING)
@@ -2042,7 +2059,8 @@
     }
   else if (tk == tk_real)
     success = demangle_real_value (work, mangled, s);
-  else if (tk == tk_pointer || tk == tk_reference)
+  else if (tk == tk_pointer || tk == tk_reference
+	   || tk == tk_rvalue_reference)
     {
       if (**mangled == 'Q')
 	success = demangle_qualified (work, mangled, s,
@@ -2051,7 +2069,8 @@
       else
 	{
 	  int symbol_len  = consume_count (mangled);
-	  if (symbol_len == -1)
+	  if (symbol_len == -1
+	      || symbol_len > (long) strlen (*mangled))
 	    return -1;
 	  if (symbol_len == 0)
 	    string_appendn (s, "0", 1);
@@ -3552,6 +3571,8 @@
 do_type (struct work_stuff *work, const char **mangled, string *result)
 {
   int n;
+  int i;
+  int is_proctypevec;
   int done;
   int success;
   string decl;
@@ -3564,6 +3585,7 @@
 
   done = 0;
   success = 1;
+  is_proctypevec = 0;
   while (success && !done)
     {
       int member;
@@ -3588,6 +3610,14 @@
 	    tk = tk_reference;
 	  break;
 
+	  /* An rvalue reference type */
+	case 'O':
+	  (*mangled)++;
+	  string_prepend (&decl, "&&");
+	  if (tk == tk_none)
+	    tk = tk_rvalue_reference;
+	  break;
+
 	  /* An array */
 	case 'A':
 	  {
@@ -3611,13 +3641,20 @@
 	/* A back reference to a previously seen type */
 	case 'T':
 	  (*mangled)++;
-	  if (!get_count (mangled, &n) || n >= work -> ntypes)
+	  if (!get_count (mangled, &n) || n < 0 || n >= work -> ntypes)
 	    {
 	      success = 0;
 	    }
 	  else
-	    {
-	      remembered_type = work -> typevec[n];
+	    for (i = 0; i < work->nproctypes; i++)
+	      if (work -> proctypevec [i] == n)
+	        success = 0;
+
+	  if (success)
+	    {    
+	      is_proctypevec = 1;
+	      push_processed_type (work, n);
+	      remembered_type = work->typevec[n];
 	      mangled = &remembered_type;
 	    }
 	  break;
@@ -3645,7 +3682,6 @@
 	  break;
 
 	case 'M':
-	case 'O':
 	  {
 	    type_quals = TYPE_UNQUALIFIED;
 
@@ -3789,7 +3825,7 @@
     /* A back reference to a previously seen squangled type */
     case 'B':
       (*mangled)++;
-      if (!get_count (mangled, &n) || n >= work -> numb)
+      if (!get_count (mangled, &n) || n < 0 || n >= work -> numb)
 	success = 0;
       else
 	string_append (result, work->btypevec[n]);
@@ -3840,6 +3876,9 @@
     string_delete (result);
   string_delete (&decl);
 
+  if (is_proctypevec)
+    pop_processed_type (work); 
+
   if (success)
     /* Assume an integral type, if we're not sure.  */
     return (int) ((tk == tk_none) ? tk_integral : tk);
@@ -3983,6 +4022,7 @@
 	  success = 0;
 	  break;
 	}
+      /* fall through */
     case 'I':
       (*mangled)++;
       if (**mangled == '_')
@@ -4130,7 +4170,8 @@
 
   literal_len = consume_count (mangled);
 
-  if (literal_len <= 0)
+  if (literal_len <= 0
+      || literal_len > (long) strlen (*mangled))
     return 0;
 
   /* Literal parameters are names of arrays, functions, etc.  and the
@@ -4252,6 +4293,41 @@
 }
 
 static void
+push_processed_type (struct work_stuff *work, int typevec_index)
+{
+  if (work->nproctypes >= work->proctypevec_size)
+    {
+      if (!work->proctypevec_size)
+	{
+	  work->proctypevec_size = 4;
+	  work->proctypevec = XNEWVEC (int, work->proctypevec_size);
+	}
+      else 
+	{
+	  if (work->proctypevec_size < 16)
+	    /* Double when small.  */
+	    work->proctypevec_size *= 2;
+	  else
+	    {
+	      /* Grow slower when large.  */
+	      if (work->proctypevec_size > (INT_MAX / 3) * 2)
+                xmalloc_failed (INT_MAX);
+              work->proctypevec_size = (work->proctypevec_size * 3 / 2);
+	    }   
+          work->proctypevec
+            = XRESIZEVEC (int, work->proctypevec, work->proctypevec_size);
+	}
+    }
+    work->proctypevec [work->nproctypes++] = typevec_index;
+}
+
+static void
+pop_processed_type (struct work_stuff *work)
+{
+  work->nproctypes--;
+}
+
+static void
 remember_type (struct work_stuff *work, const char *start, int len)
 {
   char *tem;
@@ -4515,10 +4591,13 @@
 		{
 		  string_append (declp, ", ");
 		}
+	      push_processed_type (work, t);  
 	      if (!do_arg (work, &tem, &arg))
 		{
+		  pop_processed_type (work);
 		  return (0);
 		}
+	      pop_processed_type (work);
 	      if (PRINT_ARG_TYPES)
 		{
 		  string_appends (declp, &arg);
--- a/src/libiberty/hashtab.c
+++ b/src/libiberty/hashtab.c
@@ -962,17 +962,17 @@
   c += length;
   switch(len)              /* all the case statements fall through */
     {
-    case 11: c+=((hashval_t)k[10]<<24);
-    case 10: c+=((hashval_t)k[9]<<16);
-    case 9 : c+=((hashval_t)k[8]<<8);
+    case 11: c+=((hashval_t)k[10]<<24);	/* fall through */
+    case 10: c+=((hashval_t)k[9]<<16);	/* fall through */
+    case 9 : c+=((hashval_t)k[8]<<8);	/* fall through */
       /* the first byte of c is reserved for the length */
-    case 8 : b+=((hashval_t)k[7]<<24);
-    case 7 : b+=((hashval_t)k[6]<<16);
-    case 6 : b+=((hashval_t)k[5]<<8);
-    case 5 : b+=k[4];
-    case 4 : a+=((hashval_t)k[3]<<24);
-    case 3 : a+=((hashval_t)k[2]<<16);
-    case 2 : a+=((hashval_t)k[1]<<8);
+    case 8 : b+=((hashval_t)k[7]<<24);	/* fall through */
+    case 7 : b+=((hashval_t)k[6]<<16);	/* fall through */
+    case 6 : b+=((hashval_t)k[5]<<8);	/* fall through */
+    case 5 : b+=k[4];			/* fall through */
+    case 4 : a+=((hashval_t)k[3]<<24);	/* fall through */
+    case 3 : a+=((hashval_t)k[2]<<16);	/* fall through */
+    case 2 : a+=((hashval_t)k[1]<<8);	/* fall through */
     case 1 : a+=k[0];
       /* case 0: nothing left to add */
     }
--- a/src/libiberty/make-relative-prefix.c
+++ b/src/libiberty/make-relative-prefix.c
@@ -233,6 +233,7 @@
   int i, n, common;
   int needed_len;
   char *ret = NULL, *ptr, *full_progname;
+  char *alloc_ptr = NULL;
 
   if (progname == NULL || bin_prefix == NULL || prefix == NULL)
     return NULL;
@@ -256,7 +257,10 @@
 #ifdef HAVE_HOST_EXECUTABLE_SUFFIX
 	  len += strlen (HOST_EXECUTABLE_SUFFIX);
 #endif
-	  nstore = (char *) alloca (len);
+	  if (len < MAX_ALLOCA_SIZE)
+	    nstore = (char *) alloca (len);
+	  else
+	    alloc_ptr = nstore = (char *) malloc (len);
 
 	  startp = endp = temp;
 	  while (1)
@@ -312,12 +316,12 @@
   else
     full_progname = strdup (progname);
   if (full_progname == NULL)
-    return NULL;
+    goto bailout;
 
   prog_dirs = split_directories (full_progname, &prog_num);
   free (full_progname);
   if (prog_dirs == NULL)
-    return NULL;
+    goto bailout;
 
   bin_dirs = split_directories (bin_prefix, &bin_num);
   if (bin_dirs == NULL)
@@ -395,6 +399,7 @@
   free_split_directories (prog_dirs);
   free_split_directories (bin_dirs);
   free_split_directories (prefix_dirs);
+  free (alloc_ptr);
 
   return ret;
 }
--- a/src/libiberty/pex-win32.c
+++ b/src/libiberty/pex-win32.c
@@ -370,6 +370,8 @@
 	      cmdline_len++;
 	    }
 	}
+      if (j == 0)
+	needs_quotes = 1;
       /* Trailing backslashes also need to be escaped because they will be
          followed by the terminating quote.  */
       if (needs_quotes)
@@ -394,6 +396,8 @@
               break;
             }
         }
+      if (j == 0)
+	needs_quotes = 1;
 
       if (needs_quotes)
         {
--- a/src/libiberty/regex.c
+++ b/src/libiberty/regex.c
@@ -2493,6 +2493,7 @@
           if ((syntax & RE_BK_PLUS_QM)
               || (syntax & RE_LIMITED_OPS))
             goto normal_char;
+	  /* Fall through.  */
         handle_plus:
         case '*':
           /* If there is no previous pattern... */
@@ -6697,6 +6698,7 @@
                 {
                   case jump_n:
 		    is_a_jump_n = true;
+		    /* Fall through.  */
                   case pop_failure_jump:
 		  case maybe_pop_jump:
 		  case jump:
@@ -7125,7 +7127,7 @@
               DEBUG_PRINT1 ("  Match => jump.\n");
 	      goto unconditional_jump;
 	    }
-        /* Note fall through.  */
+        /* Fall through.  */
 
 
 	/* The end of a simple repeat has a pop_failure_jump back to
@@ -7150,7 +7152,7 @@
                                dummy_low_reg, dummy_high_reg,
                                reg_dummy, reg_dummy, reg_info_dummy);
           }
-	  /* Note fall through.  */
+	  /* Fall through.  */
 
 	unconditional_jump:
 #ifdef _LIBC
@@ -7453,6 +7455,7 @@
                 {
                 case jump_n:
                   is_a_jump_n = true;
+		  /* Fall through.  */
                 case maybe_pop_jump:
                 case pop_failure_jump:
                 case jump:
@@ -7718,6 +7721,7 @@
 
     case set_number_at:
       p1 += 2 * OFFSET_ADDRESS_SIZE;
+      return false;
 
     default:
       /* All other opcodes mean we cannot match the empty string.  */
--- a/src/libiberty/testsuite/demangle-expected
+++ b/src/libiberty/testsuite/demangle-expected
@@ -31,6 +31,11 @@
 ArrowLine::ArrowheadIntersects
 #
 --format=gnu --no-params
+ArrowheadIntersects__9ArrowLineP9ArrowheadO6BoxObjP7Graphic
+ArrowLine::ArrowheadIntersects(Arrowhead *, BoxObj &&, Graphic *)
+ArrowLine::ArrowheadIntersects
+#
+--format=gnu --no-params
 AtEnd__13ivRubberGroup
 ivRubberGroup::AtEnd(void)
 ivRubberGroup::AtEnd
@@ -51,6 +56,11 @@
 TextCode::CoreConstDecls
 #
 --format=gnu --no-params
+CoreConstDecls__8TextCodeO7ostream
+TextCode::CoreConstDecls(ostream &&)
+TextCode::CoreConstDecls
+#
+--format=gnu --no-params
 Detach__8StateVarP12StateVarView
 StateVar::Detach(StateVarView *)
 StateVar::Detach
@@ -66,21 +76,41 @@
 RelateManip::Effect
 #
 --format=gnu --no-params
+Effect__11RelateManipO7ivEvent
+RelateManip::Effect(ivEvent &&)
+RelateManip::Effect
+#
+--format=gnu --no-params
 FindFixed__FRP4CNetP4CNet
 FindFixed(CNet *&, CNet *)
 FindFixed
 #
 --format=gnu --no-params
+FindFixed__FOP4CNetP4CNet
+FindFixed(CNet *&&, CNet *)
+FindFixed
+#
+--format=gnu --no-params
 Fix48_abort__FR8twolongs
 Fix48_abort(twolongs &)
 Fix48_abort
 #
 --format=gnu --no-params
+Fix48_abort__FO8twolongs
+Fix48_abort(twolongs &&)
+Fix48_abort
+#
+--format=gnu --no-params
 GetBarInfo__15iv2_6_VScrollerP13ivPerspectiveRiT2
 iv2_6_VScroller::GetBarInfo(ivPerspective *, int &, int &)
 iv2_6_VScroller::GetBarInfo
 #
 --format=gnu --no-params
+GetBarInfo__15iv2_6_VScrollerP13ivPerspectiveOiT2
+iv2_6_VScroller::GetBarInfo(ivPerspective *, int &&, int &&)
+iv2_6_VScroller::GetBarInfo
+#
+--format=gnu --no-params
 GetBgColor__C9ivPainter
 ivPainter::GetBgColor(void) const
 ivPainter::GetBgColor
@@ -986,11 +1016,21 @@
 List<VHDLEntity>::Pix::Pix
 #
 --format=gnu --no-params
+__Q2t4List1Z10VHDLEntity3PixOCQ2t4List1Z10VHDLEntity3Pix
+List<VHDLEntity>::Pix::Pix(List<VHDLEntity>::Pix const &&)
+List<VHDLEntity>::Pix::Pix
+#
+--format=gnu --no-params
 __Q2t4List1Z10VHDLEntity7elementRC10VHDLEntityPT0
 List<VHDLEntity>::element::element(VHDLEntity const &, List<VHDLEntity>::element *)
 List<VHDLEntity>::element::element
 #
 --format=gnu --no-params
+__Q2t4List1Z10VHDLEntity7elementOC10VHDLEntityPT0
+List<VHDLEntity>::element::element(VHDLEntity const &&, List<VHDLEntity>::element *)
+List<VHDLEntity>::element::element
+#
+--format=gnu --no-params
 __Q2t4List1Z10VHDLEntity7elementRCQ2t4List1Z10VHDLEntity7element
 List<VHDLEntity>::element::element(List<VHDLEntity>::element const &)
 List<VHDLEntity>::element::element
@@ -1036,6 +1076,11 @@
 PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX
 #
 --format=gnu --no-params
+__t4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntityOCt4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
+PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX(PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> > const &&)
+PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> >::PixX
+#
+--format=gnu --no-params
 nextE__C11VHDLLibraryRt4PixX3Z11VHDLLibraryZ14VHDLLibraryRepZt4List1Z10VHDLEntity
 VHDLLibrary::nextE(PixX<VHDLLibrary, VHDLLibraryRep, List<VHDLEntity> > &) const
 VHDLLibrary::nextE
@@ -1261,6 +1306,11 @@
 smanip_int::smanip_int
 #
 --format=lucid --no-params
+__ct__10smanip_intFPFO3iosi_O3iosi
+smanip_int::smanip_int(ios &&(*)(ios &&, int), int)
+smanip_int::smanip_int
+#
+--format=lucid --no-params
 __ct__11fstreambaseFi
 fstreambase::fstreambase(int)
 fstreambase::fstreambase
@@ -1281,6 +1331,11 @@
 smanip_long::smanip_long
 #
 --format=lucid --no-params
+__ct__11smanip_longFPFO3iosl_O3iosl
+smanip_long::smanip_long(ios &&(*)(ios &&, long), long)
+smanip_long::smanip_long
+#
+--format=lucid --no-params
 __ct__11stdiostreamFP4FILE
 stdiostream::stdiostream(FILE *)
 stdiostream::stdiostream
@@ -1321,6 +1376,11 @@
 foo::foo
 #
 --format=lucid --no-params
+__ct__3fooFO3foo
+foo::foo(foo &&)
+foo::foo
+#
+--format=lucid --no-params
 __ct__3fooFi
 foo::foo(int)
 foo::foo
@@ -1336,6 +1396,11 @@
 foo::foo
 #
 --format=lucid --no-params
+__ct__3fooFiO3fooT1T2T1T2
+foo::foo(int, foo &&, int, foo &&, int, foo &&)
+foo::foo
+#
+--format=lucid --no-params
 __ct__3iosFP9streambuf
 ios::ios(streambuf *)
 ios::ios
@@ -1811,6 +1876,11 @@
 foo
 #
 --format=lucid --no-params
+foo__FiO3fooT1T2T1T2
+foo(int, foo &&, int, foo &&, int, foo &&)
+foo
+#
+--format=lucid --no-params
 foo___3barFl
 bar::foo_(long)
 bar::foo_
@@ -2561,6 +2631,11 @@
 DListNode<RLabel &>::DListNode
 #
 --format=arm --no-params
+__ct__25DListNode__pt__9_O6RLabelFO6RLabelP25DListNode__pt__9_O6RLabelT2
+DListNode<RLabel &&>::DListNode(RLabel &&, DListNode<RLabel &&> *, DListNode<RLabel &&> *)
+DListNode<RLabel &&>::DListNode
+#
+--format=arm --no-params
 bar__3fooFiT16FooBar
 foo::bar(int, int, FooBar)
 foo::bar
@@ -2991,6 +3066,11 @@
 DListNode<RLabel &>::DListNode
 #
 --format=hp --no-params
+__ct__9DListNodeXTO6RLabel__FO6RLabelP9DListNodeXTO6RLabel_T2
+DListNode<RLabel &&>::DListNode(RLabel &&, DListNode<RLabel &&> *, DListNode<RLabel &&> *)
+DListNode<RLabel &&>::DListNode
+#
+--format=hp --no-params
 elem__6vectorXTiUP34__Fi
 vector<int,34U>::elem(int)
 vector<int,34U>::elem
@@ -3021,16 +3101,31 @@
 vector<int,-67,4000U,short &>::elem
 #
 --format=hp --no-params
+elem__6vectorXTiSN67UP4000TOs__Fi
+vector<int,-67,4000U,short &&>::elem(int)
+vector<int,-67,4000U,short &&>::elem
+#
+--format=hp --no-params
 elem__6vectorXTiSN67TRdTFPv_i__Fi
 vector<int,-67,double &,int (void *)>::elem(int)
 vector<int,-67,double &,int (void *)>::elem
 #
 --format=hp --no-params
+elem__6vectorXTiSN67TOdTFPv_i__Fi
+vector<int,-67,double &&,int (void *)>::elem(int)
+vector<int,-67,double &&,int (void *)>::elem
+#
+--format=hp --no-params
 X__6vectorXTiSN67TdTPvUP5TRs
 vector<int,-67,double,void *,5U,short &>::X
 vector<int,-67,double,void *,5U,short &>::X
 #
 --format=hp --no-params
+X__6vectorXTiSN67TdTPvUP5TOs
+vector<int,-67,double,void *,5U,short &&>::X
+vector<int,-67,double,void *,5U,short &&>::X
+#
+--format=hp --no-params
 elem__6vectorXTiA3foo__Fi
 vector<int,&foo>::elem(int)
 vector<int,&foo>::elem
@@ -3071,6 +3166,11 @@
 Spec<int,int &,int>::spec
 #
 --format=hp --no-params
+spec__17Spec<#1,#1.&&,#1>XTiTOiTi_FPi
+Spec<int,int &&,int>::spec(int *)
+Spec<int,int &&,int>::spec
+#
+--format=hp --no-params
 add__XTc_FcT1
 add<char>(char, char)
 add<char>
@@ -3101,6 +3201,11 @@
 C<Test, Test::output> call<Test>
 #
 --format=gnu --no-params
+call__H1Z4Test_OX01_t1C2ZX01PMX01FPX01i_vQ2X016output
+C<Test, Test::output> call<Test>(Test &&)
+C<Test, Test::output> call<Test>
+#
+--format=gnu --no-params
 fn__FPQ21n1cPMQ21n1cFPQ21n1c_i
 fn(n::c *, int (n::c::*)(n::c *))
 fn
@@ -3126,6 +3231,11 @@
 int foo<TA<int const &, NA<9> > >
 #
 --format=gnu --no-params
+foo__H1Zt2TA2ZOCiZt2NA1Ui9_X01_i
+int foo<TA<int const &&, NA<9> > >(TA<int const &&, NA<9> >)
+int foo<TA<int const &&, NA<9> > >
+#
+--format=gnu --no-params
 foo__H1Zt2TA2ZcZt2NA1Ui20_X01_i
 int foo<TA<char, NA<20> > >(TA<char, NA<20> >)
 int foo<TA<char, NA<20> > >
@@ -3402,6 +3512,11 @@
 _Z3fooILi2EEvRAplT_Li1E_i
 void foo<2>(int (&) [(2)+(1)])
 foo<2>
+#
+--format=gnu-v3 --no-params
+_Z3fooILi2EEvOAplT_Li1E_i
+void foo<2>(int (&&) [(2)+(1)])
+foo<2>
 # 
 --format=gnu-v3 --no-params
 _Z1fM1AKFvvE
@@ -4459,3 +4574,35 @@
 
 _Z80800000000000000000000
 _Z80800000000000000000000
+#
+# Tests write access violation PR70926
+
+0__Ot2m02R5T0000500000
+0__Ot2m02R5T0000500000
+#
+
+0__GT50000000000_
+0__GT50000000000_
+#
+
+__t2m05B500000000000000000_
+__t2m05B500000000000000000_
+#
+# Tests stack overflow PR71696
+
+__10%0__S4_0T0T0
+%0<>::%0(%0<>)
+
+# Inheriting constructor
+_ZN1DCI11BEi
+D::B(int)
+
+# exception-specification (C++17)
+_Z1fIvJiELb0EEvPDOT1_EFT_DpT0_E
+void f<void, int, false>(void (*)(int) noexcept(false))
+
+_Z1fIvJiELb0EEvPDoFT_DpT0_E
+void f<void, int, false>(void (*)(int) noexcept)
+
+_Z1fIvJiELb0EEvPDwiEFT_DpT0_E
+void f<void, int, false>(void (*)(int) throw(int))
--- a/src/libiberty/testsuite/test-pexecute.c
+++ b/src/libiberty/testsuite/test-pexecute.c
@@ -285,6 +285,20 @@
     ERROR ("echo exit status failed");
   pex_free (pex1);
 
+  /* Check empty parameters don't get lost.  */
+  pex1 = TEST_PEX_INIT (PEX_USE_PIPES, "temp");
+  subargv[1] = "echo";
+  subargv[2] = "foo";
+  subargv[3] = "";
+  subargv[4] = "bar";
+  subargv[5] = NULL;
+  TEST_PEX_RUN (pex1, 0, "./test-pexecute", subargv, NULL, NULL);
+  e = TEST_PEX_READ_OUTPUT (pex1);
+  CHECK_LINE (e, "foo  bar");  /* Two spaces!  */
+  if (TEST_PEX_GET_STATUS_1 (pex1) != 0)
+    ERROR ("echo exit status failed");
+  pex_free (pex1);
+
   pex1 = TEST_PEX_INIT (PEX_USE_PIPES, "temp");
   subargv[1] = "echo";
   subargv[2] = "bar";
--- a/src/libiberty/xmemdup.c
+++ b/src/libiberty/xmemdup.c
@@ -1,4 +1,4 @@
-/* xmemdup.c -- Duplicate a memory buffer, using xcalloc.
+/* xmemdup.c -- Duplicate a memory buffer, using xmalloc.
    This trivial function is in the public domain.
    Jeff Garzik, September 1999.  */
 
@@ -34,6 +34,8 @@
 PTR
 xmemdup (const PTR input, size_t copy_size, size_t alloc_size)
 {
-  PTR output = xcalloc (1, alloc_size);
+  PTR output = xmalloc (alloc_size);
+  if (alloc_size > copy_size)
+    memset ((char *) output + copy_size, 0, alloc_size - copy_size);
   return (PTR) memcpy (output, input, copy_size);
 }
--- a/src/include/libiberty.h
+++ b/src/include/libiberty.h
@@ -397,6 +397,17 @@
 /* Save files used for communication between processes.  */
 #define PEX_SAVE_TEMPS		0x4
 
+/* Max number of alloca bytes per call before we must switch to malloc.
+
+   ?? Swiped from gnulib's regex_internal.h header.  Is this actually
+   the case?  This number seems arbitrary, though sane.
+
+   The OS usually guarantees only one guard page at the bottom of the stack,
+   and a page size can be as small as 4096 bytes.  So we cannot safely
+   allocate anything larger than 4096 bytes.  Also care for the possibility
+   of a few compiler-allocated temporary stack slots.  */
+#define MAX_ALLOCA_SIZE	4032
+
 /* Prepare to execute one or more programs, with standard output of
    each program fed to standard input of the next.
    FLAGS	As above.
--- a/src/include/demangle.h
+++ b/src/include/demangle.h
@@ -449,7 +449,9 @@
   /* A transaction-safe function type.  */
   DEMANGLE_COMPONENT_TRANSACTION_SAFE,
   /* A cloned function.  */
-  DEMANGLE_COMPONENT_CLONE
+  DEMANGLE_COMPONENT_CLONE,
+  DEMANGLE_COMPONENT_NOEXCEPT,
+  DEMANGLE_COMPONENT_THROW_SPEC
 };
 
 /* Types which are only used internally.  */
